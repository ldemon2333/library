## 2.1.1 原始数据类型
Python 中的每个值都有一个类（class）来确定它的类型。拥有相同类的值，行为也相同。例如，整数 1 和 2 都是 `int` 类的实例，我们就可以使用相似的方法进行处理。例如，它们都可以取反或与另一个整数相加。内置的 `type` 函数允许我们检查任何值的类。
```py
>>> type(2)
<class 'int'>
```
到目前为止，我们使用的值都是 Python 语言中内置的少量的原始数据类型的实例。原始数据类型具有以下属性：

1. 有一些可以求解为原始数据类型的表达式，被称为字面量（literals）。
2. 有用于操作原始类型值的内置函数和操作符。

`int` 类是用于表示整数的原始数据类型。整数字面量（相邻的数字序列）会求解为 `int` 值，并且数学运算符可以操作这种值。

```py
>>> 12 + 3000000000000000000000000
3000000000000000000000012
```

# 2.3 序列
## 2.3.2 序列遍历
一个 `for` 循环语句由如下格式的单个子句组成：
```py
for <name> in <expression>:
    <suite>
```

`for` 循环语句按以下过程执行：

1. 执行头部（header）中的 `<expression>`，它必须产生一个可迭代（iterable）的值（译者注：可迭代的详细概念可见 _4.2 隐式序列_）
2. 对该可迭代值中的每个元素，按顺序：
    1. 将当前帧的 `<name>` 绑定到该元素值
    2. 执行 `<suite>`

这个计算过程中的一个重要结果是：执行 `for` 语句后，`<name>` 将绑定到序列的最后一个元素。所以 `for` 循环引入了另一种可以通过语句更新环境的方法。

**序列解包（Sequence unpacking）**：程序中的一个常见情况是序列的元素也是序列，但所有内部序列的长度是固定相同的。`for` 循环可以在头部的 `<name>` 中包含多个名称，来将每个元素序列“解包”到各自的元素中。

例如，我们可能有一个包含以列表为元素的 `pairs`，其中所有内部列表都只包含 2 个元素。

```py
>>> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
```

此时我们希望找到有多少第一元素和第二元素相同的内部元素对，下面的 `for` 循环在头部中包括两个名称，将 `x` 和 `y` 分别绑定到每对中的第一个元素和第二个元素。

```py
>>> same_count = 0
>>> for x, y in pairs:
        if x == y:
            same_count = same_count + 1
>>> same_count
2
```

## 2.3.3 序列处理
序列是复合数据的一种常见形式，常见到整个程序都可能围绕着这个单一的抽象来组织。具有序列作为输入输出的模块化组件可以混用和匹配以实现数据处理。将序列处理流程中的所有操作链接在一起可以定义复杂组件，其中每个操作都是简单和集中的。

**列表推导式（List Comprehensions）**：许多序列操作可以通过对序列中的每个元素使用一个固定表达式进行计算，并将结果值保存在结果序列中。在 Python 中，列表推导式是执行此类计算的表达式。

```py
>>> odds = [1, 3, 5, 7, 9]
>>> [x+1 for x in odds]
[2, 4, 6, 8, 10]
```

上面的 `for` 关键字并不是 `for` 循环的一部分，而是列表推导式的一部分，因为它被包含在方括号里。子表达式 `x+1` 通过绑定到 `odds` 中每个元素的变量 `x` 进行求值，并将结果值收集到列表中。

另一个常见的序列操作是选取原序列中满足某些条件的值。列表推导式也可以表达这种模式，例如选择 `odds` 中所有可以整除 25 的元素。

```py
>>> [x for x in odds if 25 % x == 0]
[1, 5]
```

列表推导式的一般形式是：

```py
[<map expression> for <name> in <sequence expression> if <filter expression>]
```

为了计算列表推导式，Python 首先执行 `<sequence expression>`，它必须返回一个可迭代值。然后将每个元素值按顺序绑定到 `<name>`，再执行 `<filter expression>`，如果结果为真值，则计算 `<map expression>`，`<map expression>` 的结果将被收集到结果列表中。


# 2.4 可变数据
## 2.4.1 对象隐喻
对象将数据的值和行为结合到了一起。

对象有属性，方法

## 2.4.2 序列对象
像数字这样的基本数据类型的实例是不可变（immutable）的。它们所代表的值，在程序运行期间是不可以更改的。 另一方面，列表就是可变的（mutable）。

**数据共享和身份（Sharing and Identity）**

尽管两个列表的元素值相同，但他们仍然可能是完全不同的两个列表对象，所以我们需要一个机制来验证两个对象是否相同。Python 提供了 `is` 和 `is not` 两种比较操作符来验证两个变量是否指向同一个对象。如果两个对象的值完全相等，则说明它们两个是同一个对象，对其中任意一个对象的改动都将影响到另外一个。身份验证比简单的相等验证更准确。

最后两个比较说明了 `is` 和 `==` 的区别。前者是检验的是对象的内存地址，而后者只是判断内容是否相同。

**元组。** 元组是指 Python 内置类型 `tuple` 的实例对象，其是不可变序列。我们可以将不同数据用逗号分隔，用这种字面量的方式即可以创建一个元组。括号并不是必须的，但是一般都会加上。元组中可以放置任意对象。

```py
>>> 1, 2 + 3
(1, 5)
>>> ("the", 1, ("and", "only"))
('the', 1, ('and', 'only'))
>>> type( (10, 20) )
<class 'tuple'>
```

在批量赋值的场景下，元组会被隐式地使用到。将两个值批量赋值给两个变量时，实际上是创建了一个包含两个元素的元组，然后对其进行解构赋值。

## 2.4.3 字典
利用 `dictionary` 构造方法，我们可以将一个由键值对组成的列表转化为一个字典对象。
```py
>>> dict([(3, 9), (4, 16), (5, 25)])
{3: 9, 4: 16, 5: 25}
```

但是字典类型也有一些限制：

- 字典的 key 不可以是可变数据，也不能包含可变数据
- 一个 key 只能对应一个 value

第一个限制是由于字典在 Python 内部的实现机制导致的。字典类型具体的实现机制不在这里展开。简单来说，假设是 key 值告诉 Python 应该去内存中的什么位置找对应的键值对，如果 key 值本身发生了变化，那键值对在内存中的位置信息也就丢失了。比如，元组可以被用来做字典的 key 值，但是列表就不可以。

第二个限制是因为字典本身被设计为根据 key 去查找 value，只有 key 和 value 的绑定关系是唯一确定的，我们才能够找到对应的数据。

字典中一个很有用的方法是 `get`，它返回指定 key 在字典中对应的 value；如果该 key 在字典中不存在，则返回默认值。`get` 方法接收两个参数，一个 key，一个默认值。
```py
>>> numerals.get('A', 0)
0
>>> numerals.get('V', 0)
5
```

与列表类似，字典也有推导式语法。其中，key 和 value 使用冒号分隔。字典推导式会创建一个新的字典对象。

```py
>>> {x: x*x for x in range(3,6)}
{3: 9, 4: 16, 5: 25}
```

## 2.4.4 局部状态
列表和字典拥有局部状态（local state），即它们可以在程序执行过程中的某个时间点修改自身的值。状态（state）就意味着当前的值有可能发生变化。

函数也是有状态的。举例来说，我们可以定义一个函数，来抽象从银行账户中取钱的过程。我们为这个函数命名为 `withdraw`，它接收一个参数，代表取钱的金额。如果账户中有足够的金额，`withdraw` 会返回取完钱以后的余额；否则，`withdraw` 会返回「余额不足」。假设我们账户里有 100 美元，调用 withdraw 应该得到如下结果：

```py
>>> withdraw(25)
75
>>> withdraw(25)
50
>>> withdraw(60)
'余额不足'
>>> withdraw(15)
35
```

在上面的代码中，表达式 `withdraw(25)` 被执行了两次，但是返回了不同的结果。因此，我们定义的这个函数不是纯函数（in-pure）。执行这个函数在返回内容的同时，还产生了其它副作用（side effects），导致多次调用同一个函数得到的结果却不相同。这里的副作用之所以会出现，是因为 `withdraw` 函数更改了它所在的栈帧之外的变量。

```py
>>> withdraw = make_withdraw(100)
```

`make_withdraw` 的实现需要一种新的声明形式：非局部（nonlocal）声明。当我们调用 `make_withdraw` 的时候，我们将初始余额声明为 `balance` 变量，然后我们再定义并返回一个局部函数 `withdraw`，它会在调用时更新并返回 balance 的值。

```py
>>> def make_withdraw(balance):
        """返回一个每次调用都会减少 balance 的 withdraw 函数"""
        def withdraw(amount):
            nonlocal balance                 # 声明 balance 是非局部的
            if amount > balance:
                return '余额不足'
            balance = balance - amount       # 重新绑定
            return balance
        return withdraw
    
```

当 balance 属性为声明为 nonlocal 后，每当它的值发生更改时，相应的变化都会同步更新到 `balance` 属性第一次被声明的位置。回想一下，在没有 noncal 声明之前，所有对 balance 的重新赋值操作都会在当前环境的第一帧中绑定。非局部语句指示名称不会出现在第一个（局部）帧或最后一个（全局）帧，而是出现在其他地方。

第一个 def 声明的表现符合我们的预期：它创建一个新的自定义函数并将该函数以 `make_withdraw` 为名绑定到全局帧中。随后调用 make_withdraw 创建并返回一个局部定义的函数 withdraw。参数 balance 则绑定在该函数的父帧中。最重要的是，在这个示例中，变量名 balance 只有一个绑定关系。

接下来，我们调用 `make_withdraw` 得到函数 `wd`，然后调用 `wd` 方法并入参 5。`withdraw` 函数执行在一个新的环境中，并且该环境的 `parent` 是定义 `withdraw` 函数的环境。跟踪 withdraw 的执行，我们可以发现 Python 中 nonlocal 声明的效果：当前执行帧之外的变量可以通过赋值语句更改。

非局部语句（nonlocal statement）会改变 withdraw 函数定义中剩余的所有赋值语句。在将 balance 声明为 nonlocal 后，任何尝试为 balance 赋值的语句，都不会直接在当前帧中寻找并更改 balance，而是找到定义 balance 变量的帧，并在该帧中更新该变量。如果在声明 nonlocal 之前 balance 还没有赋值，则 nonlocal 声明将会报错。

通过改变 balance 的绑定，我们也改变了 withdraw 函数。下一次调用该函数时，变量 balance 的值将会是 15，而不是 20。因此，当我们第二次调用 withdraw 时，返回值将是 12，而不是 17。第一次调用对 balance 的改变会影响到第二次调用的结果。

通过引入非局部语句，我们为赋值语句创建了双重作用。他们可以更改局部绑定 (local bindings)，也可以更改非局部绑定 (nonlocal bindings)。事实上，赋值语句已经有了很多作用：它们可以创建新的变量，也可以为现有变量重新赋值。赋值也可以改变列表和字典的内容。Python 中赋值语句的多种作用可能会使执行赋值语句时的效果变得不太明显。作为程序员，我们有责任清楚地记录代码，以便其他人可以理解赋值的效果。

