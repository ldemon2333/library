OS的作用就是来衔接计算机的硬件系统和软件系统，以使得整个计算机对程序员和用户而言更容易使用。例如，为了使得文本“Hello World”在计算机屏幕上显示，必须在特定的屏幕位置上画几百个像素。这可以通过参考硬件规范，编写相关的代码来完成，该代码在驻留RAM的屏幕映像中放置必要的比特位。

实际上，本书所描述的OS服务包含了最小规模的操作系统，主要是：（1）以一种对软件友好的方式封装了不同的硬件服务；（2）用不同的函数和抽象数据类型扩展了高级语言。在这个意义上的操作系统与语言的标准程序库的分界线就不是那么明显。事实上，某些现代语言（例如Java）就趋向于将很多经典的操作系统服务（比如GUI管理，内存管理，和多任务处理等）连同很多语言扩展一起打包到其标准程序库中。

按照这种模式，本章描述并构建的服务就可以被看作是简单的OS和Jack语言的标准程序库的集合。该OS被打包成一组Jack类，每个类通过Jack子程序调用来提供一组相关的服务。这个OS与工业级强度的操作系统有很多相似的特点，但是它仍然缺少大量的OS特性，比如进程管理、磁盘管理、通信等。

OS通常是由高级语言编写，并被编译成二进制形式，就像任何其他程序一样。Jack的OS也不例外，可以完全由Jack编写而成。然而与其他由高级语言编写的程序不同的是，操作系统代码必须了解它所运行的硬件平台。换句话说，为了对高层的应用程序员隐藏这些硬件细节，OS程序员必须编写能够直接操纵这些细节的代码（这个任务需要参考硬件规范文档）。方便的是，这可以利用Jack语言来做到。正如本章将看到的，Jack语言被定义成足够“低层级的”语言，以便能够允许它在需要时可以与硬件进行“亲密接触”。

# 12.1 背景知识
## 12.1.1 数学操作
这一节介绍乘法、除法以及平方根操作是如何在OS级别的软件中被有效实现的。要注意的是，这些数学操作的硬件实现同样也基于这里提到的算法。

**效率第一**
数学算法操作在n-位数上，在典型的计算机体系中，n=16，32或64。通常，期望运行时间与参数n成比例的算法。下面介绍一种有效的n-比特位的数乘法$x \cdot y$ 算法，它的运行时间是$O(n)$ ，而不是$O(x)$ 或$O(y)$。

**乘法**
![[Pasted image 20240707202359.png]]

图12.1中的算法对n-比特位的数执行$O(n)$次加法操作。

**除法**
计算两个n-比特位的数的除法$x/y$，一种简陋的方法是重复地从x上减去y，直到无法继续（即直到x<y)。该算法的运行时间明显与除法的商成正比，可能大到$O(x)$，即以n为指数。为了提高该算法的效率，可以在每次迭代中试着从x上减去y的一个较大的倍数。例如，如果x=891，y=5，这样马上就能断定可以从x上减去一百个5，剩余数仍然比5大，与原算法相比因此减少了100次迭代。这就是长除法的基本原理。

![[Pasted image 20240707203103.png]]

该递归算法的运行时间由递归的深度来决定。因此在每次递归中，y的值被乘上2，且一旦出现y>x立即结束，于是递归深度受到n（x的位数）的限制。每个递归层都包含了一个常数数量的加法，减法和乘法操作，意味着整个运行时间为$O(n)$个这样的操作。

因为每个乘法操作也需要$O(n)$次加法和减法操作，所以该算法被认为是次优的。但如果仔细观察，会发现可以不使用乘法来计算乘积$2\cdot q \cdot y$。我们可以根据在前一个递归层的该乘积值，使用加法来求出其当前的值。

**平方根**
可以采用很多不同的方法来有效地计算平方根，例如，牛顿-拉夫逊方法（Newton-Raphson method）或者泰勒级数展开式（Taylor series expansion）。对我们而言，可以利用二分查找（binary search）来计算平方根。

![[Pasted image 20240707203921.png]]

## 12.1.2 数字的字符串表示
计算机在内部使用二进制码来表示数字。然而人们习惯于用十进制的表示法来处理数字。因此，当人们要读取或者输入数字时，计算机必须进行进制转换。通常，这些工作是由OS的底层服务程序来处理。

## 12.1.3 内存管理
**动态内存分配**
计算机的程序会声明并使用各种类型的变量，包括如整数、布尔数等简单的数据类型以及如数组、对象等复杂的数据类型。高级语言的最大优点之一是程序员不必关心内存管理细节：比如为变量分配内存空间；以及当该变量不再使用时，回收围棋分配的内存空间。所有关于内存管理的琐碎工作都由编译器、操作系统和虚拟机在后端来完成。

不同变量的内存在程序生命周期中的不同时刻被分配。例如，静态变量在编译期间由编译器为其分配内存，而局部变量则在每个子程序开始运行时被分配在堆栈内。其他变量的内存则是在程序的执行过程中被动态分配，这就需要操作系统的帮助了。例如，每当Java程序创建新数组或新对象时，对应的内存块就会被分配，而这块内存块的大小只有在程序运行期间才能确定。当数组或对象不再使用时，其内存空间会被收回。在一些高级语言中（如C++和Jack），释放不再使用的内存空间是程序员的任务，然而在其他语言如Java中，会自动地产生“垃圾回收“。被用于进行动态内存分配的内存段称为堆（heap），负责管理这个资源的就是操作系统。

OS使用不同的技术来处理动态内存分配和去配。这些技术通常在两个称为alloc()和deAlloc()的函数中实现。我们提供两个算法版本：基本的算法版本和改进的算法版本。

**基本内存管理算法**
该算法所管理的数据结构就是一个单一的指针，成为$free$，它指向还未经过分配的内存的堆基地址。图12.6a展示了该算法。

![[Pasted image 20240709193031.png]]

显然，这个算法对内存的浪费程度很严重，因为它不回收那些不再被使用的变量所占用的内存。

**改进的内存分配算法**
该算法管理一个由可使用内存段构成的链表，称为freeList。每个内存段包含两个字段：该内存段的长度和指向链表中下个内存段的指针。这些字段可被保存在内存段起始的两个内存位置中。例如，length == segment[0]和segment.next == segment[1]。图12.6b例示了典型的freeList状态。

要分配指定大小的内存块时，该算法必须在freeList中搜索大小合适的内存段。有两种常用的启发式算法来完成此搜索任务。第一种是“最优适应（Best-fit）”算法，该算法在整个链表中搜索大小最匹配的内存段分配给变量。第二种是“最先适应（First-fit）”算法，该算法将链表中找到的第一个“大小能满足变量要求的内存段”分配给变量，一旦找到合适的段，就从中取出所需要的内存块（返回块起始位置的前一个位置，block[-1]，被用来保存其长度，在内存空间的去配过程中会用到该长度值）。接着，该段在freeLIst中被更新，成为分配之后剩余的部分。如果块中没有剩余的内存，或者若剩余部分太小，则从freeList中去掉整个段。

收回无用对象的内存块，该算法将收回的块追加到freeList中。

![[Pasted image 20240709194506.png]]

经过频繁分配、收回操作之后，图12.6b中所描述的动态分配机制会产生内存碎片。因此应该考虑一些“碎片整理”的操作，即将那些虽然在物理上连续而在freeList中从逻辑上被划分到不同内存段的内存区域合并起来。可以在对象被去配时，或alloc()没有找到合适内存块时执行碎片整理操作，也可依据其他条件来执行。

## 12.1.4 变长数组和字符串
现代语言中的常用方法是使用String类来提供创建并操纵字符串对象的服务。在物理上，字符串对象可以通过使用数组来实现。在创建字符串时，一般为该数组分配的空间足够用来保存可能的最大长度。而字符串的实际长度可能比最大值要短，且应在字符串对象的整个生命周期中保存该实际长度值。

## 12.1.5 输入/输出管理
实际的I/O操作是通过操作系统提供的服务实现的。

OS可以使用一组称为设备驱动（device driver）程序的OS服务来处理I/O底层操作，封装设备接口的物理细节，达到方便访问和使用设备的目的。本书中描述了处理两种最普遍的I/O设备——屏幕和键盘——的基本要件。在逻辑上将屏幕的处理分为两个独立的模块：图形输出处理和字符输出处理。

### 图形输出
**绘制像素**
现今的大多数计算机使用光栅（即raster，也称为位图，bitmap）显示技术。在位图屏幕中所能执行的唯一基本操作就是绘制一个像素（pixel），即在屏幕上绘制点（dot）， 屏幕的最左上角像素的坐标才是（0,0）。

在底层进行像素绘制是属于硬件操作，它依赖于屏幕和显示卡接口的具体细节。如果屏幕接口是基于RAM驻留内存的内存映像（memory map）进行构建的（Hack平台就是如此），那么将适当的二进制值写入到内存中代表该像素的内存单元，就可完成画像素的任务。

![[Pasted image 20240709195953.png]]

**绘制线条**
要在位图屏幕上的两个位置之间画一条线，最好的方法就是用一系列的像素来逼近连接两点之间那条“理想的”直线。注意，绘制所使用的“笔”仅能沿四个方向移动，分别是上、下、左、右四个方向。

**圆的绘制**

**字符输出**

**键盘处理**
跟前面一样，处理输入的方法是基于一系列级联的分层抽象。高级程序依赖于readLine抽象，readLine依赖于readChar抽象，而readChar又依赖于KeyPressed抽象，KeyPressed则依赖于硬件。