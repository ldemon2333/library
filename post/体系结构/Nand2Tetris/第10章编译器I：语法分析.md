编译（compilation）从概念上讲由两个不同的任务组成。首先，我们必须理解源程序的语法（syntax），以此来揭示程序的语义（semantics）。第一个任务通常称为语法分析（syntax analysis）；第二个任务，即代码生成（code generation）。

如果希望单独测试该语法分析器，就必须设计某种可行的方法来证明它“理解了”源程序。我们的方法是让语法分析器输出XML文件，其格式反映了输入程序的语法结构。通过观察生成的XML输出。

# 10.1 背景知识
![[Pasted image 20240705192739.png]]

## 10.1.1 词法分析
对程序进行语法分析的第一步，是将字符分组成字元，忽略空格和注释。这一步通常称为词法分析（lexical analysis）、扫描（scanning）或字元化（tokenizing）。

![[Pasted image 20240705193205.png]]

如图10.2所示，字元包括不同的种类，比如while是关键字（keyword），count是标识符（identifier），<=是操作符（operator）。

## 10.1.2 语法
上下文无关语法（context-free grammars）来描述。

![[Pasted image 20240705193740.png]]

## 10.1.3 语法分析（Parsing）

检查语法是否将所输入的文本看作合法输入，这个过程称为语法分析（parsing）。语法分析器（parser）生成的输出可以用称为语法分析树（parse tree）或导出树（derivation tree）的树状数据结构来描述。

![[Pasted image 20240705194055.png]]

**递归下降分析（Recursive Descent Parsing）** 
有很多算法可用来构建语法分析树。自顶向下的方法，也称为递归下降分析，是应用由语法规则描述的嵌套结构来尝试递归地分析字元集合形成的输入流（token stream）。

**LL(0)语法**
每当一个非终结符有多种可选择的导出规则时，其第一个字元足以确定该非终结符所属的表达式类型，而不会出现不确定的情况。具有这种属性的语法称为*LL(0)*。

# 10.2 规范详述
## 10.2.1 Jack语言语法
![[Pasted image 20240705194954.png]]

## 10.2.2 Jack语言的语法分析器
语法分析器（syntax analyzer）的主要目的是读取Jack程序，根据Jack语法“理解”其语法结构。“理解”的意思是语法分析器在处理过程中的每一步都必须确定当前读取的程序要素是expression或statement或variable name等等。语法分析器必须以完全递归的形式来保存语法结构的信息。

![[Pasted image 20240705195328.png]]
![[Pasted image 20240705195339.png]]

## 10.2.3 语法分析器的输入
Jack语法分析器接受单一的命令行参数，如下所示：
```
prompt> JackAnalyzer source
```
每个Xxx.jack文件都是字符流（即一系列字符）。根据Jack语言的语义元素（lexical elements）所指定的规则，该字符流应该被字元化，形成字元流（即一系列字元）。

## 10.2.4 语法分析器的输出
本章让语法分析器输出关于输入程序的XML文件，如图10.6：

![[Pasted image 20240705195950.png]]

语法分析器必须辨识语言构造中的两个主要类型：终结符和非终结符。

![[Pasted image 20240705200432.png]]
![[Pasted image 20240705200518.png]]

# 10.3 实现
构建Jack语言的语法分析器（syntax analyzer）所需的全部信息。本节将给出语法分析器的软件架构。
![[Pasted image 20240705200846.png]]

这些模块用来处理语言的语法。

# 10.4 观点
编译器并不需要显式地维护语法分析树。读取输入时就立即进行分析，在内存中并不存储编译器输入的整个源程序。
