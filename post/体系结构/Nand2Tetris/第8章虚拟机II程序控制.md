# 8.1 背景知识

对于在运行期的每个子程序调用，底层必须处理下面的一些细节：
- 将参数从调用者（caller）传递给被调用者（called subroutine）
- 在跳转并执行被调用者之前，先保存调用者的状态
- 为被调用者使用的局部变量分配空间
- 跳转并执行被调用者
- 将被调用者的运行结果返回给调用者
- 在从被调用者返回之前，回收其使用的内存空间
- 恢复调用者的状态
- 返回到调用语句之后的下一条语句继续执行

## 8.1.1 程序控制流

## 8.1.2 子程序调用

调用内置命令和调用用户定义的子程序之间的唯一区别是用户自定义子程序之前要有关键字call 。

帧（frame）来表达子程序的局部变量的集合。
堆栈是指全局堆栈。

![[Pasted image 20240703193635.png]]

基于堆栈调用的返回实现过程如图8.3所示。当我们用call xxx指令执行调用操作时，应该知道准确的返回地址：指令call xxx的下一条指令的内存地址，保存在调用者的帧里面。

# 8.2 VM 规范详述，第II部分

## 8.2.3 函数调用协议

![[Pasted image 20240703194248.png]]

每当VM函数开始运行（或者继续前面的执行）时，要保证其处于自己的私有空间之内，这个私有空间是由各函数的虚拟内存和堆栈组成。

## 8.2.4 初始化

当VM实现开始运行（或者重启）时，按照惯例它总是执行名为Sys.init的无参数VM函数，接着该函数调用用户程序中的主函数。

# 8.3实现

## 8.3.1 Hack平台上的标准VM映射，第II部分

**全局堆栈**  VM的内存资源是通过维护一个全局的堆栈来得到的。每当调用一个函数时，该函数对应的帧（frame）就被压入全局堆栈。该帧包括被调用函数（called function）将要使用的参数：一组用于保存调用者状态的指针（pointers）；被调用函数的局部变量（被初始化为0）；以及一个被调用函数将要使用的工作堆栈（当前为空）。

![[Pasted image 20240703195228.png]]

要注意图8.4中的阴影区以及ARG、LCL和SP指针对于VM函数是不可见的（无法感知它们的存在）。这三个指针是更底层的VM实现在函数调用与返回协议中使用的。

**函数调用协议的实现**  

![[Pasted image 20240703195601.png]]

**汇编语言符号**

![[Pasted image 20240703195955.png]]

**引导程序（bootstrap）代码**  当VM-Hack翻译器编译VM程序（一组.vm文件）时，会产生一个用Hack汇编语言编写的.asm文件。该文件必须符合规范。标准映射规定：（1）VM堆栈的初始地址必须被映射到RAM[256]；（2）经过编译的VM程序所执行的第一个函数必须是[[第8章虚拟机II程序控制#8.2.4 初始化|Sys.init]]。

如何在VM翻译器生成的.asm文件中执行这个初始化呢？在重置（reset）时获取位于ROM[0]位置的字并且执行。因此，起始于ROM地址0的代码段，称为引导程序代码（bootstrap code），是计算机“启动”时要执行的第一段代码。引导程序代码应该执行下列操作：
```
sp=256 //将堆栈指针初始化为0x0100
call Sys.init  //开始执行（翻译后的）Sys.init
```
Sys.init将调用主程序中的主函数，然后进入无限循环。

通过正确地编写Sys.init，每种语言编译器都能执行这样启动程序。


