Docker 是应用容器（Application Container），Docker 进程是一个普通进程，用来操作镜像文件。所以 Docker 进程+构建的应用镜像文件就等于 Docker 容器。

镜像 Docker images，类似于VM虚拟机的快照，我们可以通过ID或者易识别的名字+tag来确认唯一的目标镜像。ImagesID是一个64位的字符，但是一般我们都是使用前面12位就足够区别了。
![[Pasted image 20250106180733.png]]

如图中左边红框中redis: lates和右边的红框中5f515359c7f8都唯一表示为同一个镜像。所以我们一般的镜像可以命名为类似centos:latest、centos:centos7.1.1503等等。

镜像是分层的，有基础镜像，仅仅包含操作系统，比如centos镜像；有中间件镜像，比如redis等数据库镜像；最后是应用镜像，就是指具体的应用服务了，应用镜像可以非常丰富，随时可以发布，这三者之间依次叠加。

所以当我们在使用 Docker构建镜像的时候，每一个命令都会在前一个命令的基础上形成一个新镜像层。如下图，基础镜像就是 centos 镜像，中间件镜像就是两个红色圈，应用镜像就是紫色圈。其中redis+centos这样叠加组合的中间件镜像就可以供A服务或者B服务使用，这样叠加组合更加灵活。仍和一种镜像都可以从Docker hub公共仓库中拉取。
![[Pasted image 20250106180909.png]]
容器Docker containers，你可以从镜像中创建容器，这如同从快照中创建虚拟机，不过更轻量，启动更快，秒启。应用是在容器中运行的，打个比方，你首先下载了一个Ubuntu的镜像，然后又安装mysql和Django应用及其依赖，来完成对它Ubutun镜像的修改，一个个人觉得非常完美应用镜像生成了！就把这个镜像分享给大家使用，大家通过这个镜像就生成一个容器。容器启动之后就会运行Django服务了。
![[Pasted image 20250106181048.png]]
上面也说到了，容器就是一个个独立的封闭的集装箱，但是也需要对外提供服务的，所以Docker允许公开容器的特定端口，在启动 Docker 的时候，我们就可以将容器的特定端口映射到宿主机上面的任意一个端口，所以，如果几个服务都需要80端口，那么容器的对外端口是80，但是映射到宿主机上面就是任意端口，就不会产生冲突，所以就不需要通过代理来解决冲突。容器对外端口与宿主机的端口映射可以通过下面的命令来完成。

	启动docker容器  
	docker run -d -p 2222:22 --name 容器名 镜像名  
	-d 守护容器，就是后台运行，退出命令窗口容器也不会停止  
	-it 交互式容器 退出命令窗口容器就停止运行了  
	-p宿主机端口和容器端口映射  
	8081:80 宿主机端口:容器公开的端口

![[Pasted image 20250106181246.png]]
仓库Docker registeries，docker仓库和存放集装箱的仓库是一样的，不过docker使用来存放镜像的。仓库存在公有和私有之分，公有仓库docker hub提供了非常多的镜像文件，这些镜像直接拉取下来就可以运行了，你也可以上传自己的镜像到docker hub上面。同时也可以自己搭建私有仓库用于团队项目管理。

![[Pasted image 20250106181352.png]]
1. 开发构建镜像并将镜像 push 到 Docker 仓库
2. 测试或者运维从 Docker 仓库拷贝一份镜像到本地
3. 通过镜像文件开启 Docker容器并提供服务

首先，Docker的使用简单至极，从开发的角度来看就是三步走：构建，运输，运行。其中关键步骤就是构建环节，即打包镜像文件。但是从测试和运维的角度来看，那就只有两步：复制，运行。有了这个镜像，那么想复制到哪运行都可以，完全和平台无关了。

其次，因为在构建镜像的时候就处理完了服务程序对于系统的所有依赖，所以在你使用的时候，你可以忽略掉原本程序的依赖以及开发语言。对测试和运维而言，更多专注于自己的业务内容上。

最后，Docker于开发者而言提供了一种开发环境的管理办法，与测试人员而言保证了环境的同步，于运维人员提供了可移植的标准化部署流程。

Docker是个进程级的轻量化虚拟机，和传统虚拟机有啥区别呢？

Docker这个虚拟机超级轻量级，仅仅是一个进程而已。与传统的虚拟机比如VM有着巨大的差别，区别看下图：
![[Pasted image 20250106181620.png]]
我们来看一下二者的区别，因为 VM 的 Hypervisor 需要实现对硬件的虚拟化，并且还要搭载自己的操作系统，其中虚拟机操作系统占用内存是比较大的，一个操作系统有好几个G，自然在启动速度和资源利用率以及性能上有非常大的开销，如果在本地，或者个人电脑，那么影响还不是那么大，但是在云端就是一个非常大的资源浪费。

咱们很多时候做事情的时候不会考虑与事情本身无关的问题，比如造飞机的不会考虑飞机是否要潜水，对于我们目前很多移动互联网的应用来说，很少会涉及到对操作系统的部分，其实我们主要关心的是应用的本身，而VM虚拟机的上层是运行的运行时库和应用，整个虚拟机的空间是非常的庞大，但是容器化技术Docker技术的出现后，省去了操作系统这一层，多个容器之间相互隔离且共用了宿主操作系统和运行时库。

所以Docker 应用容器相对于 VM 有以下几个优点：
- 启动速度快，容器启动本质就是一个开启一个进程而已，因此都是秒启，而 VM 通常要更久。
- 资源利用率高，一台普通 PC 可以跑成百上千个容器，你跑十个 VM 试试。
- 性能开销小， VM 通常需要额外的 CPU 和内存来完成 OS 的功能，这一部分占据了额外的资源。

所以很多移动互联网的应用或者云计算的后端节点都可以用docker来替换物理机器或者虚拟机。

# Docker 是个啥架构，底层又是用的啥技术？
![[Pasted image 20250106181743.png]]
从Docker依赖的底层技术来看，Docker原生态是不能直接在Windows平台上运行的，只支持linux系统，原因是Docker依赖 linux kernel 三项最基本的技术，namespaces充当隔离的第一级，是对Docker容器进行隔离，让容器拥有独立的hostname,ip,pid，同时确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程;Cgroups是容器对使用的宿主机资源进行核算并限制的关键功能。比如CPU,内存,磁盘等，union FS主要是对镜像也就是image这一块作支持，采用copy-on-write技术，让大家可以共用某一层，对于某些差异层的话就可以在差异的内存存储，Libcontainer是一个库，是对上面这三项技术做一个封装。

Docker engine 用来控制容器container的运行，以及镜像文件的拉取。