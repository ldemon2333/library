本章从如下四个方面来讨论 TCP 协议：
- TCP 头部信息。
- TCP 状态转移过程。TCP 连接的任意一端都是一个状态机。在 TCP 连接从建立到断开的整个过程，连接两端的状态机将经历不同的状态变迁。
- TCP 数据流。
- TCP 数据流的控制。超时重传和拥塞控制。

# 3.1 TCP 服务的特点
传输层协议主要有两个：TCP 协议和 UDP 协议。TCP 协议的特点是：面向连接、字节流和可靠传输。

TCP 连接是全双工的，即双方的数据读写可以通过一个连接进行。

TCP 协议的这种连接是一对一的，所以基于广播和多播（目标是多个主机地址）的应用程序不能使用 TCP 服务。而无连接协议 UDP 则非常适合于广播和多播。

字节流服务和数据报服务，体现为通信双方是否必须执行相同次数的读、写操作。当发送端应用程序连续执行多次写操作时，TCP 模块先将这些数据放入 TCP 发送缓冲区中。当 TCP 模块真正开始发送数据时，发送缓冲区中这些等待发送的数据可能被封装成一个或多个 TCP 报文段发出。因此，TCP 模块发送出的 TCP 报文段的个数和应用程序执行的写操作次数之间没有固定的数量关系。

当接收端收到一个或多个 TCP 报文段后，TCP 模块将它们携带的应用程序数据按照 TCP 报文段的序号依次放入 TCP 接收缓冲区中，并通知应用程序读取数据。接收端应用程序可以一次性将 TCP 接收缓冲区中的数据全部读出，也可以多次读出，这取决于用户指定的应用程序读缓冲区的大小。

综上所述，发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是字节流的概念：应用程序对数据的发送和接收是没有边界限制的。UDP 则不然。发送端应用程序每执行一次写操作，UDP 模块就将其封装成一个 UDP 数据报并发送之。接收端必须及时针对每一个 UDP 数据报执行读操作（通过 recvfrom 系统调用），否则就会丢包。并且，如果用户没有指定足够的应用程序缓冲区来读取 UDP 数据，则 UDP 数据将被截断。
![[Pasted image 20250113151910.png]]

TCP 传输是可靠的。首先，TCP 协议采用发送应答机制，即发送端发送的每个 TCP 报文段都必须得到接收方的应答，才认为这个 TCP 报文段传输成功。其次，TCP 协议采用超时重传机制，发送端在发送出一个 TCP 报文段之后启动定时器，如果在定时时间内未收到应答，它将重发该报文段。最后，因为 TCP 报文段最终是以 IP 数据报发送的，而 IP 数据报到达接收端可能乱序、重复，所以 TCP 协议还会对接收到的 TCP 报文段重排、整理，再交付给应用层。

# 3.2 TCP 头部结构
## 3.2.1 TCP 固定头部结构
![[Pasted image 20250113152326.png]]
32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。

6 位标识位包含如下几项：
![[Pasted image 20250113152755.png]]
![[Pasted image 20250113152830.png]]

## 3.2.2 TCP 头部选项
TCP 头部的最后一个选项字段（options）是可变长的可选信息。这部分最多包含 40 字节，因为 TCP 头部最长是 60 字节。典型的 TCP 头部选项结构如图 3-4 所示。
![[Pasted image 20250114123442.png]]
kind 说明选项的类型。length 说明选项的总长度，info 是选项的具体信息。常见的 TCP 选项有 7 种。
![[Pasted image 20250114123605.png]]
kind：
- 0：选项表结束选项。
- 1：nop 选项
- 2：最大报文段长度选项
- 3：窗口扩大因子选项

## 3.2.3 使用 tcpdump 观察 TCP 头部信息
![[Pasted image 20250113152940.png]]
tcpdump 输出 Flags[S]，表示该 TCP 报文段包含 SYN 标志，因此它是一个同步报文段。

seq 是序号值。因为这是整个通信过程中的第一个 TCP 报文段，所以没有 ack。

win 是接收通告窗口的大小。

接下来分析 tcpdump 输出的字节码中 TCP 头部对应的信息，它从第 21 字节开始，
![[Pasted image 20250113153444.png]]
# 3.3 TCP 连接的建立和关闭
## 3.3.1 使用 tcpdump 观察 TCP 连接的建立和关闭
![[Pasted image 20250113153607.png]]
![[Pasted image 20250113153617.png]]
![[Pasted image 20250113153632.png]]
TCP 三次握手

后面是 4 个 TCP 报文段的关闭连接过程。实际上，仅用于确认目的的确认报文段 5 是可以省略的，因为结束报文段 6 也携带了该确认信息。确认报文段 5 是否出现在连接断开的过程中，取决于 TCP 的延迟确认特性。可能是客户端执行主动关闭，也可能是服务器执行主动关闭。

## 3.3.2 半关闭状态
TCP 连接是全双工的，所以它允许两个方向的数据传输被独立关闭。允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。
![[Pasted image 20250113154232.png]]

## 3.3.3 连接超时
客户端访问一个服务器，由于网络繁忙，导致服务器对于客户端发送出的同步报文段没有应答，此时客户端程序的 TCP，先进行重连，如果重连无效，则通知应用程序连接超时。

为了观察连接超时，模拟一个繁忙的服务器环境，在 ernest-laptop 上执行下面的操作。
![[Pasted image 20250113154801.png]]
`iptable` 命令用于过滤数据包，这里利用它来丢弃所以接收到的同步报文段，这样客户端就无法得到任何确认报文段。

接下来从 Kongming20 上执行 telnet 命令登录到 ernest-laptop，并用 tcpdump 抓取这个过程中双方交换的 TCP 报文段。
![[Pasted image 20250113160948.png]]
从两次 date 命令的输出来看，Kongming20 建立 TCP 连接的超时时间是 63 s。
![[Pasted image 20250113161027.png]]
这次抓包我们保留了 tcpdump 输出的时间戳。

![[Pasted image 20250113161230.png]]

# 3.4 TCP 状态转移
TCP 连接的任意一端在任一时刻都处于某种状态，当前状态可以通过 `netstat` 命令查看。TCP连接从建立到关闭的整个过程中通信两端状态的变化。
![[Pasted image 20250113211319.png]]
图 3-8 中的粗虚线表示典型的服务器端连接的状态转移；粗实线表示典型的客户端连接的状态转移。CLOSED 是一个假想的起始点，并不是实际的状态。

## 3.4.1 TCP 状态转移总图
先讨论服务器的典型状态转移过程。

服务器通过 `listen` 系统调用进入 LISTEN 状态，被动等待客户端连接，因此执行的是所谓的被动打开。服务器一旦监听到某个连接请求（收到同步报文段），就将该连接放入内核等待队列中，并向客户端发送带 SYN 标志的确认报文段。此时该连接处于 SYN_RCVD 状态。如果服务器成功地接收到客户端发送回的确认报文段，则该连接转移到 ESTABLISHED 状态。ESTABLISHED 状态是连接双方能够进行双向数据传输的状态。

当客户端主动关闭连接时（通过 `close` 或 `shutdown` 系统调用向服务器发送结束报文段），服务器通过返回确认报文段使连接进入 CLOSE_WAIT 状态。这个状态：等待服务器应用程序关闭连接。通常，服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接。这将使连接转移到 LAST_ACK 状态，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连接就彻底关闭了。

下面讨论客户端的状态转移：

客户端通过 `connect` 系统调用主动与服务器建立连接。connect 系统调用首先给服务器发送一个同步报文段，使连接转移到 SYN_SENT 状态。此后，connect 系统调用可能因为如下两个原因失败返回：
- 如果 connect 连接的目标端口不存在（未被任何进程监听），或者该端口仍被处于 TIME_WAIT 状态的连接所占有，则服务器将给客户端发送一个复位报文段，connect 调用失败。
- 如果目标端口存在，但 connect 在超时时间内未收到服务器的确认报文段，则 connect 调用失败。
connect 调用失败将使连接立即返回到初始的 CLOSED 状态。如果客户端成功收到服务器的同步报文段和确认，则 `connect` 调用成功返回，连接转移至 ESTABLISHED 状态。

当客户端执行关闭时，它将服务器发送一个结束报文段，同时连接进入 FIN_WAIT_1 状态。若此时客户端收到服务器专门用于确认目的的确认报文段（图3-6中的 TCP 报文段5），则连接转移至 FIN_WAIT_2 状态。当客户端处于 FIN_WAIT_2 状态时，服务器处于 CLOSED_WAIT 状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接（发送结束报文段），则客户端将给予确认并进入 TIME_WAIT 状态。

图 3-8 还给出了客户端从 FIN_WAIT_1 状态直接进入 TIME_WAIT 状态的一条线路（不经过 FIN_WAIT_2 状态），前提是处于 FIN_WAIT_1 状态的服务器直接收到带确认信息的结束报文段（而不是先收到确认报文段，再收到结束报文段）。这种情况对应于图 3-6 中的服务器不发送 TCP 报文段5。

处于 FIN_WAIT_2 状态的客户端需要等待服务器发送结束报文段，才能转移至 TIME_WAIT 状态，否则它将一直停留在这个状态。如果不是为了在半关闭状态下继续接收数据，连接长时间地停留在 FIN_WAIT_2 状态并无益处。连接停留在 FIN_WAIT_2 状态的情况可能发生在：客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为孤儿连接。
![[Pasted image 20250113214451.png]]

## 3.4.2 TIME_WAIT 状态
客户端连接在收到服务器的结束报文段（6）之后，并没有直接进入 CLOSED 状态，而是转移到 TIME_WAIT 状态。在这个状态，客户端连接要等待一段长为 2MSL（Maximum Segment Life，报文段最大生存时间）的时间，才能完全关闭。MSL 建议值是 2 min。

TIME_WAIT 状态存在的原因有两点：
- 可靠地终止 TCP 连接。
- 保证让迟来的 TCP 报文段有足够的时间被识别并丢弃。

在 Linux 系统上，一个 TCP 端口不能被同时打开多次（两次及以上）。当一个 TCP 连接处于 TIME_WAIT 状态时，无法立即使用该连接占有着的端口来建立一个新连接。如果不存在 TIME_WAIT 状态，则应用程序能够立即建立一个和刚关闭的连接相似的连接。这个新的连接被称为原来的连接的化身（incarnation）。新的化身可能接收到属于原来的连接、携带应用程序数据的 TCP 报文段（迟到的报文段）。这就是第二个原因。

因此，一个连接的新的化身可以在 2MSL 时间之后安全地建立，而绝对不会接收到属于原来连接的应用程序数据。

有时候希望避免 TIME_WAIT 状态，因为当程序退出后，希望能够立即重启它。但由于处于 TIME_WAIT 状态的连接还占用着端口，程序将无法启动（直到 2MSL 超时时间结束）。

如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务器端口，所以连接的 TIME_WAIT 状态将导致它不能立即重启。可以通过 socket 选项 SO_REUSEADDR 来强制进程立即使用处于 TIME_WAIT 状态的连接占用的端口。

# 3.5 复位报文段
在某些特殊条件下，TCP 连接的一端会向另一端发送携带 RST 标志的报文段，即复位报文段，以通知对方关闭连接或重新建立连接。产生复位报文段有 3 种情况。

## 3.5.1 访问不存在的端口
当客户端程序访问一个不存在的端口时，目标主机将给它发送一个复位报文段。

当客户端程序向服务器的某个端口发起连接，而该端口仍被处于 TIME_WAIT 状态的连接所占用时，客户端程序也将收到复位报文段。

## 3.5.2 异常终止连接
TCP 提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所以排队等待发送的数据都将被丢弃。

应用程序可以使用 socket 选项 SO_LINGER 来发送复位报文段，以异常终止一个连接。

## 3.5.3 处理半打开连接
考虑下面的情况：服务器（或客户端）关闭或者异常终止了连接，而对方没有接收到结束报文段（比如发生了网络故障），此时，客户端（或服务器）还维持着原来的连接，而服务器（或客户端）即使重启，也已经没有该连接的任何信息了。这种状态称为半打开状态，处于这种状态的连接称为半打开连接。如果客户端（或服务器）往处于半打开状态的连接写入数据，则对方将回应一个复位报文段。

# 3.6 TCP 交互数据流
讨论通过 TCP 连接交换的应用程序数据。TCP 报文段所携带的应用程序数据按照长度分为两种：交互数据和成块数据。交互数据仅包含很少的字节，对实时性要求高，比如 telnet、ssh 等。成块数据的长度则通常为 TCP 报文段允许的最大数据长度，对传输效率要求高，比如 ftp。下面讨论交互数据流。

在 ernest-laptop 上执行 telnet 命令登录到本机，然后在 shell 命令提示符后执行 ls 命令，同时用 tcpdump 抓取这一过程中 telnet 客户端和 telnet 服务器交换的 TCP 报文段。具体如下：
![[Pasted image 20250114121040.png]]
![[Pasted image 20250114121338.png]]
TCP 报文段 1-3 是针对 “l" 的过程，TCP 4~6 报文段是针对字母 “s"的过程。TCP 7 传送的 2 字节数据分别是：客户端键入的回车符和流结束符（EOF，本例中是 0x00）。TCP 报文段 8 携带服务器返回的客户查询的目录的内容（ls 命令的输出），TCP 10 携带的也是服务器返回给客户端的数据，包括一个回车符、一个换行符、客户端登录用户的 PS1 环境变量（第一级命令提示符）。

客户端针对服务器返回的数据所发送的确认报文段（TCP 段6、9和 11）都不携带任何应用程序数据（长度为0），而服务器每次发送的确认报文段（TCP 报文段2、5、8、10）都包含它需要发送的应用程序数据。服务器的这种处理方式称为延迟确认，即它不马上确认上次收到的数据，而是在一端延迟时间后查看本端是否有数据需要发送，如果有，则和确认信息一起发出。因为服务器对客户请求处理得很快。延迟确认可以减少发送 TCP 报文段的数量。而由于用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文段总是不携带任何应用程序数据。

上例是在本地回路运行的结果，在局域网中也能得到基本相同的结果，但在广域网上的交互数据流可能经受很大的延迟，解决拥塞问题使用 Nagle 算法。

Nagle 算法要求一个 TCP 连接的通信双方在任意时刻都最多只能发送一个未被确认的 TCP 报文段，在该 TCP 报文段的确认到达之前不能发送其他 TCP 报文段。另一方面，发送方在等待确认的同时收集本段需要发送的微量数据，并在确认到来时以一个 TCP 报文段将它们全部发出。

# 3.7 TCP 成块数据流
下面考虑用 FTP 协议传输一个大文件。在 ernest-laptop 上启动一个 vsftpd 服务器程序，并执行 ftp 命令登录该服务器上，然后在 ftp 命令提示符后输入 get 命令，从服务器下载一个大文件。同时用 tcpdump 抓取这一个过程中 ftp 客户端和 vsftpd 服务器交换的 TCP 报文段。
![[Pasted image 20250114123009.png]]
![[Pasted image 20250114123018.png]]
![[Pasted image 20250114123032.png]]
客户端发送的最后两个 TCP 报文段 17 和 18，它们分别是对 TCP 报文段 2 和 16 的确认（从序号值和确认值来判断）。因此，当传输大量大块数据的时候，发送方会连续发送多个 TCP 报文段，接收方可以一次确认所有这些报文段。那么发送方在收到上一次确认后，能连续发送多少个 TCP 报文段呢？这是由接收通告窗口的大小决定的。TCP 报文段 17 说明客户端还能接收 30084 x 64 字节（本例中窗口扩大因子为6），即 1925376 字节的数据。而在 TCP 报文段 18 中，接收通告窗口大小为 1748288 字节，即客户端能接收的数据量变小了。这表明客户端的 TCP 接收缓冲区有更多的数据未被应用程序读取而停留在其中，这些数据都来自 TCP 报文段 3~16 中的一部分。

下面修改系统的 TCP 接收缓冲区和 TCP 发送缓冲区的大小，使之都为 4096 字节，然后重启 vsftpd 服务器，并再次执行上述操作。
![[Pasted image 20250114124731.png]]
![[Pasted image 20250114124739.png]]

# 3.8 带外数据
有些传输层协议具有带外（Out Of Band，OOB）数据的概念，用于迅速通告对方本端发生的重要事件。因此，带外数据比普通数据（也称为带内数据）有更高的优先级，它应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。

TCP 利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式。

介绍 TCP 发送带外数据的过程。假设一个进程已经往某个 TCP 连接的发送缓冲区中写入了 N 字节的普通数据，并等待其发送。在数据被发送前，该进程又向这个连接写入了 3 字节的带外数据 “abc"。此时，待发送的 TCP 报文段的头部将被设置 URG 标志，并且紧急指针被设置为指向最后一个带外数据的下一字节（进一步减去当前 TCP 报文段的序号值得到其头部中的紧急偏移值）。
![[Pasted image 20250114125605.png]]
由图 3-10 可见，发送端一次发送的多字节的带外数据只有最后一字节被当作带外数据（字母c），而其他数据（字母 a 和 b）被当成普通数据。如果 TCP 模块以多个 TCP 报文段来发送图 3-10 所示 TCP 发送缓冲区中的内容，则每个 TCP 报文段都将设置 URG 标志，并且它们的紧急指针指向同一个位置（数据流中带外数据的下一个位置），但只要一个 TCP 报文段真正携带带外数据。

TCP 接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指的位置确定带外数据的位置，并将它读入一个特殊的缓冲中。这个缓冲只有 1 字节，称为带外缓存。如果上层应用程序没有及时将带外数据从带外缓存中读出，则后续的带外数据将覆盖它。这是默认方式，如果我们给 TCP 连接设置了 SO_OOBINLINE 选项，则带外数据将和普通数据一样被 TCP 模块存放在 TCP 接收缓存区中。

# 3.9 TCP 超时重传
讨论异常网络状态下（开始出现超时或丢包），TCP 如何控制数据传输以保证其承诺的可靠服务。

TCP 服务必须能够重传超时时间内未收到确认的 TCP 报文段。为此，TCP 模块为每个 TCP 报文段都维护一个重传定时器，该定时器在 TCP 报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP 模块将重传 TCP 报文段并重置定时器。
![[Pasted image 20250114131150.png]]

iperf 是一个测量网络状况的工具，-s 选项表示将其作为服务器运行。iperf 默认监听 5001 端口，并丢弃该端口上接收到的所有数据，相当于一个 discard 服务器。
![[Pasted image 20250114131310.png]]
TCP 报文段 1~3 是三次握手建立连接的过程，TCP 报文段 4~5 是客户端发送数据 “1234”（应用程序数据长度为 6，包括回车、换行两个字符，后同）及服务器确认的过程。TCP 报文段 6 是客户端第一次发送数据 “12” 的过程。因为服务器的网线被断开，所有客户端无法收到 TCP 报文段 6 的确认报文段。此后，客户端对 TCP 报文段6 执行了 5 次重传，它们是 TCP 报文段 7~11，这可以从每个 TCP 报文段的序号得知。数据包 12~23 都是 ARP 模块的输出内容，即 Kongming20 查询 ernest-laptop 的 MAC 地址。

# 3.10 拥塞控制
## 3.10.1 拥塞控制概述
TCP 还有提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。这就是所谓的拥塞控制。

RFC 5681 文档，四个部分：慢启动、拥塞避免、快速重传和快速恢复。

拥塞控制的最终受控变量是发送端向网络一次连续写入（收到其中第一个数据的确认之前）的数据量，我们称为 SWND（Send Window，发送窗口）。不过，发送端最终以 TCP 报文段来发送数据，不过，发送端最终以 TCP 报文段来发送数据，所以 SWND 限定了发送端能连续发送的 TCP 报文段数量。这些 TCP 报文段的最大长度称为 SMSS，其值一般等于 MSS。

接收方可通过其接收通告窗口（RWND）来控制发送端的 SWND。发送端引入了一个称为拥塞窗口（CWND）的状态变量。实际的 SWND 值是 RWND 和 CWND 中的较小者。![[Pasted image 20250114132555.png]]
