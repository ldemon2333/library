网络程序需要处理的第三类事件是定时事件，比如定期检测一个客户连接的活动状态。服务器程序通常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑。为此，要将每个定时事件分别封装成定时器，并使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理。本章主要讨论的就是两种高效的管理定时器的容器：时间轮和时间堆。

定时是指在一段时间之后触发某段代码的机制，可以在这段代码中依次处理所有到期的定时器。换言之，定时机制是定时器得以被处理的原动力。Linux 提供了三种定时方法，它们是：
- socket 选项 SO_RCVTIMEO 和 SO_SNDTIMEO
- SIGALRM 信号
- I/O 复用系统调用的超时参数

# 11.1 socket 选项 SO_RCVTIMEO 和 SO_SNDTIMEO
这两个选项分别用来设置 socket 接收数据超时时间和发送数据超时时间。
![[Pasted image 20250303193244.png]]

# 11.2 SIGALRM 信号
由 alarm 和 setitimer 函数设置的实时闹钟一旦超时，将触发 SIGALRM 信号。因此，可以利用该信号的信号处理函数来处理定时任务。但是，如果要处理多个定时任务，我们就需要不断地触发 SIGALRM 信号，并在其信号处理函数中执行到期的任务。一般而言，SIGALRM 信号按照固定的频率生成，即由 alarm 或 setitimer 函数设置的定时周期 T 保持不变。

## 11.2.1 基于升序链表的定时器
定时器通常至少要包含两个成员：一个超时时间和一个任务回调函数。有的时候还可能包含回调函数被执行时需要传入的参数，以及是否重启定时器等信息。

## 11.2.2 处理非活动连接
服务器程序通常要定期处理非活动连接：给客户端发一个重连请求，或者关闭该连接。Linux 在内核中提供了对连接是否处于活动状态的定期检测机制，可以通过 socket 选项 KEEPALIVE 来激活它。不过使用这种方式使得应用程序对连接的管理变得复杂。可以在应用层实现类似于 KEEPALIVE 的机制，以管理所有长时间处于非活动状态的连接。利用 alarm 函数周期性地触发 SIGALRM 信号，该信号地信号处理函数利用管道通知主循环执行定时器链表上的定时任务——关闭非活动的连接。3

# 11.3 I/O 复用系统调用的超时参数
Linux 下的 3 组 I/O 复用系统调用都带有超时参数，因此它们不仅能统一处理信号和 I/O 事件，也能统一处理定时事件。但是由于 I/O 复用系统调用可能在超时时间到期之前就返回（有 I/O 事件发生），所有如果我们要利用它们来定时，就需要不断更新定时参数以反映剩余的时间。

### epoll_wait 返回 0 的含义

在Linux系统中，`epoll_wait`函数用于等待注册的文件描述符上的事件发生。当`epoll_wait`返回0时，表示在指定的超时时间内没有事件发生。这意味着没有注册的文件描述符准备好进行I/O操作，或者超时时间太短，不足以让事件发生。

具体来说：

- **返回值为0**：表示在指定的超时时间内没有事件发生。进程可以继续执行其他任务，或者再次调用`epoll_wait`等待新的事件。
    
- **返回值为-1**：表示发生了错误，如无效的epfd或者内存不足等。此时，`errno`会被设置为具体的错误原因。
    

此外，如果`epoll_wait`被信号中断，它会返回-1，并且`errno`会被设置为EINTR。这种情况下，进程需要根据信号处理逻辑决定是否继续等待事件。

总结而言，`epoll_wait`返回0表明在指定的时间内没有事件发生，进程应继续处理其他任务或重新等待事件的发生。

# 11.4 高性能定时器
## 11.4.1 时间轮
基于排序链表的定时器存在一个问题：添加定时器的效率偏低。下面时间轮解决了这个问题。
![[Pasted image 20250304115750.png]]
实线指针指向轮子上的一个槽（slot）。它以恒定的速度顺时针转动，每转动一步就指向下一个槽，每次转动一个滴答（tick）。一个滴答的时间称为时间轮的槽间隔 si（slot interval），实际上就是心搏时间。该时间轮共有 N 个槽。每个槽指向一条定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间相差 N* si 的整数倍。假如现在指针指向槽 cs，我们要添加一个定时时间为 ti 的定时器，则该定时器将被插入槽 ts（timer slot）对应的链表中：
$$
ts = (cs+(ti/si)) \ mod \ N
$$
基于排序链表的定时器使用唯一的一条链表来管理所有定时器，所以插入操作的效率随着定时器数目的增多而降低。而时间轮使用哈希表的思想，将定时器散列到不同的链表上。这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响。

对时间轮而言，要提高定时精度，就要使 si 足够小；要提高执行效率，则要 N 足够大。

复杂的时间轮可能有多个轮子，不同的轮子拥有不同的粒度。相邻的两个轮子，精度高的转一圈，精度低的仅往前移动一槽，就像水表一样。

对时间轮而言，添加一个定时器的时间复杂度是 O（1），删除也是 O1，执行一个定时器的时间复杂度是O(n)。但实际上执行一个定时器任务的效率比 O(n) 好，因为时间轮将所有的定时器散列到了不同的链表上。时间轮的槽越多，等价于散列表的入口越多，从而每条链表上的定时器数量越少。此外，当使用多个轮子来实现时间轮时，执行一个定时器任务的时间复杂度将接近 O(1)。

## 11.4.2 时间堆
设计定时器的另外一种思路是：将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数 tick 被调用，超时时间最小的定时器必然到期，我们就可以在 tick 函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。

使用最小堆数组来表示。初始化只需对数组中的第 $(N-1)/2$ ~ 0 个元素执行下滤操作。     

添加一个定时器的时间复杂度是 O(logn)，删除也是 logn，执行一个定时器是 O(1)。因此，时间堆的效率很高。

