模板细节问题服务器程序规范。
- Linux 服务器程序一般以后台进程形式运行。后台进程又称守护进程（daemon）。守护进程的父进程通常是 init 进程（PID 为 1 的进程）
- Linux 服务器程序有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的 UDP 服务器。大部分后台进程都在 /var/log 目录下拥有自己的日志目录。
- Linux 服务器程序一般以某个专门的非 root 身份运行。比如 mysqld、httpd、syslogd 等后台进程，分别拥有自己的运行账户 mysql、apache 和 syslog
- 绝大多数服务器程序都有配置文件，并存放在 /etc 目录下。
- Linux 服务器进程通常会在启动的时候生成一个 PID 文件并存入 /var/run 目录中，以记录该后台进程的 PID。比如 syslogd 的 PID 文件是 /var/run/syslogd.pid
- Linux 服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等。

# 7.1 日志
## 7.1.1 Linux 系统日志
Linux 提供一个守护进程来处理系统日志——syslogd。升级版——rsyslogd

rsyslogd 守护进程既能接收用户进程输出的日志，又能接收内核日志。用户进程是通过调用 syslog 函数生成系统日志的。该函数将日志输出到一个 UNIX 本地域 socket 类型（AF_UNIX）的文件 /dev/log 中，rsyslogd 则监听该文件以获取用户进程的输出。内核日志在老系统上是通过另外一个守护进程 rklogd 来管理的，rsyslogd 利用额外的模块实现了相同的功能。内核日志由 printk 等函数打印至内核的环状缓冲中，ring buffer 的内存直接映射到 /proc/kmsg 文件中。rsyslogd 则通过读取该文件获得内核日志。

rsyslogd 守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。默认下，调试信息会保存至 /var/log/debug 文件。rsyslogd 的主要配置文件是 /etc/rsyslog.conf，其中主要可以设置的项包括：内核日志输入路径，是否接收 UDP 日志及其监听端口（默认是 514，见 /etc/services 文件），是否接收 TCP 日志及其监听端口，日志文件的权限，包含哪些子配置文件（比如 /etc/rsyslog.d/* .conf）。rsyslogd 的子配置文件则指定各类日志的目标存储文件。
![[Pasted image 20250213110319.png]]

## 7.1.2 syslog 函数
应用程序使用 syslog 函数与 rsyslogd 守护进程通信。syslog 函数的定义如下：
![[Pasted image 20250213110412.png]]
priority 参数是所谓的设施值与日志级别的按位或。设施值的默认值是 LOG_USER。日志级别有如下几个：
![[Pasted image 20250213110528.png]]

下面这个函数可以改变 syslog 的默认输出方式，进一步结构化日志内容：
![[Pasted image 20250213110647.png]]
ident 参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。logopt 参数对后续 syslog 调用的行为进行配置，它可取下列值的按位或：
![[Pasted image 20250213110824.png]]
facility 参数可用来修改 syslog 函数中的默认设施值。

日志的过滤也很重要。程序在开发阶段可能需要输出很多调试信息，而发布之后我们又需要将这些调试信息关闭。解决这个问题的方法并不是在程序发布之后删除调试代码，而是简单地设置日志掩码，使日志级别大于日志掩码的日志信息被系统忽略。
![[Pasted image 20250213111101.png]]

# 7.2 用户信息
## 7.2.1 UID、EUID、GID 和 EGID
大部分服务器必须以 root 身份启动，但不能以 root 身份运行。获取和设置当前进程的真实用户 ID
![[Pasted image 20250213111232.png]]
GID 真实组 ID 和有效组 ID（EGID）

一个进程拥有两个用户 ID：UID 和 EUID。EUID 存在的目的是方便资源访问：它使得运行程序的用户拥有该程序的有效用户的权限。比如 su 程序，任何用户都可以使用它来修改自己的账号信息，但修改账户时 su 程序不得不访问 /etc/passwd 文件，而访问该文件是需要 root 权限的。那么以普通用户身份启动的 su 程序如何能访问 /etc/passwd 文件呢？用 ls 命令可以查看到，su 程序的所有者是 root，并且它被设置了 set-user-id 标志。这个标志表示，任何普通用户运行 su 程序时，其有效用户就是该程序的所有者 root。任何运行 su 程序的普通用户都能够访问 /etc/passwd 文件。有效用户为 root 的进程称为特权进程（privileged processes）
![[Pasted image 20250213112706.png]]

编译该文件，将生成的可执行文件（名为 test_uid）的所有者设置为 root，并设置该文件的 set-user-id 标志，然后运行该程序以查看 UID 和 EUID。具体操作如下：
![[Pasted image 20250213112814.png]]
输出：进程的 UID 是启动程序的用户的 ID，而 EUID 则是 root 账户（文件所有者）的 ID。

# 7.3 进程间关系
## 7.3.1 进程组
Linux 下每个进程都隶属于一个进程组，因此它们除了 PID 信息外，还有进程组 ID（PGID）。可以用如下函数来获取指定进程的 PGID：
![[Pasted image 20250213115320.png]]
成功时返回进程 pid 所属进程组的 PGID，失败则返回 -1 并设置 errno。

每个进程组都有一个首领进程，其 PGID 和 PID 相同。进程组将一直存在，直到其中所有进程都退出，或者加入到其他进程组。

下面的函数用于设置 PGID：
![[Pasted image 20250213115453.png]]
该函数将 PID 为 pid 的进程的 PGID 设置为 pgid。如果 pid 和 pgid 相同，则由 pid 指定的进程将被设置为进程组首领；如果 pid 为 0，则表示设置当前进程的 PGID 为 pgid；如果 pgid 为 0，则使用 pid 作为目标 PGID。setpgid 函数成功时返回 0，失败则返回 -1 并设置 errno。

一个进程只能设置自己或者其子进程的 PGID。并且，当子进程调用 exec 系列函数后，我们不能在父进程中对它设置 PGID。

## 7.3.2 会话
一些有关联的进程组将形成一个会话（session）。下面的函数用于创建一个会话：
![[Pasted image 20250213115858.png]]
该函数不能由进程组的首领进程调用，否则产生一个错误。对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果：
![[Pasted image 20250213120014.png]]

## 7.3.3 ps 查看进程关系
![[Pasted image 20250213120037.png]]
# 7.4 系统资源限制
Linux 系统资源限制可以通过如下一对函数来读取和设置：
![[Pasted image 20250213120355.png]]![[Pasted image 20250213120406.png]]
rlim_t 是一个整数类型，描述资源级别。rlim_cur 指定资源的软限制，rlim_max 成员指定资源的硬限制。软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。例如，当进程 CPU 时间超过其软限制时，系统将向进程发送 SIGXCPU 信号；当文件尺寸超过其软限制时，系统将向进程发送 SIGXFSZ 信号。硬限制一般是软限制的上限。可以使用 ulimit 命令修改当前 shell 环境下的资源限制，这种修改将对该 shell 启动的所有后续程序有效。
![[Pasted image 20250213120815.png]]

# 7.5 改变工作目录和根目录
Web 服务器的逻辑根目录并非文件系统的根目录 “/”，而是站点的根目录（一般是/var/www/）

获取进程当前工作目录和改变进程工作目录的函数分别是：
![[Pasted image 20250213120943.png]]
![[Pasted image 20250213121056.png]]

# 7.6 服务器程序后台化
![[Pasted image 20250213121454.png]]
![[Pasted image 20250213121510.png]]
