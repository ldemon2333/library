信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。

# 10.1 Linux 信号概述
## 10.1.1 发送信号
![[Pasted image 20250228113506.png]]

![[Pasted image 20250228113534.png]]
![[Pasted image 20250228113547.png]]

## 10.1.2 信号处理方式
![[Pasted image 20250228113716.png]]

## 10.1.4 中断系统调用
![[Pasted image 20250228114058.png]]

# 10.2 信号函数
## 10.2.1 signal 系统调用
![[Pasted image 20250228114341.png]]
## 10.2.2 sigaction 系统调用
![[Pasted image 20250228114425.png]]
![[Pasted image 20250228114551.png]]

# 10.3 信号集
## 10.3.1 信号集函数
sigset_t 来表示一组信号。其定义如下：
![[Pasted image 20250228114757.png]]

## 10.3.2 进程信号掩码
![[Pasted image 20250228115205.png]]

## 10.3.3 被挂起的信号
设置进程信号掩码后，被屏蔽的信号将不能被进程接收。如果给进程发送一个被屏蔽的信号，则 OS 将该信号设置为进程的一个被挂起的信号。如果取消对被挂起信号的屏蔽，则它能立即被进程接收到。如下函数可以获得进程当前被挂起的信号集：
![[Pasted image 20250228115424.png]]
set 参数用于保存被挂起的信号集。显然，进程即使多次接收到同一个被挂起的信号，sigpending 函数也只能反映一次。并且，当我们再次使用 sigprocmask 使能该挂起的信号时，该信号的处理函数也只能被触发一次。

sigpending 成功时返回 0， 失败时返回 -1 并设置 errno。
![[Pasted image 20250228115659.png]]

# 10.4 统一事件源
信号是一种异步事件：信号处理函数和程序的主循环是两条不同的执行路线。信号处理函数需要尽可能地执行完毕，以确保该信号不被屏蔽太久（为了避免一些竞态条件，信号在处理期间，系统不会再次触发它）。一种典型的解决方案是：把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它只是简单地通知主循环程序接收到信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。信号处理函数通常使用管道来将信号“传递”给主循环：信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值。那么主循环怎么知道管道上何时有数据可读呢？使用 I/O 复用系统调用来监听管道的读端文件描述符上的可读事件。如此一来，信号事件就能和其他 I/O 事件一样被处理，即统一事件源。

# 10.5 网络编程相关信号
## 10.5.1 SIGHUP
当挂起进程的控制终端时，SIGHUP 信号将被触发。对于没有控制终端的网络后台程序而言，它们通常利用 SIGHUP 信号来强制服务器重读配置文件。一个典型的例子是 xinetd 超级服务程序。

xinetd 程序在接收到 SIGHUP 信号之后将调用 hard_reconfig 函数，它循环读取 /etc/xinetd.d/目录下的每个子配置文件，并检测其变化。如果某个正在运行的子服务的配置文件被修改以停止服务，则 xinetd 主进程将给该子服务进程发送 SIGTERM 信号以结束它。如果某个子服务的配置文件被修改以开启服务，则 xinetd 将创建新的 socket 并将其绑定到服务对应的端口上。下面简答地分析 xinetd 处理 SIGHUP 信号的流程。
![[Pasted image 20250228134141.png]]

strace 跟踪进程 7438，即 xinetd 服务器程序，以观察 xinetd 是如何处理 SIGHUP 信号的。
![[Pasted image 20250228135602.png]]
![[Pasted image 20250228135556.png]]
该输出分为 4 个部分，用空行将每个部分隔开。

第一部分描述程序接收到 SIGHUP 信号时，信号处理函数使用管道通知主程序该信号的到来。信号处理函数往 fd 4（管道的写端）写入信号值 1 （SIGHUP 信号），而主程序使用 poll 检测到文件描述符 3 （管道的读端）上有可读事件，就将管道上的数据读入。

第二部分描述了 xinetd 重新读取一个子配置文件的过程。

第三部分描述了 xinetd 给子进程 echo-stream（PID 为 7442）发送 SIGTERM 信号来终止该子进程，并调用 waitpid 来等待该子进程结束。

第四部分描述了 xinetd 启动 telnet 服务的过程：创建一个流服务 socket 并将其绑定到端口 23 上，然后监听该端口。

## 10.5.2 SIGPIPE
默认情况下，往一个读端关闭的管道或 socket 连接中写数据将引发 SIGPIPE 信号。我们需要在代码中捕获并处理该信号，或者至少忽略它，因为程序接收到 SIGPIPE 信号的默认行为是结束进程。引起 SIGPIPE 信号的写操作将设置 errno 为 EPIPE。

可以使用 send 函数的 MSG_NOSIGNAL 标志来禁止写操作触发 SIGPIPE 信号。在这种情况下，我们应该使用 send 函数反馈的 errno 值来判断管道或者 socket 连接的读端是否已经关闭。

此外，也可以利用 I/O 复用系统调用来检测管道和 socket 连接的读端是否已经关闭。以 poll 为例，当管道的读端关闭时，写端文件描述符上的 POLLHUP 事件将被触发；当 socket 连接被对方关闭时，socket 上的 POLLRDHUP 事件将被触发。

## 10.5.3 SIGURG
在 Linux 环境下，内核通知应用程序带外数据到达主要有两种方法：I/O 复用技术，select 等系统调用在接收到带外数据时将返回，并向应用程序报告 socket 上的异常事件。另外一种方法就是使用 SIGURG 信号。

![[Pasted image 20250303192358.png]]