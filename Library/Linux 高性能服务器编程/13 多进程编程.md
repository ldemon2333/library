- 复制进程映像的 fork 系统调用和替换进程映像的 exec 系列系统调用
- 僵尸进程以及如何避免僵尸进程
- IPC 通信最简单的方式：管道
- 3 种 System V 进程间通信方式：信号量、消息队列和共享内存。它们都是由 AT&T System V2 版本的 UNIX 引入的，所有统称为 System V IPC。
- 在进程间传递文件描述符的通用方法：通过 UNIX 本地域 socket 传递特殊的辅助数据

# 13.1 fork 系统调用
```
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

fork 函数复制当前进程，在内核进程表中创建一个新的进程表项。新的进程表项有很多属性和原进程相同，比如堆指针、栈指针和标志寄存器的值。但子进程的信号位图被清楚（原进程设置的信号处理函数不再对新进程起作用）。

创建子进程后，父进程中打开的文件描述符默认在子进程中也是打开的，且文件描述符的引用计数加 1。不仅如此，父进程的用户根目录、当前工作目录等变量的引用计数均会加 1。

# 13.2 exec 
![[Pasted image 20250331150816.png]]

# 13.3 处理僵尸进程
对于多进程程序而言，父进程一般需要跟踪子进程的退出状态。因此，当子进程结束运行时，内核不会立即释放该进程的进程表表项，以满足父进程后续对该子进程退出信息的查询（如果父进程还在运行）。在子进程结束运行之后，父进程读取其退出状态之前，我们称该子进程处于僵尸态。另外一种使子进程进入僵尸态的情况是：父进程结束或者异常终止，而子进程继续运行。此时子进程的 PPID 被 OS 设置为 1，即 init 进程。init 进程接管了该子进程，并等待它结束。在父进程退出之后，子进程退出之前，该子进程处于僵尸态。

由此可见，如果父进程没有正确地处理子进程的返回信息，子进程都将停留在僵尸态，并占据着内核资源。
![[Pasted image 20250331151257.png]]
wait 函数将阻塞进程，直到该进程的某个子进程结束运行为止。它返回结束运行的子进程的 PID，并将该子进程的退出状态信息存储于 stat_loc 参数指向的内存中。
![[Pasted image 20250331151415.png]]
wait 函数的阻塞特性显然不是服务器程序期望的，而 waitpid 函数解决了这个问题。
![[Pasted image 20250331151518.png]]

8.3 节曾提到，要在事件已经发生的情况下执行非阻塞调用才能提高程序的效率。对 waitpid 函数而言，我们最好在某个子进程退出之后再调用它。那么父进程从何得知某个子进程已经退出了呢？使用 SIGCHLD 信号。可以在父进程中捕获 SIGCHLD 信号，并在信号处理函数中调用 waitpid 函数以“彻底结束”一个子进程。
![[Pasted image 20250331151759.png]]

# 13.4 管道
管道是父子进程间通信的常用手段。

管道能在父、子进程间传递数据，利用 fork 调用之后两个管道文件描述符（fd[0] 和 fd[1]）都保持打开。一对这样的文件描述符只能保证父、子进程间一个方向的数据传输，父进程和子进程必须有一个关闭 fd[0]，另一个关闭 fd[1]。
![[Pasted image 20250331152027.png]]
显然，如果要实现父、子进程之间的双向数据传输，就必须使用两个管道。socket 编程接口提供了一个创建全双工管道的系统调用：socketpair。squid 服务器程序就是利用 socketpair 创建管道，以实现在父进程和日志服务子进程之间传递日志信息。

不过，管道只能用于有关联的两个进程（比如父、子进程）间的通信。而下面要讨论的 3 中 System V IPC 能用于无关联的多个进程之间的通信，因为它们都使用一个全局唯一的键值来标识一条信道。不过，有一种特殊的管道成为 FIFO，也叫命名管道。它也能用于无关联进程之间的通信。

# 13.5 信号量
## 13.5.1 信号量原语

## 13.5.2 semget 系统调用
![[Pasted image 20250331152948.png]]![[Pasted image 20250331153000.png]]
## 13.5.3 semop 系统调用
semop 改变信号量的值，即执行 P、V 操作。在讨论 semop 之前，需要先介绍与每个信号量关联的一些重要的内核变量：
![[Pasted image 20250331153322.png]]

todo