讨论与网络编程相关的几个高级I/O 函数，这些函数大致分为三类：
- 用于创建文件描述符的函数，包括 pipe、dup/dup2 函数
- 用于读写数据的函数，包括 readv/writev、sendfie、mmap/munmap、splice 和 tee 函数
- 用于控制 I/O 行为和属性的函数，包括 fcntl 函数

# 6.1 pipe 函数
![[Pasted image 20250211161928.png]]
往 fd[1] 写入的数据可以从 fd[0] 读出。fd[0] 只能用于从管道读出数据。如果要实现双向的数据传输，就应该使用两个管道。默认情况下，这一对文件描述符都是阻塞的。如果应用程序将 fd[0] 和 fd[1] 都设置为非阻塞的，则会有不同的行为。如果管道的写端文件描述符 fd[1] 的引用计数减少至 0，则针对该管道的读端文件描述符 fd[0] 的 read 操作将返回 0，即读取到了 EOF；反之，读端文件描述符的引用计数减少至 0，则针对该管道的写端文件描述符 fd[1] 的 write 操作将失败，并引发 SIGPIPE 信号。

管道内部传输的数据是字节流。应用层程序能往一个 TCP 连接中写入多少字节的数据，取决于对方的接收通告窗口的大小和本端的拥塞窗口的大小。而管道本身有一个容量限制。可以使用 fcntl 函数来修改管道的容量。

![[Pasted image 20250211162631.png]]

socketpair 前三个参数的含义与 socket 系统调用的三个参数完全相同，但 domain 只能使用 UNIX 本地域协议族 AF_UNIX，因为只能在本地使用这个双向管道。创建的 fd[2] 这对文件描述符是既可读又可写的。成功返回 0 ，失败时返回 -1 并设置 errno

# 6.2 dup 函数和 dup2 函数
把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接。
![[Pasted image 20250211162934.png]]
dup 函数创建一个新的 fd，该 fd 和原 fd 指向相同的文件、管道或者网络连接。并且 dup 返回的 fd 总是取系统当前可用的最小整数值。

![[Pasted image 20250211163250.png]]

先关闭标准输出 fd （1），然后复制 socket 文件 fd connfd。dup 返回是 1。这样服务器输出到标准输出的内容就会直接发送到与客户连接对应的 socket 上，这就是 CGI 服务器的基本原理。

# 6.3 readv 函数和 writev 函数
readv 函数将数据从文件描述符读到分散的内存块中，即分散读；writev 函数将多块分散的内存数据一并写入文件描述符中，即集中写。
![[Pasted image 20250211163632.png]]
vector 类型是 iovec 结构数组，结构体 iovec 描述一块内存区。count 参数是 vector 数组的长度。readv 和 writev 在成功时返回读出/写入 fd 的字节数，失败则返回 -1 并设置 errno。

当 Web 服务器解析完一个 HTTP 请求之后，如果目标文档存在且客户具有读取该文档的权限，那么它就需要发送一个 HTTP 应答来传输该文档。这个 HTTP 应答包含 1 个状态行、多个头部字段、1 个空行和文档的内容。其中，前 3 部分可能被 Web 服务器放置在一块内存中，而文档的内容则通常被读入到另外一块单独的内存中。可以使用 writev 函数将它们同时写出。

# 6.4 sendfile 函数
sendfile 函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，称为零拷贝。
![[Pasted image 20250211165018.png]]

in_fd 参数是待读出内容的 fd。sendfile 成功时返回传输的字节数，失败则返回 -1 并设置 errno。man 手册明确指出，in_fd 必须是一个支持类似 mmap 函数的文件描述符，即它必须指向真实的文件，不能是 socket 和管道；而 out_fd 则必须是一个 socket。sendfile 没有为目标文件分配任何用户空间的缓冲，也没有执行读取文件的操作，但同样实现了文件的发送。

# 6.5 mmap 函数和 munmap 函数
![[Pasted image 20250211165612.png]]
prot 参数用来设置内存段的访问权限。
![[Pasted image 20250211165642.png]]

flags 参数控制内存段被修改后程序的行为。
![[Pasted image 20250211165743.png]]
offset 参数设置从文件的何处开始映射。


# 6.6 splice 函数
splice 函数用于在两个文件描述符之间移动数据，也是零拷贝操作。splice 函数的定义如下：
![[Pasted image 20250211170741.png]]

fd_in 参数是待输入数据的 fd。flags 控制数据如何移动。
![[Pasted image 20250211180552.png]]

**使用 splice 函数时，fd_in 和 fd_out 必须至少有一个是管道文件描述符**。
![[Pasted image 20250211180717.png]]

下面使用 splice 函数来实现一个零拷贝的回射服务器，它将客户端发送的数据原样返回给客户端。
![[Pasted image 20250211180849.png]]
通过 splice 函数将客户端的内容读入到 pipefd[1] 中，然后再使用 splice 函数从 pipefd[0] 中读出该内容到客户端，从而实现了回射服务。整个过程未执行 recv/send 操作，未涉及用户空间和内核空间之间的数据拷贝。

### 一、**零拷贝 `splice` 的示例**

以下为 Linux 系统调用 `splice` 的典型使用场景及代码示例，重点展示如何通过管道实现零拷贝数据传输：

#### 1. **C语言示例：文件高效传输**
![[Pasted image 20250227141203.png]]

**关键点**：
- **零拷贝实现**：`splice` 通过管道直接在内核态转移数据，**避免用户态与内核态之间的数据复制**，提升传输效率
- **参数说明**：`splice` 的 `fd_in` 或 `fd_out` 必须有一个是管道文件描述符

### 二、**为什么需要管道？**

管道在 `splice` 中起到**内核态数据中转**的核心作用，其必要性体现在：

#### 1. **零拷贝的依赖机制**
- **页缓存绑定**：`splice` 将文件或网络数据的页缓存（Page Cache）绑定到管道的环形缓冲区，后续操作仅需传递指针，**无需物理拷贝数据**
- **内存管理优化**：管道作为内核对象，可直接操作内存页的引用计数指针，实现数据移动而非复制

#### 2. **统一数据接口
- **兼容多种场景**：管道可作为通用中介，统一处理文件到文件、文件到网络、网络到网络等不同场景的数据传输，简化内核逻辑
#### 3. **规避用户态参与**
- **绕过用户缓冲区**：若直接操作非管道描述符（如两个普通文件），仍需用户态参与数据拷贝，破坏零拷贝特性

### 三、**管道与 `splice` 的协作原理**
1. **数据移动流程**：
    - **步骤1**：`splice` 将输入源（如文件）的页缓存绑定到管道写端缓冲区，仅记录内存页指针
    - **步骤2**：从管道读端直接读取指针，将数据输出到目标（如网络socket），整个过程**无物理数据复制。
2. **性能优势**：
    - **减少CPU开销**：传统 `read/write` 需要4次上下文切换和2次数据拷贝，而 `splice` 仅需2次系统调用和0次数据拷贝。
    - **适用大文件传输**：适合高并发场景（如反向代理服务器），避免频繁内存分配。

### 四、**注意事项**
1. **管道容量限制**：单个 `splice` 操作的数据量需小于管道缓冲区大小（默认64KB），否则需分多次调用。
2. **描述符类型约束**：`splice` 要求至少一个描述符是管道，否则返回 `EINVAL` 错误。


# 6.7 tee 函数
tee 函数在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此原 fd 上的数据仍然可以用于后续的读操作。
![[Pasted image 20250211181306.png]]
fd_in 和 fd_out 必须是管道文件描述符。tee 成功时返回在两个文件描述符之间复制的数据数量。失败 -1。

# 6.8 fcntl 函数
file control，提供了对文件描述符的各种控制操作。另一个是 ioctl，比 fcntl 能够执行更多的控制。但是，对于控制 fd 常用的属性和行为，fcntl 函数是由 POSIX 规范指定的首选方法。
![[Pasted image 20250211182249.png]]
cmd 参数指定执行何种类型的操作。可能需要第三个可选参数 arg。
![[Pasted image 20250211182348.png]]
![[Pasted image 20250211182354.png]]
在网络编程中，fcntl 函数通常用来将一个文件描述符设置为非阻塞的。
![[Pasted image 20250211182510.png]]
此外，SIGIO 和 SIGURG 这两个信号与其他 Linux 信号不同，它们必须与某个文件描述符相关联方可使用：当被关联的 fd 可读或可写时，系统将触发 SIGIO 信号；当被关联的 fd（必须是 socket）上有带外数据可读时，系统将触发 SIGURG 信号。将信号和 fd 关联的方法，就是使用 fcntl 函数为目标 fd 指定宿主进程或进程组，那么被指定的宿主进程或进程组将捕获这两个信号。使用 SIGIO 时，还需要利用 fcntl 设置其 O_ASYNC 标志（异步 I/O 标志）