Linux 服务器程序必须处理的三类事件：I/O 事件、信号和定时事件。在处理这三类事件时通常需要考虑如下三个问题：
- 统一事件源。利用 I/O 复用系统调用来管理所有事件。
- 可移植性。不同的 OS 具有不同的 I/O 复用方式。
- 对并发编程的支持。

# 12.1 I/O 框架库概述
各种 I/O 框架库的实现原理基本相似，要么以 Reactor 模式实现，要么以 Proactor 模式实现，要么同时以这两种模式实现。举例来说，基于 Reactor 模式的 I/O 框架库包含如下几个组件：句柄（Handle）、事件多路分发器（EventDemultiplexer）、事件处理器（EventHandler）和具体的事件处理器（ConcreteEventHandler）、Reactor。这些组件的关系如图所示。
![[Pasted image 20250304133051.png]]
### 1. 句柄
I/O 框架库要处理的对象，即 I/O 事件、信号和定时事件，统一称为事件源。一个事件源通常和一个句柄绑定在一起。句柄的作用是，当内核检测到就绪事件时，它将通过句柄来通知应用程序这一事件。
### 2. 事件多路分发器
事件的到来是随机的、异步的。我们无法预知程序何时收到一个客户连接请求，又亦或收到一个暂停信号。所有程序需要循环地等待并处理事件，这就是事件循环。在事件循环中，等待事件一般使用 I/O 复用技术来实现。I/O 框架库一般将系统支持的各种 I/O 复用系统调用封装成统一的接口，称为事件多路分发器。核心函数是 demultiplex，其内部调用 select、poll、epoll_wait 函数。

此外，事件多路分发器还需要实现 register_event 和 remove_event 方法，以供调用者往事件多路分发器中添加事件和从事件多路分发器中删除事件。

### 3. 事件处理器和具体事件处理器
事件处理器执行事件对应的业务逻辑。它通常包含一个或多个 handle_event 回调函数，这些回调函数在事件循环中被执行。I/O 框架库提供的事件处理器通常是一个接口，用户需要继承它来实现自己的事件处理器，即具体事件处理器。因此，事件处理器中的回调函数一般被声明为虚函数，以支持用户的扩展。

get_handle 方法，它返回与该事件处理器关联的句柄。当事件多路分发器检测到有事件发生时，它是通过句柄来通知应用程序的。因此，必须将事件处理器和句柄绑定，才能在事件发生时获取到正确的事件处理器。

### 4. Reactor
Reactor 是 I/O 框架库的核心。它提供的几个主要方法是：
- handle_events。该方法执行事件循环。它重复如下过程：等待事件，然后依次处理所有就绪事件对应的事件处理器。
- register_handler。注册事件
- remove_handler

![[Pasted image 20250304134424.png]]
# 12.2 Libevent 源码分析
- 线程安全
- 基于 Reactor 模式的实现