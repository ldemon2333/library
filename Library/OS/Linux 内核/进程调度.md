假定系统时钟设定为 1ms。

# 调度策略
传统Unix OS 的调度算法必须实现几个互相冲突的目标：进程响应时间尽可能快，后台作业的吞吐量尽可能高，尽可能避免进程的饥饿现象，低优先级和高优先级进程的尽可能调和。

Linux 的调度基于分时技术。调度策略也是根据进程的优先级对它们进行分类。每个进程都与一个值相关联，在 Linux 中，进程的优先级是动态的。在较长的时间间隔内没有使用 CPU 的进程，通过动态地增加它们的优先级来提升它们。

将进程分位三类：
- 交互式进程（interactive process）
- 批处理进程（batch process）
- 实时进程（real-time process）：这样的进程绝不会被低优先级的进程阻塞，它们应该有一个短的响应时间。

例如，一个批处理进程可能是I/O密集型，或是CPU密集型。在Linux 中，调度算法可以明确地确认所有实时程序的身份，但没有办法区分交互式程序和批处理程序。Linux 2.6 调度程序实现了基于进程过去行为的启发式算法，以确定进程应该被当作交互式进程还是批处理进程。


# 进程的抢占
Linux 的进程是抢占式的。如果进程进入 TASK_RUNNING 状态，内核检查它的动态优先级是否大于当前正运行进程的优先级。如果是，current 的执行被中断，并调用调度程序选择另一个进程运行。当进程在它的时间片到期时也可以被抢占。此时，当前进程 thread_info 结构中的 TIF_NEED_RESCHED 标志被设置，以便时钟中断处理程序终止时调度程序被调用。

`TIF_NEED_RESCHED` 标志位的作用是告诉内核当前的线程需要进行调度。

注意，被抢占的进程并没有被挂起，因为它还处于 TASK_RUNNING 状态，只不过不再使用 CPU。此外，记住 Linux 2.6 内核是抢占式的，这意味着进程无论是处于内核态还是用户态，都可能被抢占。

# 调度算法
早期 Linux 版本中的调度算法：在每次进程切换时，内核扫描可运行进程的链表，计算进程的优先级，然后选择“最佳”进程来运行。缺点是选择“最佳”进程所要消耗的时间与可运行的进程数量相关，因此，这个算法的开销太大。

Linux 2.6 的调度算法。通过设计，该算法较好地解决了与可运行进程数量的比例关系，在固定的时间内选中要运行的进程。它也很好地处理了与处理器数量地比例关系，因为每个 CPU 都拥有自己的可运行进程队列。

调度程序总能成功找到要执行的进程。事实上，总是至少有一个可运行进程，即 *swapper* 进程，它的PID = 0，而且它只有在CPU不能执行其他进程才执行。

在 Linux 内核中，`swapper` 进程是一个非常特殊的进程，它是内核启动时创建的第一个进程，并且始终存在于系统中。`swapper` 进程的主要功能是负责内存管理，尤其是与内存交换（swap）相关的操作。尽管 `swapper` 进程本身不执行任何实际的用户任务，它在系统启动过程中和管理系统资源时起着重要作用。

### `swapper` 进程的基本特点

1. **进程号（PID）为 0**：  
    在 Linux 中，`swapper` 进程的进程号（PID）为 `0`，它是内核空间中的第一个进程。这个进程通常不直接执行任务，也不能被普通用户终止。
    
2. **内存管理**：  
    `swapper` 进程主要负责虚拟内存的管理，尤其是在物理内存不足时，处理内存的交换操作（swap）。当系统内存不足时，`swapper` 进程会将不常用的页面数据从内存交换到磁盘的交换分区或交换文件中。
    
3. **初始化进程**：  
    在 Linux 内核启动时，`swapper` 进程会首先被创建，它的作用是负责执行一些必要的初始化工作，并且启动第一个用户空间进程（通常是 `init` 进程，进程号为 `1`）。
    
4. **调度器和 CPU 管理**：  
    `swapper` 进程并不负责执行任何用户代码，而是由调度器负责安排进程的执行。它的存在是为了确保内核的基础进程能够在系统启动时运行，并参与一些重要的内存管理操作。其主要作用是为其他进程提供调度支持。
    
5. **内核线程**：  
    `swapper` 本质上是一个内核线程，而不是普通的用户进程。它在内核空间中运行，不会进行用户空间的任务。
    

### `swapper` 进程的作用

- **虚拟内存管理**：  
    `swapper` 进程在操作系统中起到管理虚拟内存和物理内存之间交换的作用。当系统的内存使用达到高峰时，它会负责将某些不活跃的内存页从内存中交换到硬盘上的交换分区（swap space）。通过这种方式，它可以确保系统始终有足够的内存来处理正在运行的进程。
    
- **初始化内核资源**：  
    `swapper` 进程负责进行初始的内存管理操作，它会在系统启动时完成一些与内存分配相关的工作。例如，内核会在启动时分配一些基本的内存结构，并确保虚拟内存和物理内存映射正确。
    
- **启动其他进程**：  
    在 Linux 启动过程中，`swapper` 进程负责启动系统中的第一个用户进程（通常是 `init`）。一旦 `init` 进程启动，`swapper` 就不再直接参与进程的调度工作，而是交给调度器来处理。
    

### `swapper` 进程与 `init` 进程的关系

- `swapper` 进程的 PID 是 `0`，它在系统启动时是唯一的内核进程，负责启动系统中的其他进程。
- `init` 进程是系统启动后的第一个用户进程，其 PID 是 `1`。`swapper` 进程通过调度 `init` 进程来进入用户空间，进行用户级任务的调度。

### `swapper` 进程的生命周期

- 在系统启动时，`swapper` 进程会在内核空间初始化一些基本资源。
- 一旦内核完成初始化，并且其他进程（如 `init`）开始运行，`swapper` 进程就不再直接进行用户空间的调度，但它依然保持在系统中，负责内存交换等核心任务。

### 代码中的 `swapper` 进程

在 Linux 内核的源代码中，`swapper` 进程是通过一个特殊的内核线程来表示的，它并不执行任何用户代码。它通常和其他内核线程一起，作为内核的主要进程之一运行。

### 总结

- `swapper` 是一个特殊的内核进程，它的进程号为 `0`。
- 其主要职责是负责内存管理，尤其是内存的交换（swap）操作。
- 它是内核启动时创建的第一个进程，并且在系统的生命周期内始终存在，确保系统的基本内存管理和调度功能。
- 尽管 `swapper` 进程不执行用户任务，但它在 Linux 系统中起到了非常关键的作用，特别是在内存管理和进程调度的初期阶段。


每个 Linux 进程总是按照下面的调度类型被调度：
- SCHED_FIFO：先进先出的实时进程。当调度程序把 CPU 分配给进程的时候
- SCHED_RR：时间片轮转的实时进程
- SCHED_NORMAL：普通的分时进程

# 普通进程的调度
每个普通进程都有它自己的静态优先级，调度程序使用静态优先级来估价系统中这个进程与其他普通进程之间调度的程度。内核用从 100 到 139 的数表示普通进程的静态优先级。

新进程总是继承其父进程的静态优先级。但是用户可以改变自己拥有的进程的静态优先级。

## 基本时间片
静态优先级本质上决定了进程的基本时间片，关系如下：
![[Pasted image 20241129180748.png]]
优先级较高的进程获得更长的 CPU 时间片。
![[Pasted image 20241129180901.png]]
$$
nice = 静态优先级-120
$$
## 动态优先级和平均睡眠时间
动态优先级，其值的范围是 100~139。动态优先级是调度程序在选择新进程来运行的时候使用的数。它与静态优先级的关系用下面的经验公式表示：
![[Pasted image 20241129181116.png]]
*bonus* 是范围从 0 ~ 10 的值，值小于5表示降低动态优先级以示惩罚，值大于5表示增加动态优先级以示奖赏。bonus 的值与进程的平均睡眠时间相关。

表 7-3 说明了平均睡眠时间和 bonus 值的关系。
![[Pasted image 20241129181400.png]]
平均睡眠时间也被调度程序用来确定一个给定进程是交互式进程还是批处理进程。如果一个进程满足下面的公式，就被看作是交互式进程：
![[Pasted image 20241129181506.png]]
表达式：静态优先级/4 - 28 被称为交互式的 $\delta$；注意，高优先级进程比低优先级进程更容易成为交互式进程。例如，具有最高静态优先级（100）的进程，当它的 bonus 值超过2，即睡眠时间超过 200ms 时，就被看作是交互式进程。相反，具有最低静态优先级（139）的进程决不会被当作是交互式进程，因为这要求bonus要大于等于11。

## 活动和过期进程
即使具有较高静态优先级的普通进程获得了较大的 CPU 时间片，也不应该使静态优先级较低的进程无法运行。为了避免饥饿，当一个进程用完它的时间片时，它应该被还没有用完时间片的低优先级进程取代。为了实现这种机制，调度程序维持两个不相交的可运行进程的集合。

活动进程：这些进程还没有用完它们的时间片，因此运行它们运行。
过期进程：这些可运行进程已经用完了它们的时间片，并因此被禁止运行，直到所有活动进程都过期。

具体方案复杂一些：因为调度程序试图提升交互式进程的性能。用完其时间片的活动批处理进程总是变成过期进程。用完其时间片的交互式进程通常仍然是活动进程：调度程序重填其时间片并把它留在活动进程集合中。但是，如果最老的过期进程已经等待了很长时间，或者过期进程比交互式进程的静态优先级高，调度程序就把用完时间片的交互式进程移到过期进程集合中。结果，活动进程集合最终会变为空，过期进程将有机会运行。

# 实时进程的调度
每个实时进程都与一个实时优先级相关，实时优先级是一个范围从 1 ~ 99 的值。调度程序总是让优先级高的进程运行，实时进程运行的过程中，禁止低优先级进程的执行。与普通进程相反，实时进程总是被当初活动进程。用户可以通过系统调用 sched_setparam() 和 sched_setscheduler() 改变进程的实时优先级。

如果几个可运行的实时进程具有相同的最高优先级，那么调度程序选择第一个出现在与本地CPU的运行队列相应链表中的进程。

只有在下述事件之一发生时，实时进程才会被另外一个进程取代：
- 进程被另外一个具有更高实时优先级的实时进程抢占。
- 进程执行了阻塞操作并进入睡眠（处于 *TASK_INTERRUPTIBLE* 或 *TASK_UNINTERRUPTIBLE* 状态）。
- 进程停止（处于 *TASK_STOPPED* 或 *TASK_TRACED* 状态）或被杀死（处于 *EXIT_ZOMBIE* 或*EXIT_DEAD* 状态）
- 进程通过系统调用 `sched_yield()` 自愿放弃CPU
- 进程是基于时间片轮转的实时进程 (*SCHED_RR*)，而且用完了它的时间片。

# 调度程序所使用的数据结构
运行队列链表链接所有的可运行进程的进程描述符，(idle 进程) 除外。

## 数据结构 runqueue
系统中的每个 CPU 都有它自己的运行队列，所有的 runqueue 结构存放在 runqueues per-CPU 变量中。宏 `this_rq()` 产生本地 CPU 运行队列的地址，而宏 `cpu_rq(n)` 产生索引为 n 的CPU的运行队列的地址。

**per-CPU 变量**是指每个 CPU 核心都有独立副本的变量。

![[Pasted image 20241129184757.png]]
![[Pasted image 20241129184804.png]]

runqueue 中最重要的字段是与可运行进程的链表相关的字段。系统中的每个可运行进程属于且只属于一个运行队列。只要可运行进程保持在同一个运行队列中，它就只可能在拥有该运行队列的CPU上执行。但是，可运行进程会从一个运行队列迁移到另一个运行队列。

运行队列的`arrays` 字段是一个包含两个`prio_array_t`结构的数组。每个数据结构都表示一个可运行进程的集合，并包括 140 个双向链表头（每个链表对应一个可能的进程优先级）、一个优先级位图和一个集合中所包含的进程数量的计数器。

![[Pasted image 20241129185710.png]]

如图7-1，runqueue 结构的 active 字段指向 arrays 中两个 prio_array_t 数据结构之一。

arrays 中两个数据结构的作用会发生周期性的变化：活动进程突然变成过期进程，而过期进程变为活动进程，调度程序简单地交换运行队列的 active 和 expired 字段的内容。

## 进程描述符
每个进程描述符都包含几个与调度相关的字段。
![[Pasted image 20241129185947.png]]
![[Pasted image 20241129190132.png]]

当新进程被创建的时候，由 `copy_process()` 调用的函数 `sched_fork()` 用下述方法设置`current` 进程（父进程）和 p 进程（子进程）的`time_slice` 字段：
```
p->time_slice = (current->time_slice + 1) >> 1;
current->time_slice >>=1;
```
换句话说，父进程剩余的节拍数被划分成两等份：一份给父进程，另一份给子进程。这样做是为了避免用户通过下述方法获得无限的 CPU 时间：父进程创建一个运行相同代码的子进程，并随后杀死自己，通过适当地调节创建的速度，子进程就可以总是在父进程过期之前获得新的时间片。一个进程不能通过创建多个后代来霸占资源（除非它有给自己实时策略的特权）。

如果父进程的时间片只剩下一个时钟节拍，则划分操作强行把`current->time_slice` 置为0，从而耗尽父进程的时间片。这种情况下，`copy_process()`把`current->time_slice`重新置为 1，然后调用 `scheduler_tick()`递减该字段。

函数 `copy_process()` 也初始化子进程描述符中与进程调度相关的几个字段：
```
p->first_time_slice = 1;
p->timestamp = sched_clock();
```
因为子进程没有用完它的时间片（如果一个进程在它的第一个时间片内终止或执行新的程序，就把子进程的剩余时间奖励给父进程），所以`first_time_slice`标志被置为 1。用函数 `sched_clock()` 所产生的时间戳的值初始化 `timestamp` 字段：实际上，函数 sched_clock() 返回被转化成纳秒的 64 位寄存器 TSC 的内容。


https://arthurchiao.art/blog/linux-cfs-design-and-implementation-zh/#12-cfs-%E6%89%A9%E5%B1%95
# 2.2 核心概念
vruntime：在真实 CPU 上，任意时间只能运行一个任务。

runqueue：每个 CPU 上的可运行进程队列

## 基于时序的红黑树
哪个进程 vruntime 最小，说明累计执行时间最少，从“公平”的角度来说，需要执行它。
- CFS 用红黑树组织运行进程，用 vruntime 做 key，所有 runnable 的进程都是用 `p->se.vruntime` 作为 key 来排序的。
- CFS 每次取出最左边的进程
实际上 CFS 还维护了 min/max vruntime
- min vruntime 用途：新进程或重新回到 ready 状态的进程，用 vruntime=min_vruntime 来初始化，放到最左边
- max vruntime 用途：限额

# 2.3 调度策略（scheduling policy）
## 2.3.1 实时进程调度策略
可运行的进程都放到了一个 runqueue（运行队列）的数据结构中，调度器根据调度策略从里面取出进程放到 CPU 上执行。有两种调度策略：SCHED_RR 和 SCHED_FIFO。

SCHED_FIFO：
进程在下面的条件下会放弃 CPU：
1. 进程在等待，例如 IO 操作。当进程再回到 ready 状态时，它会被放到 runqueue 队尾。
2. 进程通过 sched_yield yield（主动让出）CPU。进程立即进入 runqueue 队尾。

SCHED_RR：
runqueue 中的每个进程轮流获得时间片（quantum）。

## 2.3.2 常规进程调度策略


