ring buffer 4 个信息：
- 在内存中的实际**开始位置**（例如：一片内存的头指针，数组的第一个元素指针）；
- 在内存中的实际**结束位置**（也可以是缓冲区实际空间大小，结合开始位置，可以算出结束位置）；
- 在缓冲区中进行写操作时的**写索引**值；
- 在缓冲区中进行读操作时的**读索引**值。

怎样判断缓冲区是满的
当缓冲区是满、或是空，都有可能出现读索引与写索引指向同一位置：

![[Pasted image 20241204143032.png]]
# 区分缓冲区满或者空
## 总是保持一个存储单元为空
缓冲区中总是有一个存储单元保持未使用状态。缓冲区最多存入 (size−1) 个数据。如果读写指针指向同一位置，则缓冲区为空。如果读指针位于写指针的相邻后一个位置，则缓冲区为满。这种策略的优点是简单、粗暴；缺点是语义上实际可存数据量与缓冲区容量不一致，测试缓冲区是否满需要做取余数计算。

## 使用数据计数
不使用显示的写指针。缺点是读写操作都需要修改这个存储数据计数，对于多线程访问缓冲区需要并发控制。

## 镜像指示位
缓冲区的长度如果是 n，逻辑地址空间则为0至n-1；那么，规定n至2n-1为镜像逻辑地址空间。本策略规定读写指针的地址空间为0至2n-1，其中低半部分对应于常规的逻辑地址空间，高半部分对应于镜像逻辑地址空间。当指针值大于等于2n时，使其折返（wrapped）到ptr-2n。使用一位表示写指针或读指针是否进入了虚拟的镜像存储区：置位表示进入，不置位表示没进入还在基本存储区。
![[Pasted image 20241204143557.png]]
在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区为空；如果二者的指示位不同，说明缓冲区为满。这种方法优点是测试缓冲区满/空很简单；不需要做取余数操作；读写线程可以分别设计专用算法策略，能实现精致的并发控制。 缺点是读写指针各需要额外的一位作为指示位。

如果缓冲区长度是2的幂，则本方法可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差n，则缓冲区为满，这可以用（写指针 == （读指针 异或 缓冲区长度）来判断。

## 读/写计数

## 记录最后的操作


# 镜像指示位
上面描述中提到了**读/写指针**的概念，注意这个读/写指针和上文提到的**读索引**和**写索引**不是一回事。读写指针的范围是【0，2n-1】，而**读索引**和**写索引**的范围是【0，n-1】，其必须和缓冲区的实际逻辑空间一致。但是**读/写指针**和**读索引**和**写索引**有一个转换关系：
![[Pasted image 20241204144515.png]]
如果缓冲区长度是 2 的幂，那么求余运算可以等价为：
![[Pasted image 20241204144630.png]]
按位与的运算效率要比求余运算高的多，在`linux`内核中将缓冲区长度扩展为2的幂长度随处可见，都是为了用按位与操作代替求余操作。为了判断缓冲区是否为**空或者满**，镜像指示位策略引入了两个布尔变量（指示位），来分别标记读指针或写指针是否进入了镜像区间，\[n，2n−1\]，在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区**为空**；如果二者的指示位不同，说明缓冲区**为满**。但如果缓冲区的长度是2的幂，则可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差n，则缓冲区为满。

# 3.1 RT-Thread 中实现的 ring buffer
下面分析**RT-Thread**的**ring buffer**实现，主要会讨论**环形缓冲区结构体**、**缓冲区初始化操作**、**写操作**、**读操作**、**判断缓冲区是否为空或满**。

## 环形缓冲区结构体
`RT-Thread`中定义了结构体`rt_ringbuffer`，其中`buffer_ptr`、`buffer_size`、`read_index`、`write_index`和**2.2节**中介绍的**4**个信息是完全对应的。为了判断缓冲区是空还是满，还定义了两个布尔型变量`read_mirror`和`write_mirror`，其是通过位域的定义方式来实现。
![[Pasted image 20241204145245.png]]

## 缓冲区初始化操作
![[Pasted image 20241204145340.png]]

## 写操作和读操作
写操作有两个接口`rt_ringbuffer_put`和`rt_ringbuffer_put_force`，当缓冲区满的时候，前一个不会写入，后一个会强制写入（覆盖）；读操作有一个接口`rt_ringbuffer_get`。

这里先说明一下，**RT-Thread**的**ring buffer**实现虽然借鉴了上一章讲的**镜像指示位**策略，但其并没有使用读写指针，而是直接用的**写索引**和**读索引**，也就是说结构体中的`read_index`和`write_index`就是**写索引**和**读索引**，无需进行转换，直接可以用来操作缓冲区。这一点和`linux`的实现方式不同，在下面的`linux`章节中会看到。但`read_mirror`和`write_mirror`是和**镜像指示位**策略中讲的一样，用来标记是否进入了镜像区间。

先来看`rt_ringbuffer_put`的实现，该函数的返回值是实际写入大小，就是如果传入的`length`大于缓冲区的剩余空间，则`length`只有部分会被写入缓冲区。通过条件`if (rb->buffer_size - rb->write_index > length)`将写操作分成了如下两种情形：

![[Pasted image 20241204145455.png]]


当`if (rb->buffer_size - rb->write_index > length)`为**真**时，其对应的是**情形一**。就是说从**写索引**到缓冲区结束位置这一段空间能容纳全部所写入数据。在图片情形一中，开始缓冲区中有两个元素`1`、`2`，接着继续写入`A`、`B`、`C`三个元素。可以看出从**写索引**到缓冲区结束位置还可以容纳**4**个元素，所以`A`、`B`、`C`三个元素可以一次性写入缓冲区，**写索引**无需回环。对应的代码就是`rt_memcpy(&rb->buffer_ptr[rb->write_index], ptr, length);`。

当`if (rb->buffer_size - rb->write_index > length)`为**假**时，其对应的是**情形二**。就是说从**写索引**到缓冲区结束位置这一段空间无法全部容纳所写入数据，**写索引**需要回环到缓冲区开头，写入剩下的数据。在图片情形二中，开始缓冲区中有两个元素`1`、`2`，接着继续写入`A`、`B`、`C`三个元素。可以看出从**写索引**到缓冲区结束位置还可以容纳**2**个元素，也就是说`A`、`B`两个元素可以写入从**写索引**到缓冲区结束位置这一段，而`C`只能回环到缓冲区的开头位置。对应代码就是`rt_memcpy(&rb->buffer_ptr[rb->write_index],&ptr[0],rb->buffer_size - rb->write_index);rt_memcpy(&rb->buffer_ptr[0],&ptr[rb->buffer_size - rb->write_index],length - (rb->buffer_size - rb->write_index));`。因为写索引已经回环了，所以要将`write_mirror`做一下取反操作：`rb->write_mirror = ~rb->write_mirror;`。

写操作接口`rt_ringbuffer_put_force`和上面介绍的基本一样，其实就是多了当传入的`length`大于缓冲区的剩余空间时，会将已有的元素覆盖掉。如果发生了元素覆盖，那缓冲区一定会变满，read_index和write_index回相等，对应语句`if (length > space_length) rb->read_index = rb->write_index;`（也即2.1节中讨论的问题2，读索引要指向最老元素）。因为会操作`read_index`元素，也要考虑其是否发生了回环，发生了回环后`read_mirror`需要取反，对应语句`rb->read_mirror = ~rb->read_mirror;`。图中对应的**情形三**描述了该过程，开始缓冲区中有两个元素`1`、`2`，接着继续写入`A`、`B`、`C`、`D`、`E`、`F`六个元素。此时元素`1`被覆盖掉，**写索引**和**读索引**都指向元素`2`。

读接口`rt_ringbuffer_get`和写接口的操作逻辑基本一致，也是通过条件`if (rb->buffer_size - rb->write_index > length)`将读操作分成了两种情形，过程和写操作接口`rt_ringbuffer_put`没有差异。


## 判断缓冲区是否为空或满
判断缓冲区是否为空或满，通过函数`rt_ringbuffer_status`来实现。其逻辑就是在**2.2.3节**中介绍的：在读写指针的值相同情况下，如果二者的指示位相同，说明缓冲区**为空**；如果二者的指示位不同，说明缓冲区**为满**。注意这里的**读写指针**已经在读写(`rt_ringbuffer_get`和`rt_ringbuffer_put`)过程中转换为了**读写索引**。
![[Pasted image 20241204150440.png]]

# 3.2 Linux 中实现的 ring buffer
在linux内核中，kfifo就是**ring buffer**的经典实现方式，本文将介绍`linux 2.6`版本中的**ring buffer**实现方式，主要介绍**缓冲区结构体**、**缓冲区初始化**、**读操作**、**写操作**、**判断缓冲区是否为空或满**。

## 缓冲区结构体
`kfifo`的**ring buffer**结构体定义如下，其中`buffer`、`size`、`in`、`out`和**2.2节**中介绍的环形缓冲区**4**个信息是一一对应的。但其中`in`、`out`分别是**写指针**和**读指针**，而不是**写索引**和**读索引**。它们之间的转换关系就是**2.2.3节**介绍的转化公式。参数`lock`是自旋锁，在多进程/线程对同一个环形缓冲区进行读写操作时，需要进行锁保护。和`RT-Thread`对比，可以看到其并没有读写的镜像指示位，判断缓冲区是否为空或满呢？在下一节会进行分析。
![[Pasted image 20241204150606.png]]

## 缓冲区初始化
在`kfifo`的初始化`kfifo_init`中可以看出，其会对所传入的`size`大小进行扩展，使其满足`size`为**2的幂**。这样就可以使用**2.2.3节**中介绍的性质，**如果缓冲区的长度是2的幂，则可以省略镜像指示位。如果读写指针的值相等，则缓冲区为空；如果读写指针相差n(缓冲区大小)，则缓冲区为满**。所以在传入`buffer`的`size`大小时，最好开始就将其确定为**2的幂**。
![[Pasted image 20241204150632.png]]

## 读操作和写操作
 可以看到`kfifo`对读操作和写操作的实现非常简洁。在进行读操作和写操作时，其充分利用了无符号整型的性质。在`__kfifo_put`(写操作)和`__kfifo_get`(读操作)时，in(写指针)和out(读指针)都是正向增加的，当达到最大值时，产生溢出，使得从0开始，进行循环使用。**in(写指针)** 和**out(读指针)** 会恒定的保持如下关系： 
$$
 读指针+缓冲区已存储数据长度=写指针
$$

其中读指针是`out`，写指针是`in`。**out(读指针)** 永远不会超过**in(写指针)** 的大小，最多两者相等，相等就是缓冲区为空的时候。再结合在**2.2.3节**中介绍的转换关系： 读索引=读指针&(缓冲区长度−1) 写索引=写指针&(缓冲区长度−1) 就可以对环形缓冲区进行读写操作了，下面来看源码。

先看`__kfifo_put`的源码。`len = min(len, fifo->size - fifo->in + fifo->out);`中表达的意思就是实际写入的长度一定要小于缓冲区的可用空间大小，防止发生覆盖已有元素的场景。来看这一句`l = min(len, fifo->size - (fifo->in & (fifo->size - 1)));`，其中`(fifo->in & (fifo->size - 1))`就是将**in(写指针)** 转换为**写索引**，整体表达的意思是从**写索引**到缓冲区结束位置这一段所能写入数据的大小，这一段写入操作的代码为`memcpy(fifo->buffer + (fifo->in & (fifo->size - 1)), buffer, l);`。如果这一段还不够，需要折返到缓冲区的开始位置，将剩下的部分写入到缓冲区中，其代码为`memcpy(fifo->buffer, buffer + l, len - l);`。而且len>=l(因为l取的是较小值)，当len=l就说明第一段已经可以容纳所写入大小，缓冲区无需折返，第二个`memcpy`拷贝了零个字节，相当于什么也没有发生。

再看`__kfifo_get`的源码。其思路基本和`__kfifo_put`一致，了解了上面的转换关系，就比较好理解。

## 判断缓冲区是否为空或满
`kfifo`中没有专门的函数判断缓冲区是否为空或满，但可以通过`__kfifo_len`函数获取**缓冲区已存储数据长度**。如果其值等于零就说明缓冲区为空，如果其值等于缓冲区大小，就说明缓冲区满。
![[Pasted image 20241204151909.png]]


## 小结
- linux 中环形缓冲区（ring buffer）的实现，其实是对镜像指示位策略的扩展，读指针和写指针区间范围不再局限在镜像区间\[0, 2n-1\]，而是整个 unsigned int  大小的空间，对于 32 位机器，读指针和写指针的区间范围是\[0, 2^32-1\];
- 进行扩展后，还能维持如下的关系，是因为缓冲区大小 n 会被扩展为 2 的幂。
![[Pasted image 20241204144630.png]]
- 读索引和写索引的区间范围仍然是\[0, n-1\];
- 在多进程/线程中，对同一个环形缓冲区进行读写操作时，需要加上锁，不然存在访问不安全问题
- 当只有一个读进程/线程和一个写进程，无需加锁，也能保证访问安全。

# 3.3    linux 5.17+的ring buffer
如下是 5.17 `kfifo.h`文件中定义的ring buffer结构体，其中`in`、`out`依然是**写指针**和**读指针**，`mask`是缓冲区大小减1（做&操作，更方便的将读写指针转换为**读写索引**），`esize`缓冲区单个存储元素的字节大小(在`linux 2.6`版本中，一个元素就是一个字节大小，最新版本将其进行了扩展)，`data`缓冲区的逻辑起始地址（指针类型不再是字节）。
![[Pasted image 20241204152542.png]]

# 4. 总结
- 环形缓冲区（ring buffer）适合于事先明确了缓冲区的最大容量的情形。缓冲区的容量（长度）一般固定，可以用一个静态数组来充当缓冲区，无需重复申请内存；
- 如果缓冲区的大小需要经常调整，就不适合用环形缓存区，因为在扩展缓冲区大小时，需要搬移其中的数据，这种场合使用链表更加合适；
- 因为缓冲区成头尾相连的环形，写操作可能会覆盖未及时读取的数据，有的场景允许这种情况发生，有的场景又严格限制这种情况发生。选择何种策略和具体应用场景相关；
- 环形缓冲区（ring buffer）特别适合于通信双方循环发送数据的场景；
- 镜像指示位是一种高效判断缓冲区是否为空或满的策略，在**RT-Thread**和**linux**中都使用了该策略（或者是该策略的扩展），其能够保证在只有一个读线程（或进程）和一个写线程（或进程）中无需锁也能做到线程安全；
- 注意区分写指针和写索引，读指针和读索引，最终对缓冲区进行操作还是需要写索引和读索引；



  



  

  


  


  