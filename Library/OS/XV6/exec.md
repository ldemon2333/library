# kernel/exec
exec 系统调用会创建一个地址空间的用户部分。一个用户进程的地址空间除了用户部分之外，还需要有内核栈等位于内核的部分。exec 只负责初始化==地址空间的用户部分==。

用存储在文件系统里的ELF格式文件来初始化地址空间的用户部分？

一般来说ELF文件会有多个 program header，它们每一个指向必须读入内存的一个程序段，但是xv6中为了简单起见，==只有一个program header==，有关ELF格式的定义**全部在kernel/elf.h中**

# 2.1 loadseg 函数
==先从loadseg函数开始，因为exec函数会调用它==，这个函数负责将一个程序段==载入某个页表的虚拟地址中==。

# 2.2 exec
啊哈，算是大概看了一下exec调用的实现，这个函数的实现==还是非常复杂的，足足写了上百行代码==。在阅读过的代码部分中，我有一个地方不是很明白，那就是以下代码(kernel/exec.c:103)：
![[Pasted image 20241217122203.png]]
为什么要将sp设置到trapframe的a1寄存器中？==sp指向是当前的栈顶位置==，它==本身的值也是程序参数argv的值==。这个值在返回之后何时被放入到用户栈中，或者何时被调用，可能在理解了整个系统调用过程之后才可以被解释清楚，这个问题留待我们在完成实验4之后回过头来看。

# kernel/kalloc.c
和vm.c一样，这里的开头是一个==全局变量的引用声明==，end标明了==自由物理内存的开始位置==
![[Pasted image 20241217122351.png]]
在kernel.ld:43处定义了end标号，它定义在==所有内核代码和数据段之后==，对照一下内核空间
![[Pasted image 20241217122432.png]]
# 3.2 struct run & kmem
**每个run结构体存储在对应空闲页面中，占用着一个指针的大小，指向它的后继者**，而==freelist指针则指向整个空闲链表开头==，如下图所示，==空心圆点表示空指针==。
![[Pasted image 20241217122531.png]]
![[Pasted image 20241217122729.png]]
# 3.3 kfree 函数
首先来看kfree函数，这是因为==freerange函数和kinit函数调用了它==，其实kfree做的事情非常简单，就是使用**头插法将页面回收到空闲链表中**。

# 3.5 kinit 
kinit函数是在**内核启动时对物理内存分配器进行初始化**的函数，只有==经过kinit之后==内存管理器才有内存可以分配。

在这里注意一点，在kernel/main.c的函数中，kinit函数调用在打开页表机制之前，所以==这里的虚拟地址也就等于物理地址==。随着后续kvminit函数将内核页表部署完毕，再使用kvminithart函数打开页表时，这时指针都是虚拟地址，但是由于内核页表是==直接映射==的，所以经过三级页表翻译之后还是等于物理地址。
![[Pasted image 20241217122948.png]]
另外，一个操作系统应该是==从硬件信息中直接获悉系统的内存==，但是xv6直接假定内存只有128MB。所以PHYSTOP的定义如下，这包含所有内核代码和数据以及可用的RAM大小：
![[Pasted image 20241217123006 1.png]]
# 3.6 kalloc 函数
kalloc函数专门负责==分配一页未用的物理内存并返回==，主要操作就是**从空闲链表的头部摘下一个节点并返回**。
