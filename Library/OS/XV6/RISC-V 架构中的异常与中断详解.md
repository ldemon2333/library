考虑RISC-V标准的实现灵活性，我们必须结合一个具体的平台来研究这个过程。这里我们选择了Xv6运行的平台——==SiFive Unleashed==

**由于Xv6运行在Supervisor模式下，所以本篇博客主要围绕S-模式下的寄存器展开**。

在RISC-V标准中，将**异常(exception)定义为当前CPU运行时遇到的==与指令有关==的不寻常情况**，而使用**中断(interrupt)定义为因为外部异步信号而引起的让控制流脱离当前CPU的事件**。而陷阱(trap)表示的则是，由异常或者中断引起的==控制权转移到陷阱处理程序==的过程。其实Xv6的定义和RISC-V的定义是相互兼容的，我们说在Xv6中有三种方式会触发陷阱：系统调用、中断和程序异常，其实系统调用中的==ecall指令和程序执行中的异常都属于RISC-V标准中定义的异常情况==，而==设备中断则属于下面我们将要介绍的全局中断==。

中断也可以进一步细分为两种情况，**一种是本地中断，一种是全局中断**。本地中断包括==软件中断和定时器中断==，它们由CLINT(Core-Local Interruptor, 核心本地中断器)来控制。另一种是==外部设备引起的中断==，也被称为全局中断，它们由PLIC(Platform-Level Interrupt Controller,平台级中断控制器)来控制。PLIC、CLINT和RISC-V核心的连接逻辑示意图如下：
![[Pasted image 20241218184538.png]]
而无论是异常还是中断，它们所导致的==硬件陷阱==流程都是一样的，具体来说有两个大动作：
1. 改变控制流
- 将PC的值保存在sepc寄存器中，而将stvec寄存器中保存的陷阱处理函数地址放入PC
2. 更新相关CSR的值，有关这些寄存器的细节在下面进行详细解释
- sstatus
- stval
- scause

有关陷阱和优先级之间的交叉关系，参考这封[问答邮件](https://groups.google.com/a/groups.riscv.org/g/sw-dev/c/-KQnN5EPHF4/m/Ua47avljCQAJ)，这封邮件得到了SiFive工程师的回复和认可，简单来说当我们说一个X-Mode的异常时(X可以是U S M任何一种模式)，我们指的本质上是当异常发生时CPU正工作在X-Mode。而**X-Mode的中断我们指的是，PLIC触发了一个必须由X-Mode响应的中断，CPU 并不一定需要正在工作此模式下。** 时钟中断作为一个特例，在RISC-V 处理器中被硬连线为一个 M-Mode 的中断，这也就是说它必须由M模式下的interrupt handler响应。

# 2. 陷阱的委派
事实上，在RISC-V的标准定义中，所有陷阱==默认都是由机器模式(M-mode)来处理的==。然而，在支持操作系统的设备上往往都实现了==监管者模式(S-Mode)==，如果按照默认模式发生中断则应该**首先陷入M-Mode下的中断处理程序，然后触发一个S-Mode下的中断再mret回S-Mode下处理**，这个过程过于繁琐且需要程序员自己实现，所以：

RISC-V标准为了应对这种情况提出了陷阱委派机制。也就是说在M-Mode下可以配置寄存器，从而使得S-Mode下的所有陷阱都被==S-Mode下的陷阱处理函数自动接管==。有两个寄存器，==medeleg和mideleg，分别用来管理异常和中断的委派==。

首先是medeleg寄存器，它的示意图如下所示，当要把特定的异常委托给S-Mode时，只需要将mcause寄存器中对应数值位置的比特位置1即可，参考下面的表格。比如当==把系统调用委托给S-Mode时==，因为它对应的Exception Code是8，那么==只需要将此寄存器中第8位置为1即可==。

![[Pasted image 20241218185658.png]]

注意，==M-Mode下发生异常，即使它被托管到S-Mode，这个异常也不会被移交给S-Mode去处理，而是在M-Mode完成处理==。这也就是RISC-V规范中所说的：Traps never transition from a more-privileged mode to a less-privileged mode(陷阱从不会从高优先级移交到低优先级)但是如果是发生在S-Mode下的异常，就会被S-Mode直接接管，不会再上交到M-Mode了，这被称为：traps may be taken horizontally(中断可以被水平接管)。

但是，如果一个属于S-Mode的中断==从M-Mode委托给S-Mode==（比方我们后面要看到的外部中断），这个中断==在M-Mode下就会被屏蔽掉==，一定要等到==进入S-Mode时才会被处理==。负责管理中断委派的是mideleg寄存器，示意图如下：
![[Pasted image 20241218185937.png]]
这里有一些点值得澄清：在实现时，无论是在qemu还是在真正的Verilog实现中，所谓mideleg寄存器中==M态下的本地中断（包括时钟中断和软中断）都是被硬连线直接连接到0的==，所以委派时赋值全赋值为1只是出于方便，并不能真的把M-Mode下的本地中断交给S-Mode处理，关于这一点的讨论可以参见[这封问答邮件](https://groups.google.com/a/groups.riscv.org/g/sw-dev/c/-KQnN5EPHF4/m/Ua47avljCQAJ)。**唯一可以被委派到S-Mode的中断是外部中断MEI，外部中断一旦被委派到S-Mode，PLIC就只会触发S-Mode下的中断挂起位sip.SEIP了**，我们在后面会看到更多细节。（注意，这里M-Mode下的==本地中断在实现时不能实现委派是SiFive_Unleashed这块RISC-V平台的实现特例==，具体情况要具体分析，也许以后电路设计不同了，结论就会有所改变，但在这里是成立的）。

所以其实时钟中断和软中断默认情况下都是M-Mode中断，这是由硬件实现决定的，可能你会问那么STI和SSI还有什么意义呢，反正它们也不会被触发。事实上，**它们被触发的唯一可能场景就是在M-Mode下的中断处理程序中被置位，然后通过mret回到S-Mode下再处理**。

在 Xv6 系统启动时，我们可以看到**它将中断和异常的处理权全部委派给了Supervisor模式**，对应的代码在start函数中
![[Pasted image 20241218190402.png]]
在start函数中，通过直接向上述两个寄存器写入全1，实现了外部中断和异常的委派。这也就意味着，在Xv6系统中发生的外部中断和异常(**不包括时钟中断和软中断（ecall），它们默认被硬连线到M-Mode中断**)都将会被S-Mode下的操作系统接管，==不会呈递到M-Mode来处理==。所以接下来，我们的注意力主要放在S-Mode下的相关寄存器上。

# 3. sstatus 寄存器
sstatus寄存器的==全称是supervisor status register==，顾名思义，它是用来反映S-Mode下处理器的工作状态的。当执行RV64时，sstatus寄存器的示意图如下所示：
![[Pasted image 20241218190538.png]]
在sstatus寄存器中与异常和中断有关的位有SPP、SIE、SPIE，下面一个一个来看。

## 3.1 SPP 位
SPP记录的是在进入S-Mode之前处理器的特权级别，==为0表示陷阱源自用户模式(U-Mode)==，为1表示其他模式。当执行一个陷阱时，SPP会由硬件自动==根据当前处理器所处的状态自动设置为0或者1==。当执行SRET指令从陷阱中返回时，如果SPP位为0，那么处理器将会返回U-Mode，为1则会返回S-Mode，最后无论如何，SPP都被设置为0。

## 3.2 SIE 位
SIE位是S-Mode下中断的总开关，就像是一个总电闸。如果SIE位置为0，那么==无论在S-Mode下发生什么中断，处理器都不会响应==。但是**如果当前处理器运行在U-Mode，那么这一位不论是0还是1，S-Mode下的中断都是默认打开的**。也就是说在任何时候==S-Mode都有权因为自己的中断而抢占位于U-Mode下的处理器==，这一点要格外注意。想想定时器中断而导致的CPU调度，事实上这种设计是非常合理的。

所以SIE位是**S-Mode下的**总开关，而不是任何情况下的总开关，真正完全负责禁用或者启用特定中断的位，都在sie寄存器里呢，下面再详细解释。

## 3.3 SPIE 位
SPIE位记录的是在==进入S-Mode之前S-Mode中断是否开启==。当进入陷阱时，硬件会==自动将SIE位放置到SPIE位上==，相当于起到了记录原先SIE值的作用，并最后将SIE置为0，表明==硬件不希望在处理一个陷阱的同时被其他中断所打扰，也就是从硬件的实现逻辑上来说不支持嵌套中断==(即便如此，我们还是可以手动打开SIE位以支持嵌套中断，笑)。当使用SRET指令从S-Mode返回时，SPIE的值==会重新放置到SIE位上来恢复原先的值==，并且将SPIE的值置为1。

## 3.4 进一步说明
关于RISC-V中位于不同特权模式下的响应问题，标准中有进一步的说明：

当一个处理器在特权模式x(x = U or S or M)运行时，xIE控制着这个模式下的中断总开关。**对于更低优先级的中断来说，是默认全部禁用的，而对于更高优先级的中断来说是默认全部打开的**。这意味着==在任何时候高优先级都拥有着对处理器的抢占权，而低优先级则被强行剥夺打断高优先级的权力==。

那么用户难道对这种机制无能为力，只能任凭高优先级随意打断低优先级模式吗？其实也不是，标准上说可以通过==禁用某种特定的中断，使得对应的中断发生时，低优先级的运行不受影响，这是通过设置mie或sie寄存器实现的==。

另外，RISC-V==在硬件层面上来说不支持陷阱的嵌套==，硬件只假设最理想的情况，即：

**发生陷阱->处理它(在此期间完全不发生其他陷阱)->恢复到原先状态。**

所以在sstatus寄存器中只保留了一位用来存储上一个状态的SPP和SPIE位，事实上我们==完全可以支持嵌套==，只不过==要提供更多的软件支持==。最重要的也就是，==使用处理器的软件堆栈来保存sstatus等寄存器的值==，等到陷阱返回时再恢复之。我们可以看到kerneltrap函数中的逻辑实现了这一点(kernel/trap.c:131):
![[Pasted image 20241218191415.png]]
但是Xv6对于嵌套中断的支持也就到此为止，不支持更多层的嵌套中断了，在上述的代码中==并没有再次打开中断的操作==。

# 4. stvec 寄存器
stvec 寄存器的全称是 supervisor trap vector base address register (S 态陷阱向量基址寄存器，stvec)，它的示意图如下：
![[Pasted image 20241218191736.png]]
可以看到stvec寄存器分为两个域，分别是BASE域和MODE域，下面我们再分别来仔细研究一下这两个域。
## 4.1 MODE 域
在RISC-V标准的定义中，MODE域可能的取值有如下三种：
![[Pasted image 20241218191802.png]]
可以看到，MODE域的取值影响了==发生陷阱时要跳转到的地址==。之前我们为了描述的方便，一般简单地说stvec中==存放着中断处理程序的地址==，发生陷阱时会直接跳转到。但其实stvec寄存器中不仅仅是中断处理程序的地址，还存放着MODE域的值。
- 当BASE域为0时，所有的陷阱全部==跳转到BASE地址指向的程序入口==
- 当BASE域为1时，异步中断，这里手册上举了一个例子：如果我们==将MODE设置为Vectored状态==，同时触发了一个S-Mode定时器中断(中断号为5)，则程序会跳转到B A S E + 4 × 5 = B A S E + 0 x 14 BASE + 4 \times 5 = BASE + 0x14

## 4.2 BASE 域
BASE域存放着一个基地址，在Direct模式或者是Vectored模式下的同步陷阱情况下，它都指向中断处理程序的地址(这里的地址==可以是虚拟地址，也可以是物理地址==，当然在Xv6的语境下绝大部分都指的是虚拟地址)。

在Vectored模式的非同步陷阱的情况下，比如由外部中断引起的陷阱时，它是==中断服务程序的基址==，加上一个特定偏移量之后才可以对应到对应的中断处理程序。

另外，BASE域有额外的限制因素，它必须是==4-字节对齐的(4-byte aligned)==。所以其实我们可以看到在Xv6的代码实现中，无论是在trampoline.S还是kernelvec.S的汇编代码实现中，在代码的头部总有：
![[Pasted image 20241218192904.png]]
这就是为了让代码文件按照4字节对齐，从而==满足了stvec寄存器的写入需求==。

# 5.sip 与 sie 寄存器
sip与sie这两个寄存器与中断的处理密切相关，在手册对应的部分不仅有关于这两个寄存器的说明。而且还有大量有关中断机制的细节描述，接下来的各个小段都是从RISC-V标准中阅读得到的总结，在此做一个详细记录。

sip与sie都是处理器与中断有关的寄存器，它们合称(Supervisor Interrupt Registers，S-Mode中断寄存器)，sip专门==用来记载挂起的中断位==，sie专门用来==记载使能的中断位==，它们的示意图如下：

![[Pasted image 20241218193011.png]]
在RV-64标准中，这两个寄存器都是64位大小的。 ==标准中断只占据了这两个寄存器的低16位(15:0)==，更高的位都被保存下来以作为扩展用途。和medeleg和mideleg寄存器的用法差不多，**将中断号对应的位在这两个寄存器中置位**即可，如下图所示：
![[Pasted image 20241218193236.png]]
如果我们想==触发一个S-Mode下的软件中断==，因为它的异常编号是1(见上表)，则==只需要在sip中将第1位设置为1即可==，sie寄存器的使用方法也是一样的，它表示的是对应编号的中断是否使能。

## 5.1 中断被呈递到何种特权模式下处理

https://blog.csdn.net/zzy980511/article/details/130642258






