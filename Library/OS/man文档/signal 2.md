```
man signal
```

# SYNOPSIS
```
#include <signal.h>

typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

# DESCRIPITION
The behavior of signal() varies across UNIX versions, 不用版本不同历史的 Linux 行为也不同。 Avoid its use: use sigaction(2) instead.

signal() sets the disposition of the signal signum to handler, which is either SIG_IGN, SIG_DEL, or the address of a programmer-defined function (a "signal handler").

If the signal signum is delivered to the process, then one of the following happens：
- SIG_IGN
- SIG_DFL
- If the disposition is set to a function, then first either the disposition is reset to SIG_DFL, or the signal is blocked, and then handler is called with argument signum. If invocation of the handler caused the signal to be blocked, then the signal is unblocked upon return from the handler.

**重置处理方式**：在调用处理程序之前，信号的处理方式通常会重置为默认动作（`SIG_DFL`）。这样做是为了防止在处理程序执行期间再次接收到同样的信号而导致处理程序被多次调用。
**阻塞信号**：触发处理程序的信号可以被阻塞，以防止在处理程序执行期间再次中断该处理程序。这意味着在处理程序运行时，相同的信号不会再次导致处理程序被调用。
**解锁信号**：如果在调用处理程序时信号被阻塞（由于阻塞机制），在处理程序返回后，该信号将自动解除阻塞。这确保了在处理程序执行完毕后，可以正常处理后续信号。

# RETURN VALUE
signal() returns the previous value of the signal handler, or SIG_ERR on error. In the event of an error, errno is set to indicate the cause.

# NOTES
The effects of signal() in a multithreaded process are unspecified.

According th POSIX, the behavior of a process is undefined after it ignores a SIGFPE, SIGLL, or SIGSEGV signal that was not generated by kill(2) or raise(3). Integer division by zero has undefined result. On some architectures it will generate a SIGFPE signal. Ignoring this signal might lead to an endless loop.



