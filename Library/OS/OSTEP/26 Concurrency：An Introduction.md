与我们传统观点认为程序中只有一个执行点（即从中获取和执行指令的单个 PC）不同，多线程程序具有多个执行点（即从中获取和执行指令的多个 PC）。
也许另一种思考方式是，每个线程都非常像一个单独的进程，除了一个区别：它们共享相同的地址空间，因此可以访问相同的数据。

因此，单个线程的状态与进程的状态非常相似。它有一个程序计数器 (PC)，用于跟踪程序从何处获取指令。每个线程都有自己的一组用于计算的私有寄存器；因此，如果有两个线程在单个处理器上运行，当从运行一个线程 (T1) 切换到运行另一个线程 (T2) 时，必须进行上下文切换。线程之间的上下文切换与进程之间的上下文切换非常相似，因为在运行 T2 之前必须保存 T1 的寄存器状态并恢复 T2 的寄存器状态。对于进程，我们将状态保存到进程控制块 (PCB)；现在，我们需要一个或多个线程控制块 (TCB) 来存储进程中每个线程的状态。但是，与进程相比，我们在线程之间执行的上下文切换有一个主要区别：地址空间保持不变（即，无需切换我们正在使用的页表）。

线程和进程之间的另一个主要区别在于堆栈。在我们经典进程（我们现在可以称之为单线程进程）的地址空间的简单模型中，有一个堆栈，通常位于地址空间的底部（图 26.1，左）

![[Pasted image 20241021194939.png]]

然而，在多线程进程中，每个线程都独立运行，当然可能会调用各种例程来完成它正在做的工作。地址空间中不会只有一个栈，而是每个线程都有一个栈。假设我们有一个多线程进程，其中有两个线程；结果地址空间看起来不同（图 26.1，右）。

在此图中，您可以看到两个栈分布在进程的地址空间中。因此，任何栈分配的变量、参数、返回值以及我们放在栈上的其他内容都将放置在有时称为thread-local storage的地方，即相关线程的栈中。

# 26.1 为什么使用 Threads？
为什么要使用线程？

事实证明，至少有两个主要原因应该使用线程。第一个原因很简单：
- 并行性。假设您正在编写一个程序，该程序对非常大的数组执行操作，例如，将两个大数组相加，或者将数组中每个元素的值增加一定量。如果您只在单个处理器上运行，则任务很简单：只需执行每个操作即可完成。但是，如果您在具有多个处理器的系统上执行程序，则可以通过使用每个处理器执行一部分工作来大大加快此过程。将标准的单线程程序转换为在多个 CPU 上执行此类工作的程序的任务称为并行化，使用每个 CPU 的线程来执行这项工作是使程序在现代硬件上运行更快的自然且典型的方法。
- 第二个原因更微妙一些：避免由于 I/O 速度慢而阻塞程序进程。假设您正在编写一个执行不同类型 I/O 的程序：要么等待发送或接收消息，要么等待显式磁盘 I/O 完成，甚至（隐式地）等待页面错误完成。您的程序可能不想等待，而是希望做其他事情，包括利用 CPU 执行计算，甚至发出进一步的 I/O 请求。使用线程是避免卡住的自然方法；当程序中的一个线程等待（即被阻塞等待 I/O）时，CPU 调度程序可以切换到其他线程，这些线程已准备好运行并执行一些有用的操作。线程允许 I/O 与单个程序内的其他活动重叠，就像多道编程对跨程序进程所做的那样；因此，许多现代基于服务器的应用程序（Web 服务器、数据库管理系统等）在其实现中使用线程。

当然，在上述任何一种情况下，您都可以使用多个进程而不是线程。但是，线程共享一个地址空间，因此可以轻松共享数据，因此在构建这些类型的程序时，这是一个自然的选择。对于逻辑上独立的任务，进程是更合理的选择，因为这些任务很少需要共享内存中的数据结构。

# 26.2 一个例子：线程建立
假设运行一个程序，它创建两个线程，每个线程做一些独立工作，比如打印“A”和“B”。
![[Pasted image 20241021200245.png]]
主程序创建两个线程，每个线程会运行函数 mythread()，有不同的参数。一旦创建了线程，它可能会立即开始运行（取决于调度程序的意愿）；或者，它可能处于“就绪”但未“运行”的状态，因此尚未运行。当然，在多处理器上，线程甚至可以同时运行，但我们暂时不必担心这种可能性。

创建两个线程（我们称它们为 T1 和 T2）后，主线程调用 pthread join()，等待某个线程完成。它会执行两次，从而确保 T1 和 T2 运行并完成，然后最终允许主线程再次运行；当它再次运行时，它会打印“main: end”并退出。总的来说，在这次运行中使用了三个线程：主线程、T1 和 T2。

让我们检查一下这个小程序的可能执行顺序。在执行图（图 26.3）中，时间向下增加，每列显示不同的线程（主线程，或线程 1 或线程 2）何时运行。

但请注意，这种排序并不是唯一可能的排序。事实上，给定一个指令序列，有相当多的排序，具体取决于调度程序决定在给定点运行哪个线程。例如，一旦创建了一个线程，它可能会立即运行。

如果调度程序决定首先运行线程 2（尽管线程 1 是较早创建的），我们甚至可以看到“B”在“A”之前打印出来；没有理由假设先创建的线程会先运行。3显示了最终的执行顺序，线程 2 在线程 1 之前开始执行。

![[Pasted image 20241021200839.png]]
![[Pasted image 20241021200546.png]]

但是，系统不是先执行函数然后返回给调用者，而是为被调用的例程创建一个新的执行线程，并且它独立于调用者运行，可能在从创建返回之前，但也可能要晚得多。接下来运行什么由操作系统调度程序决定，尽管调度程序可能实现了一些合理的算法，但很难知道在任何给定时刻将运行什么。

从这个例子中你也许也能看出，线程让生活变得复杂：很难说什么时候运行什么！没有并发，计算机就已经很难理解了。不幸的是，有了并发，情况只会变得更糟。

# 26.3 为什么变得更糟糕了：Shared Data
我们上面展示的简单线程示例有助于展示线程是如何创建的，以及线程如何根据调度程序决定如何运行以不同的顺序运行。但它没有展示的是线程在访问共享数据时如何交互。

让我们想象一个简单的例子，其中两个线程希望更新一个全局共享变量。我们将研究的代码如图 26.6 所示。

![[Pasted image 20241021201702.png]]

以下是有关代码的一些说明。首先，正如 Stevens 所建议的，我们包装了线程创建和连接例程，以便在失败时简单地退出；对于像这样简单的程序，我们希望至少注意到发生了错误（如果发生了），但不要对此采取任何非常聪明的措施（例如，只是退出）。因此，Pthread create() 只是调用 pthread create() 并确保返回代码为 0；如果不是，Pthread create() 只会打印一条消息并退出。

其次，我们不是为工作线程使用两个单独的函数体，而是只使用一段代码，并向线程传递一个参数（在本例中为一个字符串），这样我们就可以让每个线程在其消息之前打印一个不同的字母。

最后，也是最重要的一点，我们现在可以看看每个工作者正在尝试做什么：将一个数字添加到共享变量计数器，并在循环中执行 1000 万次（1e7）。因此，期望的最终结果是：20,000,000。

我们现在编译并运行该程序，看看它的表现如何。有时，一切都按我们预期的方式运行：
![[Pasted image 20241021201740.png]]不幸的是，当我们运行此代码时，即使在单个处理器上，我们也不一定能得到所需的结果。有时，我们会得到：
![[Pasted image 20241021201843.png]]

# 26.4 问题核心：不可控调度
代码序列在做以下事情：
![[Pasted image 20241021213343.png]]
假设counter位于地址0x8049a1c。

假设我们的两个线程之一（线程 1）进入此代码区域，因此即将计数器增加一。它将计数器的值（假设一开始是 50）加载到其寄存器 eax 中。因此，线程 1 的 eax=50。然后它将寄存器加一；因此 eax=51。现在，发生了一些不幸的事情：定时器中断；因此，操作系统将当前正在运行的线程的状态（其 PC、其寄存器（包括 eax 等）保存到线程的 TCB。

现在发生了更糟糕的事情：线程 2 被选中运行，并输入同一段代码。它还执行第一条指令，获取 counter 的值并将其放入其 eax 中（请记住：每个线程在运行时都有自己的私有寄存器；这些寄存器由保存和恢复它们的上下文切换代码虚拟化）。此时 counter 的值仍为 50，因此线程 2 的 eax=50。然后假设线程 2 执行接下来的两条指令，将 eax 加 1（因此 eax=51），然后将 eax 的内容保存到 counter（地址 0x8049a1c）中。因此，全局变量 counter 现在的值为 51。

最后，发生另一次上下文切换，线程 1 恢复运行。回想一下，它刚刚执行了 mov 和 add，现在即将执行最后的 mov 指令。回想一下 eax=51。因此，执行最后的 mov 指令，并将值保存到内存中；计数器再次设置为 51。

简单来说，发生的事情是这样的：增加计数器的代码已经运行了两次，但是从 50 开始的计数器现在只等于 51。这个程序的“正确”版本应该导致变量计数器等于 52。

让我们查看详细的执行跟踪，以便更好地理解问题。假设，对于此示例，上述代码加载到内存中的地址 100，如以下序列（请注意，对于那些习惯使用类似 RISC 的指令集的人来说：x86 具有可变长度的指令；此 mov 指令占用 5 个字节的内存，而 add 仅占用 3 个字节）：
![[Pasted image 20241021213920.png]]
在这些假设下，图 26.7显示了发生的情况。假设计数器从值 50 开始，并跟踪此示例以确保您了解正在发生的事情。

我们在这里演示的称为竞争条件（或更具体地说，数据竞争）：结果取决于代码执行的时间。如果运气不好（即上下文切换发生在执行中的不合时宜的点），我们会得到错误的结果。事实上，我们每次都可能得到不同的结果；因此，我们称这种结果为不确定，而不是良好的确定性计算（我们在计算机上习惯于此），因为不知道输出是什么，而且在运行过程中确实可能会有所不同。

由于多个线程执行此代码可能导致竞争条件，因此我们将此代码称为critical section 。关键部分是一段访问共享变量（或更一般地说，共享资源）的代码，并且不能由多个线程同时执行。

我们真正想要的是这段代码所具有的互斥特性。此特性保证如果一个线程在临界区内执行，其他线程将无法执行。

## 提示：使用原子操作
原子操作是构建计算机系统最强大的底层技术之一，从计算机架构到并发代码（我们在这里研究的内容），再到文件系统（我们很快就会研究它）、数据库管理系统，甚至分布式系统。

将一系列操作原子化的想法可以用“全有或全无”这个短语简单地表达出来；它要么看起来好像所有你想要组合在一起的操作都发生了，要么看起来好像它们都没有发生，没有中间状态可见。有时，将许多操作组合成一个原子操作称为事务，这一想法在数据库和事务处理领域得到了非常详细的发展。

在我们探索并发的主题中，我们将使用同步原语将短指令序列转换为原子执行块，但正如我们将看到的，原子性的概念远不止于此。例如，文件系统使用日志记录或写即复制等技术来自动转换其磁盘状态，这对于在系统故障时正确运行至关重要。

# 26.5  对原子性的渴望
解决这个问题的一种方法是使用更强大的指令，只需一步就可以完成我们需要完成的所有操作，从而消除不合时宜的中断的可能性。例如，如果我们有一条如下所示的超级指令，会怎么样：
![[Pasted image 20241021214427.png]]

假设这条指令将一个值添加到内存位置，并且硬件保证它以原子方式执行；当执行该指令时，它将按预期执行更新。它不能在指令中间被中断，因为这正是我们从硬件获得的保证：当发生中断时，要么指令根本没有运行，要么已经运行完成；没有中间状态。硬件可以是一件美妙的事情，不是吗？

在这种情况下，原子意味着“作为一个单位”，有时我们将其视为“全部或无”。我们希望以原子方式执行三个指令序列：
![[Pasted image 20241021214512.png]]
正如我们所说，如果我们有一条指令来执行此操作，我们只需发出该指令即可完成。但在一般情况下，我们不会有这样的指令。想象一下，我们正在构建一个并发 B 树，并希望更新它；我们真的希望硬件支持“B 树的原子更新”指令吗？可能不会，至少在合理的指令集中不会。

因此，我们要做的是向硬件请求一些有用的指令，在此基础上，我们可以构建一组通用的同步原语。通过使用这种硬件支持，结合操作系统的帮助，我们将能够构建多线程代码，以同步和受控的方式访问关键部分，从而可靠地产生正确的结果，尽管并发执行具有挑战性。

# 26.6 One More Problem: Waiting For Another
本章将并发问题设定为线程之间只发生一种交互，即访问共享变量和需要支持关键部分的原子性。事实证明，还存在另一种常见的交互，即一个线程必须等待另一个线程完成某些操作才能继续。例如，当进程执行磁盘 I/O 并进入休眠状态时，就会出现这种交互；当 I/O 完成时，需要将该进程从休眠状态唤醒，以便继续。

因此，在接下来的章节中，我们不仅将研究如何构建对同步原语的支持以支持原子性，还将研究如何构建机制以支持这种在多线程程序中常见的睡眠/唤醒交互。如果现在这还不合理，那也没关系！

## 附言：关键并发术语
临界区、竞争条件、不确定、相互排斥

这四个术语对于并发代码至关重要，因此我们认为有必要明确指出它们。有关更多详细信息。

• 临界区是一段访问共享资源（通常是变量或数据结构）的代码。
• 如果多个执行线程大致同时进入临界区，就会出现竞争条件（或数据竞争）；两者都试图更新共享数据结构，导致令人惊讶的（也许是不受欢迎的）结果。
• 不确定程序由一个或多个竞争条件组成；程序的输出因运行而异，取决于哪些线程在何时运行。因此，结果不是确定性的，这是我们通常期望计算机系统具有的。
• 为避免这些问题，线程应使用某种互斥原语；这样做可保证只有一个线程进入临界区，从而避免竞争，并产生确定性的程序输出。

# 26.7 总结
在结束之前，你可能会问：我们为什么要在操作系统课上学习这个？“历史”是一个答案；操作系统是第一个并发程序，并且创建了许多技术供操作系统使用。后来，随着多线程进程的出现，应用程序程序员也必须考虑这些事情。

例如，想象一下有两个进程正在运行的情况。假设它们都调用 write() 来写入文件，并且都希望将数据附加到文件（即，将数据添加到文件末尾，从而增加其长度）。为此，两者都必须分配一个新块，在文件的 inode 中记录此块所在的位置，并更改文件的大小以反映新的更大大小（除其他事项外；我们将在本书的第三部分了解有关文件的更多信息）。因为中断可能随时发生，所以更新这些共享结构（例如，用于分配的位图或文件的 inode）的代码是关键部分；因此，从引入中断之初，操作系统设计人员就不得不担心操作系统如何更新内部结构。不合时宜的中断会导致上述所有问题。毫不奇怪，页表、进程列表、文件系统结构以及几乎每个内核数据结构都必须使用适当的同步原语小心访问，才能正常工作。


---
`pthread_create` 函数用于创建一个新的线程，其函数原型如下：

```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
```

以下是每个参数的详细解释：

1. **`pthread_t *thread`**：
   - 这是一个指向 `pthread_t` 类型的指针，用于存储新创建线程的 ID。这个 ID 可用于后续的线程操作，如 `pthread_join`。

2. **`const pthread_attr_t *attr`**：
   - 这是一个指向 `pthread_attr_t` 类型的指针，用于设置线程的属性。如果传递 `NULL`，则使用默认属性（如默认栈大小和调度策略）。

3. **`void *(*start_routine)(void *)`**：
   - 这是一个指向函数的指针，该函数将在新线程中执行。这个函数必须接受一个 `void *` 类型的参数，并返回 `void *` 类型的结果。

4. **`void *arg`**：
   - 这是传递给 `start_routine` 的参数，可以是任何类型的数据，但在函数中必须将其转换为合适的类型。通常用来传递一些数据给线程。

`pthread_create` 函数的返回值为一个整型值，用于指示函数的执行结果：

- **返回 0**：表示线程成功创建。
- **返回错误码**：如果线程创建失败，返回一个错误码，可能的错误包括：
  - `EAGAIN`：系统资源不足，无法创建更多线程。
  - `EINVAL`：指定的线程属性无效。
  - `EPERM`：调用线程没有足够的权限来设置调度策略。

在实际使用中，通常会检查返回值以确定线程是否成功创建，例如：

```c
if (pthread_create(&thread_id, NULL, my_function, NULL) != 0) {
    perror("Failed to create thread");
}
```

---

`pthread_join` 函数用于等待指定线程的结束，并获取其返回值。其函数原型如下：

```c
int pthread_join(pthread_t thread, void **thread_return);
```

### 参数解释

1. **`pthread_t thread`**：
   - 要等待的线程的 ID。这个 ID 是在创建线程时获得的，通常由 `pthread_create` 返回。

2. **`void **thread_return`**：
   - 这是一个指向 `void *` 指针的指针，用于接收线程的返回值。如果不需要获取返回值，可以传递 `NULL`。

### 返回值

- **返回 0**：表示成功等待指定的线程结束。
- **返回错误码**：如果等待失败，可能的错误包括：
  - `ESRCH`：指定的线程不存在。
  - `EINVAL`：指定的线程 ID 无效。
  - `EDEADLK`：发生死锁，无法等待该线程。

---
在 C 语言中，字符串是以字符数组的形式存储的，实际上是一个指向字符的指针。当你使用 `printf` 函数打印字符串时，`%s` 格式化说明符会将传入的指针视为字符串的起始地址。

### 具体解释：

1. **字符串的表示**：
   - 字符串在内存中是以字符数组的形式存储的，以 `\0`（空字符）结尾。例如，字符串 `"Hello"` 实际上是在内存中存储为 `['H', 'e', 'l', 'l', 'o', '\0']`。

2. **指针的使用**：
   - 当你定义一个字符串时，比如 `const char *str = "Hello";`，`str` 实际上是一个指针，指向字符串的首字符 `'H'` 的内存地址。

3. **`printf` 的工作原理**：
   - 当你调用 `printf("%s\n", str);` 时，`printf` 会读取 `str` 指向的内存地址，并从该地址开始逐个读取字符，直到遇到 `\0` 为止。这就是它知道何时停止打印的原因。

### 示例：
```c
const char *str = "Hello";
printf("%s\n", str); // str 被视为指向字符串的指针
```

这段代码会打印字符串 `"Hello"`，因为 `printf` 从 `str` 指向的地址开始，依次读取字符直到遇到 `\0`。

总结来说，指针能够直接传递给 `printf`，是因为 C 语言将字符串视为字符的数组，而 `%s` 格式化说明符用于处理这些字符数组。