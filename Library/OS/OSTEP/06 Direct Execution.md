为了虚拟化 CPU，操作系统需要以某种方式在看似同时运行的许多作业之间共享物理 CPU。基本思想是时间片轮转法。

然而，在构建这种虚拟化机制时存在一些挑战。第一个是性能：我们如何在不给系统增加过多开销的情况下实现虚拟化？第二个是控制：我们如何在保持对 CPU 的控制的同时高效地运行进程？

# 6.1 基本技巧：有限直接执行
为了使程序运行速度达到预期，操作系统开发人员想出了一种技术，我们称之为 limited direct execution，这并不令人意外。这个想法的“直接执行”部分很简单：直接在 CPU 上运行程序。因此，当操作系统希望启动程序时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码加载到内存中（从磁盘），找到其入口点（即 main() 例程或类似的东西），跳转到它，然后开始运行用户的代码。图 6.1 显示了这个基本的直接执行协议（目前没有任何限制），使用正常调用和返回跳转到程序的 main()，然后返回内核。

但是这种方法在我们虚拟化 CPU 的过程中引发了一些问题。第一个很简单：如果我们只是运行一个程序，操作系统如何确保程序不会做我们不希望它做的事情，同时仍然高效地运行它？第二：当我们运行一个进程时，操作系统如何停止它运行并切换到另一个进程，从而实现虚拟化 CPU 所需的时间共享？

![[Pasted image 20241027111125.png]]

# 6.2 Problem 1: Restricted Operations
直接执行具有明显的速度优势；程序在硬件 CPU 上本地运行，因此执行速度与预期一样快。但在 CPU 上运行会带来一个问题：如果进程希望执行某种受限操作，例如向磁盘发出 I/O 请求，或者获取对更多系统资源（如 CPU 或内存）的访问权限，该怎么办？


## 附言：为什么系统调用看起来像过程调用
看起来与 C 中的典型过程调用完全一样；也就是说，如果它看起来就像一个过程调用，那么系统如何知道它是一个系统调用，并执行所有正确的操作？原因很简单：它是一个过程调用，但隐藏在该过程调用中的是著名的 trap 指令。更具体地说，当您调用 open()时，您正在执行进入 C 库的过程调用。其中，无论是对于 open() 还是提供的任何其他系统调用，库都会使用与内核商定的调用约定将 open() 的参数放在众所周知的位置（例如，在堆栈上或特定寄存器中），将系统调用号也放入众所周知的位置（再次，在堆栈或寄存器上），然后执行上述 trap 指令。trap 之后的库中的代码会解压返回值并将控制权返回给发出系统调用的程序。因此，C 库中进行系统调用的部分都是用汇编语言手工编码的，因为它们需要严格遵循惯例才能正确处理参数和返回值，以及执行特定于硬件的陷阱指令。

因此，我们采取的方法是引入一种新的处理器模式，称为用户模式；

与用户模式相对的是内核模式，操作系统（或内核）在其中运行。在这种模式下，运行的代码可以做它想做的事情，包括特权操作，例如发出 I/O 请求和执行所有类型的受限指令。

然而，我们仍然面临一个挑战：当用户进程希望执行某种特权操作（例如从磁盘读取）时，它应该做什么？为了实现这一点，几乎所有现代硬件都为用户程序提供了执行系统调用的能力。系统调用最早出现在 Atlas 等古老机器上，它允许内核谨慎地向用户程序公开某些关键功能，例如访问文件系统、创建和销毁进程、与其他进程通信以及分配更多内存。大多数操作系统提供几百个调用（有关详细信息，请参阅 POSIX 标准）

要执行系统调用，程序必须执行特殊的 trap 指令。该指令同时跳转到内核并将特权级别提升到内核模式；一旦进入内核，系统就可以执行所需的任何特权操作（如果允许），从而为调用进程完成所需的工作。完成后，操作系统会调用一个特殊的 return-from-trap 指令，正如您所预料的那样，该指令会返回到调用用户程序，同时将特权级别降低回用户模式。

执行陷阱时，硬件需要小心一点，因为它必须确保存足够多的调用者寄存器，以便能够在操作系统发出从陷阱返回指令时正确返回。

这个讨论遗漏了一个重要细节：trap 如何知道在操作系统内运行哪些代码？显然，调用进程不能指定要跳转到的地址（就像在进行过程调用时一样）；这样做将允许程序跳转到内核中的任何位置。因此，内核必须仔细控制在陷阱上执行哪些代码。

内核通过在启动时设置陷阱表来实现这一点。当机器启动时，它以特权（内核）模式启动，因此可以根据需要自由配置机器硬件。**因此，操作系统要做的第一件事就是告诉硬件在发生某些异常事件时要运行什么代码**。例如，当发生硬盘中断、键盘中断或程序进行系统调用时应该运行什么代码？操作系统通常会使用某种特殊指令通知硬件这些陷阱处理程序的位置。一旦硬件得到通知，它就会记住这些处理程序的位置，直到机器下次重新启动，因此硬件知道在发生系统调用和其他异常事件时该做什么（即跳转到什么代码）。

为了指定确切的系统调用，通常会为每个系统调用分配一个系统调用号。因此，用户代码负责将所需的系统调用号放在寄存器中或堆栈上的指定位置；操作系统在处理陷阱处理程序中的系统调用时，会检查此号码，确保其有效，如果有效，则执行相应的代码。这种间接级别是一种保护形式；用户代码无法指定要跳转到的确切地址，而必须通过号码请求特定服务。

最后补充一点：能够执行指令来告诉硬件陷阱表的位置是一项非常强大的功能。因此，您可能已经猜到了，这也是一项特权操作。

时间线（图 6.2 中时间向下增加）总结了该协议。我们假设每个进程都有一个内核堆栈，在进入和退出内核时，寄存器（包括通用寄存器和程序计数器）被保存到该堆栈并从中恢复（由硬件）。

![[Pasted image 20241027141534.png]]

有限直接执行 (LDE) 协议有两个阶段。

在第一阶段（启动时），内核初始化陷阱表，并且CPU 记住其位置以供后续使用。内核通过特权指令执行此操作（所有特权指令都以粗体突出显示）。

在第二阶段（运行进程时），内核在使用从陷阱返回指令开始执行进程之前设置一些内容（例如，在进程列表中分配节点、分配内存）；这会将 CPU 切换到用户模式并开始运行进程。当进程希望发出系统调用时，它会返回到操作系统，操作系统会处理它并再次通过从陷阱返回将控制权返回给进程。然后，进程完成其工作并从main() 返回；这通常会返回到一些存根代码，这些代码将正确退出程序（例如，通过调用 exit() 系统调用，这会陷入操作系统）。此时，操作系统清理完毕，我们就完成了。

# 6.3 Problem #2: Switching Between Processes
直接执行的下一个问题是实现进程之间的切换。进程之间的切换应该很简单，对吧？操作系统应该只是决定停止一个进程并启动另一个进程。这有什么大不了的？但这实际上有点棘手：具体来说，如果一个进程在 CPU 上运行，这在定义上意味着操作系统没有运行。如果操作系统没有运行，它怎么能做任何事情呢？

                关键：如何重新获得对 CPU 的控制权
操作系统如何重新获得对 CPU 的控制权，以便能够在进程之间切换？

## A Cooperative Approach: Wait For System Calls
一些系统过去采用的方法（例如，早期版本的 Macintosh 操作系统或旧的Xerox Alto 系统）被称为合作方法。在这种方式中，操作系统相信系统的进程会合理地运行。运行时间过长的进程会定期放弃 CPU，以便操作系统决定运行其他任务。

因此，您可能会问，在这个乌托邦世界中，友好进程如何放弃 CPU？事实证明，大多数进程通过进行系统调用将 CPU 的控制权频繁地转移给操作系统，例如，打开文件并随后读取它，或向另一台机器发送消息，或创建新进程。这样的系统通常包含显式的让出系统调用，它除了将控制权转移给操作系统以便它可以运行其他进程之外什么也不做。

当应用程序执行非法操作时，它们也会将控制权转移给操作系统。例如，如果应用程序除以零，或者尝试访问它不应该访问的内存，它将生成一个操作系统陷阱。然后操作系统将再次控制 CPU（并可能终止有问题的进程）。

因此，在协作调度系统中，操作系统通过等待系统调用或某种非法操作的发生来重新获得对 CPU 的控制权。您可能还会想：这种被动方法不是不太理想吗？例如，如果一个进程（无论是恶意的，还是充满错误的）最终陷入无限循环，并且从不进行系统调用，会发生什么？那么操作系统可以做什么？

## A Non-Cooperative Approach: The OS Takes Control
如果没有硬件的额外帮助，当进程拒绝进行系统调用（或出错）并将控制权交还给操作系统时，操作系统根本无能为力。事实上，在合作方法中，当进程陷入无限循环时，你唯一的办法就是求助于解决计算机系统中所有问题的古老方法：重新启动机器。因此，我们再次遇到了获得 CPU 控制权的一般任务的一个子问题。


              关键：如何在没有合作的情况下获得控制权
即使进程不合作，操作系统如何获得对 CPU 的控制权？操作系统可以做什么来确保恶意进程不会接管机器？

答案其实很简单，很多年前许多构建计算机系统的人都发现了这一点：定时器中断。定时器设备可以编程为每隔几毫秒发出一次中断；当中断被发出时，当前正在运行的进程将停止，操作系统中预先配置的中断处理程序将运行。此时，操作系统已重新获得对 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。

正如我们之前讨论的系统调用一样，当发生定时器中断时，操作系统必须通知硬件要运行哪些代码；因此，在启动时，操作系统就是这样做的。其次，在启动过程中，操作系统必须启动定时器，这当然是一个特权操作。一旦定时器启动，操作系统就可以放心，因为控制权最终将返回给它，因此操作系统可以自由运行用户程序。定时器也可以关闭（也是一个特权操作），稍后我们将在更详细地了解并发时讨论这一点。

					提示：处理应用程序不当行为
操作系统经常需要处理不当行为的进程，这些进程无论是通过设计（恶意）还是意外（错误）试图做一些它们不应该做的事情。在现代系统中，操作系统试图处理这种不当行为的方式是简单地终止违规者。一击你出局！也许很残酷，但当你试图非法访问内存或执行非法指令时，操作系统还应该做什么？

请注意，当发生中断时，硬件有一定的责任，特别是要保存中断发生时正在运行的程序的足够多的状态，以便后续的 return-from-trap 指令能够正确恢复正在运行的程序。这组操作与硬件在显式系统调用陷入内核期间的行为非常相似，因此各种寄存器都被保存（例如，保存到内核堆栈上），因此可以通过 return-from-trap 指令轻松恢复。

## Saving and Restoring Context
现在，操作系统已经重新获得控制权，无论是通过系统调用协作，还是通过定时器中断更有力地执行，都必须做出决定：是继续运行当前正在运行的进程，还是切换到另一个进程。这个决定是由操作系统的一部分（称为调度程序）做出的。

如果决定切换，操作系统就会执行一段低级代码，我们称之为上下文切换。上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器值（例如，保存到其内核堆栈上），并为即将执行的进程恢复一些寄存器值（从其内核堆栈中）。通过这样做，操作系统可以确保当最终执行从陷阱返回指令时，系统不会返回到正在运行的进程，而是恢复另一个进程的执行。

为了保存当前正在运行的进程的上下文，操作系统将执行一些低级汇编代码来保存当前正在运行的进程的通用寄存器、PC 和内核堆栈指针，然后恢复所述寄存器、PC 并切换到即将执行的进程的内核堆栈。通过切换堆栈，内核在一个进程（被中断的进程）的上下文中输入对切换代码的​​调用，并在另一个进程（即将执行的进程）的上下文中返回。当操作系统最终执行从陷阱返回指令时，即将执行的进程将成为当前正在运行的进程。这样上下文切换就完成了。




						提示：重启很有用
之前，我们指出，在协作抢占下，解决无限循环（和类似行为）的唯一方法是重启机器。虽然你可能嘲笑这种黑客行为，但研究人员已经表明，重启（或一般来说，重新开始某个软件）在构建健壮系统方面可以成为非常有用的工具。
具体来说，重启很有用，因为它将软件移回已知且可能经过更多测试的状态。重启还可以回收陈旧或泄露的资源（例如内存），否则这些资源可能很难处理。最后，重启很容易实现自动化。出于所有这些原因，在大型集群互联网服务中，系统管理软件定期重启一组机器以重置它们并因此获得上述优势的情况并不少见。
因此，下次重启时，你不仅仅是在实施一些丑陋的黑客行为。相反，你正在使用一种久经考验的方法来改善计算机系统的行为。做得好！

图 6.3 显示了整个过程的时间线。在此示例中，进程 A 正在运行，然后被定时器中断中断。硬件保存其寄存器（保存到其内核堆栈上）并进入内核（切换到内核模式）。在定时器中断处理程序中，操作系统决定从运行进程 A 切换到进程 B。此时，它调用 switch() 例程，该例程仔细保存当前寄存器值（保存到 A 的进程结构中），恢复进程 B 的寄存器（从其进程结构条目中），然后切换上下文，具体方法是更改​​堆栈指针以使用 B 的内核堆栈（而不是 A 的内核堆栈）。最后，操作系统从陷阱中返回，恢复 B 的寄存器并开始运行它

![[Pasted image 20241027143835.png]]
进程的内核堆栈是操作系统为每个进程分配的一块内存区域，用于在内核模式下保存该进程的执行上下文和局部变量。具体来说，它的作用包括：

1. **保存上下文信息**：当进程发生系统调用或中断时，内核需要保存当前进程的状态（如寄存器值）。内核堆栈用于存储这些信息，以便在处理完成后能够恢复。

2. **调用内核函数**：当进程请求内核服务（如文件操作、网络通信等）时，内核会在进程的内核堆栈上执行相应的操作。堆栈帮助跟踪函数调用和返回。

3. **处理异常和中断**：内核堆栈也用于处理中断和异常。这些事件发生时，系统会切换到内核模式，并使用内核堆栈来处理这些事件。

每个进程的内核堆栈是独立的，通常在进程创建时分配，大小可以根据操作系统和进程的需求而有所不同。使用内核堆栈可以确保用户模式和内核模式之间的隔离，提高系统的安全性和稳定性。

操作系统上下文切换中两类寄存器保存和恢复的两种情况：

1. **定时器中断时的保存/恢复**：
   - 当发生定时器中断时，当前正在运行的进程的用户寄存器会被硬件自动保存。这是因为操作系统需要暂停当前进程，以便调度其他进程或处理其他任务。
   - 硬件使用该进程的内核堆栈来存储这些寄存器的状态。这种保存是隐式的，意味着用户并不需要显式地调用任何保存操作。

2. **进程切换时的保存/恢复**：
   - 当操作系统决定将执行从进程 A 切换到进程 B 时，内核寄存器的状态会被操作系统显式保存到该进程的进程结构体中。
   - 这一过程将系统的状态从“仿佛刚刚从进程 A 进入内核”转换为“仿佛刚刚从进程 B 进入内核”。这意味着操作系统在上下文切换中必须管理和恢复不同进程的寄存器状态，以确保每个进程能够在其被调度时正确继续执行。


用户寄存器和内核寄存器是计算机体系结构中用于存储不同类型数据的寄存器，具体如下：

1. **用户寄存器**：
   - 用户寄存器是指在用户模式下运行的进程使用的寄存器。这些寄存器用于存储进程的上下文信息，如程序计数器（PC）、堆栈指针（SP）、通用寄存器等。
   - 当一个进程在用户模式下运行时，它只能访问这些寄存器，以保护系统的稳定性和安全性。

2. **内核寄存器**：
   - 内核寄存器是在内核模式下运行的代码（如操作系统内核）使用的寄存器。这些寄存器存储系统调用、硬件中断和其他内核操作的上下文信息。
   - 内核寄存器在系统调用或中断发生时被使用，并且在用户进程与内核之间切换时，这些寄存器的状态需要被保存和恢复。

在上下文切换中，操作系统会保存当前进程的寄存器状态（用户寄存器和内核寄存器），并加载下一个进程的寄存器状态，以确保每个进程在其被调度时能继续执行。

为了让您更好地了解这种切换是如何实施的，图 6.4 显示了 xv6 的上下文切换代码。看看您是否能理解它（您必须了解一些 x86 以及一些 xv6 才能理解）。上下文结构 old 和 new 分别位于旧进程和新进程的进程结构中。
![[Pasted image 20241027144207.png]]

# 6.5 总结
我们描述了一些实现 CPU 虚拟化的关键底层机制，我们将这组技术统称为有限直接执行。基本思想很简单：只需在 CPU 上运行您想要运行的程序，但首先要确保设置硬件，以限制进程在没有操作系统协助的情况下可以执行的操作。这种

通用方法也在现实生活中采用。例如，那些有孩子的人，或者至少听说过孩子的人，可能熟悉对房间进行婴儿防护的概念：锁上装有危险物品的柜子并盖上电源插座。当房间准备好后，您可以让宝宝自由漫步，因为您知道房间中最危险的方面已经受到限制。

以类似的方式，操作系统通过首先（在启动时）设置陷阱处理程序并启动中断计时器，然后仅在受限模式下运行进程来“对 CPU 进行婴儿防护”。通过这样做，操作系统可以非常放心，进程可以高效运行，只需要操作系统干预来执行特权操作，或者当它们独占 CPU 太久而需要切换时。

因此，我们拥有虚拟化 CPU 的基本机制。

## 附言：上下文切换需要多长时间
您可能会自然而然地问：上下文切换之类的操作需要多长时间？甚至系统调用需要多长时间？对于那些好奇的人来说，有一个名为 lmbench 的工具可以精确测量这些内容，以及其他一些可能相关的性能指标。

结果随着时间的推移得到了很大的改善，大致跟踪了处理器的性能。例如，1996 年在 200 MHz P6 CPU 上运行 Linux 1.3.37，系统调用大约需要 4 微秒，上下文切换大约需要 6 微秒。现代系统的性能几乎提高了一个数量级，在具有 2 或 3 GHz 处理器的系统上，结果为亚微秒。

应该注意的是，并非所有操作系统操作都会跟踪 CPU 性能。正如 Ousterhout 所观察到的，许多操作系统操作都是内存密集型的，随着时间的推移，内存带宽并没有像处理器速度那样显着提高 [O90]。因此，根据您的工作量，购买最新最好的处理器可能不会像您希望的那样加快您的操作系统速度。

## 附注：关键的 CPU 虚拟化术语（机制）
• CPU 应支持至少两种执行模式：受限用户模式和特权（非受限）内核模式。
• 典型的用户应用程序在用户模式下运行，并使用系统调用进入内核以请求操作系统服务。
• 陷阱指令会仔细保存寄存器状态，将硬件状态更改为内核模式，并跳转到操作系统的预指定目标：陷阱表。
• 当操作系统完成系统调用服务时，它会通过另一个特殊的从陷阱返回指令返回到用户程序，该指令会降低特权并将控制权返回到跳转到操作系统的陷阱之后的指令。
• 陷阱表必须由操作系统在启动时设置，并确保用户程序无法轻易修改它们。所有这些都是有限直接执行协议的一部分，该协议可以高效运行程序，但不会失去操作系统控制。
• 一旦程序运行，操作系统必须使用硬件机制来确保用户程序不会永远运行，即计时器中断。这种方法是一种非合作性的 CPU调度方法。
• 有时，在计时器中断或系统调用期间，操作系统可能希望从运行当前进程切换到另一个进程，这是一种称为上下文切换的低级技术。

