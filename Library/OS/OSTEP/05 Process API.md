Unix 系统中的进程创建，两个系统调用：fork() 和 exec()。

# 5.1 fork() 系统调用
![[Pasted image 20241021124618.png]]

程序第一次运行时，进程打印 hello 的message；信息是当前进程的pid。进程pid是29146；

进程运行fork()系统调用，创建的进程是调用进程的（几乎）精确副本。这意味着对于操作系统来说，现在看起来好像有两个程序 p1 的副本正在运行，并且都即将从 fork() 系统调用返回。新创建的进程（称为子进程，与创建父进程相对）子进程不会从 `main()` 函数的开始处运行，而是继续执行 `fork()` 调用后的代码。这就是为什么 "hello" 消息只打印了一次，因为只有父进程在调用 `fork()` 之前打印了这条消息。

您可能已经注意到：子进程并不是一个精确的副本。具体来说，尽管它现在拥有自己的地址空间副本（即自己的私有内存）、自己的寄存器、自己的 PC 等等，但它返回给 fork() 调用者的值是不同的。具体来说，虽然父进程接收新创建的子进程的 PID，但子进程接收的返回代码为零。

p1.c 的输出不是确定性的。当创建子进程时，系统中现在有两个我们关心的活动进程：父进程和子进程。假设我们在具有单个 CPU 的系统上运行（为简单起见），那么此时子进程或父进程都可能运行。在我们的示例（上文）中，父进程确实运行，因此首先打印出其消息。在其他情况下，可能会发生相反的情况，正如我们在此输出跟踪中所示：
![[Pasted image 20241021133113.png]]

CPU 调度程序决定在给定时刻运行哪个进程；由于调度程序很复杂，我们通常无法对它将选择做什么以及哪个进程将首先运行做出强有力的假设。事实证明，这种不确定性会导致一些有趣的问题，特别是在多线程程序中。

# 5.2 wait()系统调用
到目前为止，我们还没有做太多事情：只是创建了一个打印出消息并退出的子进程。有时，事实证明，父进程等待子进程完成其正在执行的操作非常有用。此任务通过 wait() 系统调用（或其更完整的兄弟 waitpid()）完成；请参见图 5.2

![[Pasted image 20241021125052.png]]

在这个例子中，父进程调用wait()，延迟它的执行直到子进程完成执行。当子进程完成时，wait()返回给父进程。

![[Pasted image 20241021133607.png]]

通过此代码，我们现在知道子进程将始终先打印。为什么我们知道这一点？好吧，它可能只是像以前一样先运行，因此在父进程之前打印。但是，如果父进程确实先运行，它将立即调用 wait()；此系统调用直到子进程运行并退出才会返回。

# 5.3 exec()系统调用
进程创建 API 的最后一部分也是最重要的部分是 exec()系统调用。当您想要运行与调用程序不同的程序时，此系统调用非常有用。例如，在 p2.c 中调用 fork() 仅在您想要继续运行同一程序的副本时才有用。但是，您通常想要运行不同的程序；exec() 就是这样做的（图 5.3）。
![[Pasted image 20241021134031.png]]

在这个例子中，子进程调用execvp()为了运行程序wc，wc是一个计数字母程序。事实上，它在源文件 p3.c 上运行 wc，从而告诉我们文件中有多少行、多少字和多少字节：
![[Pasted image 20241021134511.png]]
fork() 系统调用很奇怪；它的同伙 exec() 也不那么正常。它的作用是：给定一个可执行文件的名称（例如 wc）和一些参数（例如 p3.c），从该可执行文件加载代码（和静态数据）并用它覆盖其当前代码段（和当前静态数据）；程序的堆和堆栈以及其他内存空间部分被重新初始化。然后操作系统只需运行该程序，将任何参数作为该进程的 argv 传入。因此，它不会创建新进程；而是将当前正在运行的程序（以前称为 p3）转换为另一个正在运行的程序（wc）。在子进程中执行 exec() 之后，几乎就像 p3.c 从未运行过一样；对 exec() 的成功调用永远不会返回。
### 1. `exec()` 的功能
- **替换进程映像**：`exec()` 系统调用会用指定的可执行文件（如 `wc`）替换当前运行进程的代码段和静态数据。这意味着，当前程序的代码和数据将被新程序的代码和数据覆盖。
### 2. 内存空间的变化
- **重初始化内存**：
  - `exec()` 只会重置进程的代码段、静态数据、堆和栈等内存部分。进程的 PID 和其他一些进程属性保持不变。
  - 这意味着调用 `exec()` 后，当前程序的堆和栈会被重新初始化。
### 3. 参数传递
- **传递参数**：在调用 `exec()` 时，可以将命令行参数（如 `p3.c`）传递给新程序。这些参数会作为 `argv` 数组传入新进程。
### 4. 进程的转变
- **不创建新进程**：与 `fork()` 不同，`exec()` 不会创建新的进程，而是将当前进程转变为另一个程序。调用 `exec()` 后，当前程序的执行几乎被完全替换。
- **不会返回**：如果 `exec()` 成功执行，它不会返回到原来的程序；相反，它开始执行新程序。因此，若 `exec()` 成功，原程序后续的代码将不会被执行。
### 5. 示例
通常，`exec()` 和 `fork()` 一起使用。例如，父进程调用 `fork()` 创建子进程，子进程随后调用 `exec()` 来运行新程序。这样，父进程可以继续执行，而子进程则转变为新的程序。


# 5.4 Why? Motivating The API
当然，你可能会有一个大问题：我们为什么要为创建一个新进程这个简单的操作构建这样一个奇怪的接口？事实证明，fork() 和 exec() 的分离对于构建 UNIX shell 至关重要，因为它允许 shell 在调用 fork() 之后但在调用 exec() 之前运行代码；此代码可以改变即将运行的程序的环境，从而可以轻松构建各种有趣的功能。

shell 就是一个用户程序。它会显示一个提示符，然后等待您输入一些内容。然后，您向其中输入命令（即，可执行程序的名称以及任何参数）；在大多数情况下，shell 会找出可执行文件在文件系统中的位置，调用 fork() 来创建一个新的子进程来运行该命令，调用 exec() 的某个变体来运行该命令，然后通过调用 wait() 等待命令完成。当子进程完成后，shell 将从 wait() 返回并再次打印出提示符，准备执行下一个命令。

fork()和exec()分离允许shell做一系列有用的事情。比如：

![[Pasted image 20241021143631.png]]

在上面的例子中，程序 wc 的输出被重定向到输出文件 newfile.txt。shell 完成此任务的方式非常简单：在创建子进程时，在调用 exec() 之前，shell（具体来说，是在子进程中执行的代码）关闭标准输出并打开文件 newfile.txt。通过这样做，即将运行的程序 wc 的任何输出都将发送到文件而不是屏幕（打开的文件描述符在 exec() 调用期间保持打开，从而启用此行为）。

图 5.4 显示了一个执行此操作的程序。具体来说，UNIX 系统从零开始寻找空闲的文件描述符。在这种情况下，关闭 STDOUT_FILENO 将不是第一个可用的文件描述符，文件在调用 open() 时被分配。子进程对文件的后续写入（例如通过 printf() 等例程）将透明地路由到新打开的文件而不是屏幕。以下是运行 p4.c 程序的输出：
![[Pasted image 20241021143949.png]]

这个程序是一个简单的 C 程序，利用 `fork` 创建子进程，然后在子进程中重定向标准输出到文件并执行 `wc` 命令。
5. **子进程分支**：`rc == 0` 进入子进程：
   - 关闭标准输出（`STDOUT_FILENO`）。
   - 打开或创建文件 `p4.output`，以写入模式，截断文件内容，设置权限。
6. **准备执行命令**：定义一个字符指针数组 `myargs`，准备 `wc` 命令和其参数。
   - `myargs[0]` 指向 `wc`，`myargs[1]` 指向 `p4.c`，`myargs[2]` 设为 `NULL` 以标记数组结束。
7. **执行命令**：使用 `execvp` 执行 `wc` 命令，统计 `p4.c` 文件的单词数。
8. **父进程分支**：`else` 分支进入父进程：
   - 调用 `wait(NULL)` 等待子进程结束，并将返回值存储在 `wc` 中。
   - 使用 `assert` 确保 `wc` 是非负的，确保 `wait` 成功。


- `open("./p4.output", ...)`：尝试打开当前目录下的文件 `p4.output`。
- `O_CREAT`：如果文件不存在，则创建该文件。
- `O_WRONLY`：以写入模式打开文件，这意味着只能向文件写入数据。
- `O_TRUNC`：如果文件已经存在，打开时将其内容截断为零长度，即清空文件内容。
- `S_IRWXU`：设置新文件的权限，表示用户（文件所有者）具有读、写和执行权限。

结合起来，这行代码的作用是确保以写入模式打开 `p4.output` 文件，如果文件不存在则创建它，如果文件已经存在，则清空其内容。

程序的最终效果是统计 `p4.c` 文件的单词数，并将结果写入 `p4.output` 文件。

![[Pasted image 20241021143959.png]]

您会注意到（至少）关于此输出的两个有趣的细节。首先，当运行 p4 时，看起来好像什么都没发生；shell 只是打印命令提示符并立即准备好执行您的下一个命令。然而，事实并非如此；程序 p4 确实调用了 fork() 来创建一个新的子程序，然后通过调用 execvp() 运行 wc 程序。您看不到屏幕上打印的任何输出，因为它已被重定向到文件 p4.output。其次，您可以看到，当我们 cat 输出文件时，会找到运行 wc 的所有预期输出。

UNIX 管道的实现方式类似，但使用的是 pipe()系统调用。在这种情况下，一个进程的输出连接到内核管道（即队列），另一个进程的输入连接到同一个管道；因此，一个进程的输出无缝地用作下一个进程的输入，并且可以将长而有用的命令链串在一起。

# 5.5 Process Control And Users
除了 fork()、exec() 和 wait() 之外，还有许多其他接口可用于与 UNIX 系统中的进程交互。例如，kill() 系统调用用于向进程发送信号，包括暂停、终止和其他有用的命令。为方便起见，在大多数 UNIX shell 中，某些按键组合配置为向当前正在运行的进程发送特定信号；例如，control-c 向进程发送 SIGINT（中断）（通常终止它），control-z 发送 SIGTSTP（停止）信号，从而暂停执行中的进程（您可以稍后使用命令恢复它，例如，许多 shell 中都有内置的 fg 命令）。

整个信号子系统提供了丰富的基础架构来向进程传递外部事件，包括在各个进程内接收和处理这些信号的方法，以及向各个进程以及整个进程组发送信号的方法。要使用这种通信形式，进程应使用 signal() 系统调用来“捕获”各种信号；这样做可以确保当特定信号传递给进程时，进程将暂停其正常执行并运行一段特定代码来响应该信号。

这自然会引发一个问题：谁可以向进程发送信号，谁不能？通常，我们使用的系统可以同时有多个人使用；如果其中一个人可以任意发送诸如 SIGINT 之类的信号（中断进程，很可能终止进程），则系统的可用性和安全性将受到损害。因此，现代系统有着用户概念。用户在输入密码以建立凭据后，登录以获取系统资源的访问权限。然后，用户可以启动一个或多个进程，并完全控制它们（暂停它们、终止它们等）。用户通常只能控制自己的进程；操作系统的工作是将资源（如 CPU、内存和磁盘）分配给每个用户（及其进程），以满足总体系统目标。

# 5.6 有用工具
还有许多命令行工具也很有用。例如，使用 ps 命令可以查看正在运行的进程；阅读手册页，了解一些可以传递给 ps 的有用标志。工具 top也非常有用，因为它可以显示系统的进程以及它们消耗了多少 CPU 和其他资源。有趣的是，很多时候，当你运行它时，top 会声称它是最大的资源消耗者；也许它有点自大。命令 kill 可用于向进程发送任意信号，稍微更用户友好的 killall 也可以。请务必小心使用这些命令；如果你不小心杀死了窗口管理器，你面前的计算机可能会变得非常难以使用。

# 5.7 总结
我们介绍了一些处理 UNIX 进程创建的 API：fork()、exec() 和 wait()。但是，我们只是略微了解了一点。

虽然我们对 UNIX 进程 API 的热情依然强烈，但我们也应该注意到，这种积极性并不统一。例如，微软、波士顿大学和瑞士联邦理工学院的系统研究人员最近发表了一篇论文，详细介绍了 fork() 的一些问题，并提倡使用其他更简单的进程创建 API，例如 spawn()。请阅读它以及它所引用的相关作品，以了解这一不同的观点。虽然通常情况下，相信这本书是件好事，但也请记住，作者有自己的观点；这些观点可能并不（总是）像你想象的那样被广泛认同。

---

`perror` 是一个 C 标准库函数，用于打印出最近一次发生错误的描述信息。它通常与系统调用或库函数一起使用，当这些调用返回一个错误值（如 `-1` 或 `NULL`）时，`perror` 可以帮助程序员理解出错的原因。

### 用法

- **语法**：`void perror(const char *s);`
- **参数**：`s` 是一个字符串，通常用作错误信息的前缀。
- **功能**：`perror` 会输出 `s`，后跟 ": " 和与当前 errno 值对应的错误描述。例如，如果文件打开失败，使用 `perror("Open failed")`，输出可能是：
  ```
  Open failed: No such file or directory
  ```

### 例子

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

int main() {
    int fd = open("nonexistentfile.txt", O_RDONLY);
    if (fd < 0) {
        perror("Open failed");
        return 1;
    }
    return 0;
}
```


---
`return` 和 `exit` 在 C 语言中都用于结束程序，但它们有一些关键区别：

### 1. **作用范围**：
- **`return`**：
  - 用于从函数返回，结束当前函数的执行。
  - 如果在 `main()` 函数中使用，返回值会被传递给操作系统作为程序的退出状态。

- **`exit`**：
  - 用于立即终止整个程序的执行，不管在哪个函数中调用。
  - 可以在任何地方调用，退出程序并返回指定的状态码给操作系统。

### 2. **清理过程**：
- **`return`**：
  - 结束函数时会执行函数中的清理工作（如局部变量的析构）。

- **`exit`**：
  - 直接终止程序，所有的 `atexit` 注册的清理函数会被调用，但局部变量不会被析构。

### 3. **退出状态**：
- **`return`**：
  - `return` 语句返回的值在 `main()` 中作为程序的退出状态，通常用 `0` 表示成功，非 `0` 表示错误。

- **`exit`**：
  - `exit(status)` 允许你指定任意整数值作为退出状态。

### 总结
- 使用 `return` 从函数返回，使用 `exit` 结束整个程序。根据需要选择合适的方式来控制程序的执行流和退出状态。

---
`exec` 系列函数用于在当前进程中执行一个新的程序。这些函数在 UNIX 和类 UNIX 系统中非常常用，特别是在创建新的进程（例如，通过 `fork()`）后，用于替换当前进程的映像。以下是关于 `exec` 函数及其变种的一些信息。

### `exec` 函数

`exec` 系列函数的基本形式是：

```c
#include <unistd.h>

int execl(const char *path, const char *arg0, ..., NULL);
int execle(const char *path, const char *arg0, ..., NULL, char *const envp[]);
int execlp(const char *file, const char *arg0, ..., NULL);
int execvp(const char *file, char *const argv[]);
```

### 变种及其功能

1. **`execl`**：
   - 使用可变参数列表传递命令行参数。
   - `path` 是要执行的程序的路径，后面的参数是程序的参数，最后以 `NULL` 结束。
   - 示例：
     ```c
     execl("/bin/ls", "ls", "-l", NULL);
     ```

2. **`execle`**：
   - 与 `execl` 类似，但可以提供环境变量的指针。
   - `envp` 是一个指向环境变量的指针数组，以 `NULL` 结束。
   - 示例：
     ```c
     char *const env[] = { "VAR=value", NULL };
     execle("/bin/ls", "ls", "-l", NULL, env);
     ```

3. **`execlp`**：
   - 类似于 `execl`，但可以在系统的 `PATH` 中搜索指定的可执行文件。
   - 不需要提供完整的路径。
   - 示例：
     ```c
     execlp("ls", "ls", "-l", NULL);
     ```

4. **`execvp`**：
   - 类似于 `execv`，使用一个参数数组来传递命令行参数。
   - `argv` 是一个指向参数字符串的指针数组，以 `NULL` 结束。
   - 可以在 `PATH` 中搜索可执行文件。
   - 示例：
     ```c
     char *args[] = { "ls", "-l", NULL };
     execvp("ls", args);
     ```

### 特点

- **替换进程映像**：调用 `exec` 系列函数后，当前进程的映像会被新的程序替换，原进程的代码和数据不再存在。因此，`exec` 函数通常不返回，除非调用失败。
- **错误处理**：如果调用 `exec` 系列函数失败（例如，指定的程序不存在），会返回 `-1`，并设置 `errno` 以指示错误类型。

### 使用示例

以下是一个简单的示例程序，使用 `fork()` 和 `execlp()` 执行 `ls` 命令：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    
    if (pid < 0) {
        perror("Fork failed");
        exit(1);
    } else if (pid == 0) {
        // Child process
        execlp("ls", "ls", "-l", NULL);
        perror("execlp failed");  // Only reached if execlp fails
        exit(1);
    } else {
        // Parent process
        wait(NULL);  // Wait for child process to finish
        printf("Child process completed.\n");
    }

    return 0;
}
```

在这个例子中，子进程通过 `execlp` 执行 `ls -l` 命令，而父进程等待子进程完成。

---
`wait()` 函数用于父进程等待其子进程的结束，并可以获取子进程的退出状态。

### 函数原型

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *status);
```

### 参数解释

- **`status`**：
   - 一个指向 `int` 类型的指针，用于存储子进程的终止状态信息。
   - 如果 `status` 不是 `NULL`，`wait()` 会将子进程的退出状态写入 `status` 所指向的地址中。
   - 如果你不关心子进程的状态信息，可以将 `status` 传递为 `NULL`，这样父进程只会等待子进程结束，而不会获得其状态。

### 返回值

- 如果成功，`wait()` 返回 **终止的子进程的 PID**。
- 如果调用失败（例如父进程没有子进程可等待），`wait()` 返回 `-1`，并设置 `errno` 来指示错误原因。

### 解析 `status` 参数

当子进程终止时，`status` 值中会包含编码的信息，指示子进程如何终止。可以使用一些宏来提取这些信息：

1. **`WIFEXITED(status)`**：
   - 如果子进程是通过 **正常退出**（调用 `exit()` 或 `return` 语句）结束的，这个宏会返回 **真**。
   - 如果返回真，可以使用 `WEXITSTATUS(status)` 来获取子进程的 **退出状态**。

   示例：
   ```c
   if (WIFEXITED(status)) {
       printf("子进程正常退出，退出状态: %d\n", WEXITSTATUS(status));
   }
   ```

2. **`WEXITSTATUS(status)`**：
   - 如果 `WIFEXITED(status)` 返回真，则此宏会返回子进程的 **退出状态**（即 `exit()` 中传递的参数值，或 `main()` 函数的返回值）。
   - 返回的值通常是 0 到 255 之间的整数，表示子进程的退出代码。

3. **`WIFSIGNALED(status)`**：
   - 如果子进程是由于 **信号终止** 的，而不是正常退出，此宏返回 **真**。
   - 如果为真，可以使用 `WTERMSIG(status)` 获取导致子进程终止的信号编号。

   示例：
   ```c
   if (WIFSIGNALED(status)) {
       printf("子进程因信号 %d 终止\n", WTERMSIG(status));
   }
   ```

4. **`WTERMSIG(status)`**：
   - 如果 `WIFSIGNALED(status)` 返回真，此宏返回导致子进程终止的 **信号编号**。

5. **`WIFSTOPPED(status)`**：
   - 如果子进程由于接收到 **停止信号**（例如 `SIGSTOP`）而暂停，此宏返回 **真**。

   示例：
   ```c
   if (WIFSTOPPED(status)) {
       printf("子进程由于信号 %d 被停止\n", WSTOPSIG(status));
   }
   ```

6. **`WSTOPSIG(status)`**：
   - 如果 `WIFSTOPPED(status)` 返回真，此宏返回导致子进程暂停的 **信号编号**。

7. **`WIFCONTINUED(status)`**（POSIX.1-2001）：
   - 如果子进程在停止后通过 `SIGCONT` 信号 **继续执行**，此宏返回 **真**。


### 总结

- `wait()` 函数的 `status` 参数允许父进程获取子进程的终止信息。
- `status` 是一个整数，通过不同的位编码来指示子进程是正常退出、被信号终止还是被信号停止。
- 使用 `WIFEXITED`、`WEXITSTATUS`、`WIFSIGNALED` 等宏，可以解码 `status` 值，了解子进程的退出原因。

---

`waitpid()` 是一个用于进程管理的系统调用，它允许父进程等待特定的子进程结束并收集其终止状态。相较于 `wait()`，`waitpid()` 提供了更灵活的功能，使得父进程可以选择等待特定的子进程，而不是任何一个子进程。

### `waitpid()` 的语法

```c
pid_t waitpid(pid_t pid, int *status, int options);
```

### 参数说明

1. **pid**: 
   - 如果 `pid` 是正数，`waitpid()` 将等待具有相应进程ID的子进程。
   - 如果 `pid` 是 `-1`，则等待任意子进程。
   - 如果 `pid` 是 `0`，则等待与调用进程属于同一进程组的任意子进程。
   - 如果 `pid` 是负数，等待与调用进程属于同一进程组的子进程。

2. **status**: 
   - 一个指向整型的指针，用于存储子进程的终止状态。父进程可以通过这个参数来检查子进程是正常退出、异常退出还是被信号终止。

3. **options**: 
   - 可以是以下选项之一，或者它们的组合：
     - `0`：阻塞等待子进程结束。
     - `WNOHANG`：如果没有子进程已结束，则立即返回，不会阻塞。
     - `WUNTRACED`：还会返回那些停止但未终止的子进程的状态。

### 返回值

- **成功**：返回已结束的子进程的进程ID。
- **失败**：返回 `-1`，并设置 `errno` 来指示错误原因。

### 使用场景

- **精确控制**：当父进程需要等待特定的子进程，而不是任意一个子进程时，`waitpid()` 提供了这种能力。
- **非阻塞等待**：可以使用 `WNOHANG` 选项来进行非阻塞等待，适合需要并发处理的场景。
- **处理多个子进程**：在有多个子进程的情况下，父进程可以通过 `waitpid()` 逐个处理每个子进程的结束状态，避免出现僵尸进程。



