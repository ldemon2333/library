---

---
在 C 语言中，`printf` 系列函数用于格式化输出，它们的用法类似，但输出目标不同。以下是几种常见的 `printf` 函数及其作用：

### 2. `sprintf`
`sprintf` 用于将格式化的输出写入字符串中，而不是打印到控制台。

#### 用法：
```c
int sprintf(char *str, const char *format, ...);
```

- **str**：目标字符串，用于存放格式化的输出。
- **format**：格式化字符串。
- **...**：插入的参数。

#### 示例：
```c
char buffer[100];
int num = 42;
sprintf(buffer, "Number: %d", num);
```

### 3. `snprintf`
`snprintf` 与 `sprintf` 类似，但它可以指定要写入的最大字符数，以避免缓冲区溢出问题。

#### 用法：
```c
int snprintf(char *str, size_t size, const char *format, ...);
```

- **size**：最大写入字符数，包括字符串结尾的 `\0`。
- **str**：目标字符串。
- **format**：格式化字符串。
- **...**：插入的参数。

#### 示例：
```c
char buffer[10];
snprintf(buffer, sizeof(buffer), "Number: %d", 12345);
```

### 4. `fprintf`
`fprintf` 用于将格式化的输出写入指定的文件流中（如文件、标准输出或标准错误）。

#### 用法：
```c
int fprintf(FILE *stream, const char *format, ...);
```

- **stream**：目标文件流。
- **format**：格式化字符串。
- **...**：插入的参数。

#### 示例：
```c
FILE *fp = fopen("output.txt", "w");
if (fp != NULL) {
    fprintf(fp, "Writing to a file: %d\n", 42);
    fclose(fp);
}
```

### 5. `vprintf`
`vprintf` 是 `printf` 的变体，用于处理变长参数列表，通常与 `va_list` 一起使用。

#### 用法：
```c
int vprintf(const char *format, va_list arg);
```

- **format**：格式化字符串。
- **arg**：变长参数列表。

#### 示例：
```c
#include <stdarg.h>
#include <stdio.h>

void myPrint(const char *format, ...) {
    va_list args;
    va_start(args, format);
    vprintf(format, args);
    va_end(args);
}

int main() {
    myPrint("Number: %d\n", 100);
    return 0;
}
```

### 6. `vsprintf` / `vsnprintf`
`vsprintf` 和 `vsnprintf` 类似于 `sprintf` 和 `snprintf`，但处理的是变长参数列表。

- **vsprintf**：写入字符串，但不限定长度。
- **vsnprintf**：写入字符串，限定最大字符数。

#### 用法：
```c
int vsprintf(char *str, const char *format, va_list arg);
int vsnprintf(char *str, size_t size, const char *format, va_list arg);
```

### 标准流与文件流的关系
标准流在 C 语言中被表示为 `FILE` 类型的指针，分别是：
- `stdin`：`FILE *stdin` （用于标准输入）
- `stdout`：`FILE *stdout` （用于标准输出）
- `stderr`：`FILE *stderr` （用于标准错误输出）

这些流与 `fopen` 函数打开的文件流类型一致，所以可以使用诸如 `fscanf`、`fprintf` 之类的文件操作函数与标准流进行交互。

### 缓冲机制
- **`stdout`** 默认是**行缓冲**，即每输出一行（遇到换行符）时刷新缓冲区。
- **`stderr`** 是**无缓冲**的，意味着错误信息一旦输出就立即显示，不会等待缓冲区填满。
- **`stdin`** 是**行缓冲**，在用户按下回车键时，输入被提交。

---
使用strace查看进程的系统调用
![[Pasted image 20241015225529.png]]
这段输出是通过 `strace` 工具捕获的系统调用跟踪信息。它显示了一个程序执行时的两个主要系统调用，分别是 `execve` 和 `exit`，以及程序的退出状态。让我们逐行解释：

### 1. `execve("./minimal", ["./minimal"], 0x7ffd7af3cfa0 /* 30 vars */) = 0`

- **`execve`**：这是一个系统调用，用于执行一个可执行文件。在这个例子中，程序正在尝试执行一个名为 `./minimal` 的可执行文件。
- **`"./minimal"`**：这是程序的文件路径，表示可执行文件的名称。
- **`["./minimal"]`**：这是传递给该程序的参数列表，包含一个参数，即可执行文件名本身。通常，第一个参数是可执行文件名（类似于命令行中的 `argv[0]`）。
- **`0x7ffd7af3cfa0 /* 30 vars */`**：这是程序的环境变量指针，指向一个包含 30 个环境变量的内存地址。`strace` 没有详细列出这些环境变量，而是用注释 `/* 30 vars */` 来简化说明。
- **`= 0`**：这个部分表示 `execve` 系统调用的返回值。在成功执行时，`execve` 的返回值通常为 `0`，表示程序被成功加载并开始执行。

在这里，`execve("./minimal", ...) = 0` 表示系统成功执行了名为 `./minimal` 的程序。

### 2. `exit(101) = ?`

- **`exit(101)`**：这表示程序正在调用 `exit` 系统调用，并传递了一个退出状态码 `101`。
- **`= ?`**：这里表示系统调用返回的值是不确定的（`exit` 系统调用通常不会返回给调用程序，因为程序已经退出）。但这个退出码将传递给操作系统或父进程。

### 3. `+++ exited with 101 +++`

- **`exited with 101`**：这表示程序以退出码 `101` 退出。操作系统接收到该退出码并报告程序终止状态。
- **`+++`**：这是 `strace` 的输出格式，用来标记程序的终止。
---

## 2.1 虚拟CPU
![[Pasted image 20241016113006.png]]

![[Pasted image 20241016113019.png]]

![[Pasted image 20241016113029.png]]

## 2.2 虚拟内存
![[Pasted image 20241016002241.png]]
输出：
![[Pasted image 20241016002252.png]]
![[Pasted image 20241016002309.png]]
这个程序做这么几件事。首先，它分配一些内存（a1），内存指针执行p。然后它打印这个内存的地址（a2），然后将0放入这个新分配内存的第一个槽中（a3）。最后，循环，延迟一秒并自加这个值，每次输出PID和这个值。

多进程运行时，每个进程都分配到了同一个地址（0x200000），同时每个看起来都在独立的更新这个地址所存储的值。这好像每个进程都有自己私有内存，而不是与其他进程共享同一个物理内存。

确实，这就是OS虚拟内存。每个进程访问它私有虚拟地址（也称为它的地址空间），这是OS以某种方式映射到物理内存。一个在运行的进程的内存引用不会影响到其他进程的地址空间。

## 2.3 Concurrency
![[Pasted image 20241016003450.png]]
另一个主题是并发。现代多线程程序也有这个问题。

threads.c的main函数创建两个线程通过使用Pthread_create()。你可以认为一个线程是一个函数与其他函数运行在同一个内存空间，并且同时有多个线程在运行。在此示例中，每个线程开始在名为 worker() 的例程中运行，在该例程中，它只是在循环中按循环次数增加计数器。

下面是当我们将变量 loops 的输入值设置为 1000 来运行此程序时发生的情况的记录。 loops 的值决定了两个 worker 中每个 worker 在循环中将共享计数器增加多少次。当将 loops 的值设置为 1000 来运行程序时，您期望 counter 的最终值是多少？

![[Pasted image 20241016004432.png]]
当两个线程结束时，最终counter的值为2000，因为每个线程自增counter1000次。确实，当这输入loops值为$N$时，我们期待最终的输出是$2N$。但不是这样的。
![[Pasted image 20241016112351.png]]
这个共享counter自增的程序使用三种指令：一是从内存将counter的值加载到寄存器中，一是自增这个值，还有一个是将这个值存回内存中。因为这三条指令并没有原子执行（立刻执行），奇怪的事情就会发生。这就是并发性要解决的问题。


## 2.4 Persistence
在系统内存中，数据很容易丢失，因为DRAM以易失性存储值。当断电或系统崩溃时，任何内存内的数据都会丢失。因此我们需要硬件和软件能够去持久地存储数据。

硬件以某种输入/输出或 I/O 设备的形式出现；在现代系统中，硬盘是长期信息的常见存储库，尽管固态硬盘 (SSD) 也在这个领域取得了进展。

OS中软件通常管理硬盘通过文件系统。

与操作系统为 CPU 和内存提供的抽象不同，操作系统不会为每个应用程序创建私有的虚拟化磁盘。相反，它假设用户经常希望共享文件中的信息。例如，在编写 C 程序时，您可能首先使用编辑器（例如 Emacs）来创建和编辑 C 文件（emacs -nw main.c）。完成后，您可能使用编译器将源代码转换为可执行文件（例如 gcc -o main main.c）。完成后，您可以运行新的可执行文件（例如 ./main）。因此，您可以看到文件如何在不同的进程之间共享。首先，Emacs 创建一个文件作为编译器的输入；编译器使用该输入文件创建新的可执行文件（分为多个步骤 - 参加编译器课程了解详情）；最后，运行新的可执行文件。这样，一个新的程序就诞生了！

![[Pasted image 20241016233523.png]]
图2.6描述创建一个文件（/tmp/file）包含string ”hellp world“的代码。

为了完成这个任务，该程序进行了3次系统调用。
- 首先，open()系统调用，打开文件和创建它；
- write()，向这个文件写入一些数据；
- close()，简单地关闭这个文件因此表明程序不再会写入一些数据。
这些系统调用被路由到操作系统中称为文件系统的部分，然后该部分处理请求并向用户返回某种错误代码。

您可能想知道操作系统如何才能真正写入磁盘。我们会向您展示，但您必须先闭上眼睛；这太令人不快了。文件系统必须做相当多的工作：首先确定这些新数据将驻留在磁盘上的位置，然后在文件系统维护的各种结构中跟踪它。这样做需要向底层存储设备发出 I/O 请求，以读取现有结构或更新（写入）它们。任何编写过设备驱动程序的人都知道，让设备代表您做某事是一个复杂而详细的过程。它需要深入了解低级设备接口及其确切语义。幸运的是，操作系统提供了一种通过其系统调用访问设备的标准而简单的方法。因此，操作系统有时被视为标准库。

当然，关于如何访问设备，以及文件系统如何在所述设备上持久地管理数据，还有更多细节。出于性能原因，大多数文件系统首先会将此类写入延迟一段时间，希望将它们分批处理成更大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都采用了某种复杂的写入协议，例如日志记录或写时复制，仔细地对磁盘的写入进行排序，以确保如果在写入序列中发生故障，系统可以在之后恢复到合理的状态。为了使不同的常见操作高效，文件系统采用了许多不同的数据结构和访问方法，从简单的列表到复杂的 b-tree。如果所有这些还不合理，那就太好了！我们将在本书关于持久性的第三部分中更详细地讨论所有这些内容，我们将在其中讨论设备和 I/O 的一般情况，然后详细讨论磁盘、RAIDs 和文件系统。

## 2.5 设计目标
现在，您已经了解了操作系统的实际功能：它利用物理资源（例如 CPU、内存或磁盘）并对其进行虚拟化。它处理与并发相关的棘手问题。它持久存储文件，从而确保文件长期安全。鉴于我们想要构建这样的系统，我们希望在心中设定一些目标，以帮助专注于我们的设计和实施，并在必要时做出权衡；找到正确的权衡是构建系统的关键。

最基本的目标之一是建立一些抽象，以便使系统方便易用。抽象是我们在计算机科学中所做的一切的基础。抽象使得我们能够通过将大型程序分成小而易理解的部分来编写大型程序，在每一节中，我们将讨论一些随着时间的推移而发展起来的主要抽象，让您可以思考操作系统的各个部分。

设计OS的目的是提供高性能；或者说是最小化OS的开销。虚拟化使系统易于使用是值得的，但并非不惜一切代价；因此，我们必须努力提供虚拟化和其他操作系统功能，而不会产生过多的开销。这些开销有多种形式：额外的时间（更多指令）和额外的空间（在内存或磁盘上）。如果可能的话，我们将寻求最小化其中一个或另一个或两者的解决方案。然而，完美并不总是可以实现的，我们将学会注意并（在适当的情况下）容忍它。

另一个目标是在应用程序之间以及操作系统和应用程序之间提供保护。因为我们希望允许许多程序同时运行，所以我们要确保一个程序的恶意或意外不良行为不会损害其他程序；我们当然不希望应用程序能够损害操作系统本身（因为这会影响系统上运行的所有程序）。保护是操作系统主要原则之一的核心，即隔离；将进程彼此隔离是保护的关键，因此是操作系统必须执行的大部分操作的基础。

操作系统还必须不间断运行；当它发生故障时，系统上运行的所有应用程序也会发生故障。由于这种依赖性，操作系统通常努力提供高度的可靠性。

其他目标也很有意义：能源效率很重要；针对恶意应用程序的安全性（实际上是保护的延伸）至关重要，尤其是在这个高度网络化的时代；随着操作系统在越来越小的设备上运行，移动性变得越来越重要。根据系统的使用方式，操作系统将具有不同的目标，因此可能以至少略有不同的方式实现。但是，正如我们将看到的，我们将介绍的关于如何构建操作系统的许多原则在各种不同的设备上都很有用。

## 2.6 历史
### 早年OS：只是库
基本上，它只是一组常用函数库；例如，系统的每个程序员不必编写低级 I/O 处理代码，而是由“操作系统”提供此类 API，从而使开发人员的工作变得更轻松。

通常，在这些旧的大型机系统上，一次只运行一个程序，由人工操作员控制。您认为现代操作系统会做的大部分工作（例如，决定以什么顺序运行作业）都是由这个操作员执行的。如果您是一位聪明的开发人员，您会对这个操作员很友好，这样他们可能会将您的作业移到队列的最前面。

这种计算模式被称为批处理，因为操作员设置了许多作业，然后以“批处理”方式运行。从那时开始，由于成本原因，计算机还没有以交互方式使用：让用户坐在计算机前使用它实在是太昂贵了，因为大多数时候计算机都处于闲置状态，每小时要花费设施数十万美元。

### 超越库：保护机制
操作系统不再只是一个简单的常用服务库，而是在管理机器方面发挥了更重要的作用。这其中的一个重要方面是认识到代表操作系统运行的代码是特殊的；它控制着设备，因此应该与普通应用程序代码区别对待。为什么会这样？好吧，想象一下，如果你允许任何应用程序从磁盘上的任何位置读取；隐私的概念就不复存在了，因为任何程序都可以读取任何文件。因此，将文件系统（用于管理文件）实现为库是没有意义的。相反，需要其他东西。

因此，系统调用的概念应运而生，由 Atlas计算系统率先提出。这里的想法不是将操作系统例程作为库提供（您只需进行过程调用即可访问它们），而是添加一对特殊的硬件指令和硬件状态，以使进入操作系统的转换成为一个更正式、更受控的过程。

系统调用和过程调用之间的主要区别在于，系统调用将控制权（即跳转）转移到操作系统，同时提升硬件特权级别。用户应用程序在所谓的用户模式下运行，这意味着硬件限制了应用程序可以执行的操作；例如，在用户模式下运行的应用程序通常无法向磁盘发起 I/O 请求、访问任何物理内存页面或在网络上发送数据包。当启动系统调用时（通常通过称为陷阱的特殊硬件指令），硬件会将控制权转移到预先指定的陷阱处理程序（操作系统先前设置），同时将特权级别提升到内核模式。在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行诸如发起 I/O 请求或为程序提供更多内存之类的操作。当操作系统完成对请求的服务后，它会通过一个特殊的“从陷阱返回”指令将控制权交还给用户，该指令会恢复到用户模式，同时将控制权交还到应用程序停止的位置。

### 多道程序设计时代
操作系统真正腾飞的时代是在大型机之外的计算时代，即小型计算机时代。像 Digital Equipment 的 PDP 系列这样的经典机器使计算机的价格大大降低；因此，现在组织内一小部分人可以拥有自己的计算机，而不是每个大型组织都拥有一台大型机。毫不奇怪，成本下降的主要影响之一是开发人员活动的增加；更多聪明的人开始使用计算机，从而使计算机系统能够做更多有趣和美妙的事情。

尤其是，由于人们希望更好地利用机器资源，多道程序设计变得很普遍。操作系统不再一次只运行一个作业，而是将多个作业加载到内存中并在它们之间快速切换，从而提高 CPU 利用率。这种切换尤其重要，因为 I/O 设备速度很慢；让程序在 CPU 上等待其 I/O 得到服务会浪费 CPU 时间。相反，为什么不切换到另一个作业并运行一段时间呢？

支持多道程序设计和在 I/O 和中断存在的情况下实现重叠的愿望迫使操作系统在多个方向上进行概念开发创新。诸如内存保护之类的问题变得很重要；我们不希望一个程序能够访问另一个程序的内存。了解如何处理由多道程序设计引入的并发问题也至关重要；确保操作系统在存在中断的情况下正常运行是一项巨大的挑战。我们将在本书后面研究这些问题和相关主题。

当时最重大的实际进步之一是 UNIX 操作系统的推出，这主要归功于贝尔实验室（没错，就是电话公司）的 Ken Thompson（和 Dennis Ritchie）。UNIX 从不同的操作系统（特别是 Multics，以及 TENEX 和 Berkeley 分时系统等系统）中汲取了许多好的想法，但使它们更简单、更易于使用。很快，这个团队就将包含 UNIX 源代码的磁带发给了世界各地的人们，其中许多人随后参与其中并亲自为系统添加了代码；有关更多详细信息，请参阅旁注。

#### 旁注：UNIX的重要性
UNIX 在操作系统历史上的重要性怎么强调都不为过。受早期系统（尤其是 MIT 著名的 Multics 系统）的影响，UNIX 汇集了许多伟大的思想，并打造了一个既简单又强大的系统。

最初的“贝尔实验室” UNIX 的底层是构建小型、功能强大的程序，这些程序可以连接在一起形成更大的工作流程。shell（您在其中输入命令）提供了pipes等原语来实现这种元级编程，因此将程序串联起来完成更大的任务变得很容易。例如，要查找文本文件中包含单词“foo”的行，然后计算有多少这样的行，您可以输入：grep foo file.txt|wc -l，从而使用 grep 和 wc（字数统计）程序来完成您的任务。

UNIX 环境对程序员和开发人员都很友好，还为新的 C 编程语言提供了编译器。
程序员可以轻松编写自己的程序并共享它们，这使得 UNIX 非常受欢迎。作者免费向任何需要的人提供副本，这可能是很大的帮助，这是早期的开源软件形式。

代码的可访问性和可读性也至关重要。用 C 语言编写的精美小内核可以吸引其他人使用内核，添加新的酷炫功能。例如，伯克利的一个富有进取心的小组在 Bill Joy 的领导下制作了一个很棒的发行版（伯克利系统发行版，简称 BSD），它有一些先进的虚拟内存、文件系统和网络子系统。Joy 后来与他人共同创立了 Sun Microsystems。

不幸的是，由于各公司试图宣称拥有 UNIX 并从中获利，因此 UNIX 的传播速度有所减缓，这是律师介入的不幸（但很常见）结果。许多公司都有自己的变体：Sun Microsystems 的 SunOS、IBM 的 AIX、HP 的 HPUX（又名“H-Pucks”）和 SGI 的 IRIX。AT&T/贝尔实验室和其他参与者之间的法律纠纷给 UNIX 蒙上了一层阴影，许多人怀疑它是否能生存下来，尤其是在 Windows 推出并占领了大部分 PC 市场之后……

#### 旁注，LINUX的到来
幸运的是，一位名叫 Linus Torvalds 的年轻芬兰黑客决定编写自己的 UNIX 版本，该版本大量借鉴了原始系统背后的原理和思想，但没有借鉴代码库，从而避免了合法性问题。他从世界各地的许多人那里获得了帮助，利用了已经存在的复杂 GNU 工具，很快 Linux 就诞生了（以及现代开源软件运动）。

随着互联网时代的到来，大多数公司（如谷歌、亚马逊、Facebook 等）选择运行 Linux，因为它是免费的，而且可以根据自己的需求随时进行修改；事实上，如果没有这样的系统，很难想象这些新公司会取得成功。随着智能手机成为面向用户的主导平台，出于许多相同的原因，Linux 也在那里找到了据点（通过 Android）。史蒂夫·乔布斯将他基于 UNIX 的 NeXTStep 操作环境带到了苹果公司，从而使 UNIX 在桌面上流行起来（尽管许多苹果技术用户可能甚至没有意识到这一事实）。因此，UNIX 继续存在，今天比以往任何时候都更重要。如果你相信计算之神，就应该感谢他们带来这一美妙的结果。

### 现代
除了小型计算机之外，还出现了一种新型机器，它更便宜、更快速，而且适合大众：个人计算机，也就是我们今天所说的 PC。在 Apple 早期机器（例如 Apple II）和 IBM PC 的引领下，这种新型机器很快成为计算领域的主导力量，因为它们的低成本使每台桌面只有一台机器，而不是每个工作组共享一台小型计算机。

不幸的是，对于操作系统而言，PC 最初代表着一次巨大的倒退，因为早期的系统忘记了（或从未了解过）小型计算机时代所学到的教训。例如，早期的操作系统，如 DOS（微软的磁盘操作系统）并不认为内存保护很重要；因此，恶意（或可能只是编程不当）的应用程序可能会在内存上乱涂乱画。第一代 Mac OS（v9 及更早版本）采用协作方式进行作业调度；因此，意外陷入无限循环的线程可能会接管整个系统，从而强制重新启动。这一代系统缺少的操作系统功能列表很长，无法在此进行全面讨论。

幸运的是，经过几年的磨难，小型计算机操作系统的旧功能开始在桌面上找到出路。例如，Mac OS X/macOS 的核心是 UNIX，包括人们期望从这样一个成熟的系统中获得的所有功能。Windows 也同样采纳了计算历史上的许多伟大创意，特别是从 Windows NT 开始，这是微软操作系统技术的一大飞跃。即使是今天的手机运行的操作系统（如 Linux），也更像 20 世纪 70 年代的小型计算机运行的操作系统，而不是 20 世纪 80 年代的 PC 运行的操作系统（谢天谢地）；很高兴看到在操作系统开发鼎盛时期开发的好想法已经进入了现代世界。更棒的是，这些想法还在不断发展，提供更多功能，使现代系统对用户和应用程序来说更加出色。


## 2.7 总结
因此，我们对操作系统进行了介绍。当今的操作系统使系统相对易于使用，并且您今天使用的几乎所有操作系统都受到我们将在整本书中讨论的发展的影响。

不幸的是，由于时间限制，本书不会介绍操作系统的许多部分。例如，操作系统中有很多网络代码；我们留给您参加网络课程来了解更多相关信息。同样，图形设备也特别重要；参加图形课程以扩展您在这方面的知识。最后，一些操作系统书籍大量谈论安全性；我们将这样做，因为操作系统必须在运行程序之间提供保护，并让用户能够保护他们的文件，但我们不会深入探讨安全课程中可能发现的更深层次的安全问题。

但是，我们将介绍许多重要主题，包括 CPU 和内存虚拟化的基础知识、并发性以及通过设备和文件系统的持久性。别担心！虽然还有很多内容需要讲解，但大部分内容都很酷，在学习完这些内容后，你会对计算机系统的实际工作方式有全新的认识。
