我们现在知道，要解决大量相关且有趣的并发问题，锁和条件变量必不可少。多年前最早意识到这一点的人之一是 Edsger Dijkstra，他因图论中著名的“最短路径”算法、一篇题为“Goto 语句被认为有害”的早期结构化编程论战，以及我们将在这里研究的案例中引入了一种称为信号量的同步原语而闻名。事实上，Dijkstra 和同事发明了信号量作为与同步相关的所有事物的单一原语；正如您将看到的，人们可以将信号量用作锁和条件变量。

## 关键：如何使用信号量
- 我们如何使用信号量来代替锁和条件变量？
- 信号量的定义是什么？什么是二进制信号量？
- 用锁和条件变量构建信号量是否简单？用信号量构建锁和条件变量是否简单？

# 31.1 信号量：定义
信号量是一个具有整数值的对象，我们可以使用两个例程来操作它；在 POSIX 标准中，这两个例程是 sem_wait() 和 sem_post()。由于信号量的初始值决定了它的行为，因此在调用任何其他例程与信号量交互之前，我们必须首先将其初始化为某个值，如图 31.1 中的代码所示。
![[Pasted image 20241028152206.png]]
在图中，我们声明一个信号量 s，并通过将 1 作为第三个参数传入，将其初始化为值 1。在我们将看到的所有示例中，sem_init() 的第二个参数都将设置为 0；这表明信号量在同一进程中的线程之间共享。有关信号量的其他用法的详细信息（即如何使用它们来同步不同进程之间的访问），请参阅手册页，这些用法需要第二个参数的不同值。

初始化信号量后，我们可以调用两个函数之一来与其交互，sem_wait() 或 sem_post()。这两个函数的行为如图 31.2 所示。
![[Pasted image 20241028152526.png]]

目前，我们不关心这些例程的实现，这显然需要一些注意；由于多个线程调用 sem_wait() 和 sem_post()，显然需要管理这些关键部分。我们现在将重点介绍如何使用这些原语；

稍后我们可能会讨论它们是如何构建的。我们应该在这里讨论接口的一些显著方面。首先，我们可以看到 sem_wait() 要么立即返回（因为当我们调用 sem_wait() 时信号量的值为 1 或更高），要么它会导致调用者暂停执行以等待后续发布。

当然，多个调用线程可能会调用 sem_wait()，因此所有线程都会排队等待被唤醒。其次，我们可以看到 sem_post() 不会像 sem_wait() 那样等待某些特定条件成立。相反，它只是增加信号量的值，然后，如果有线程等待被唤醒，则唤醒其中一个。

第三，当信号量的值为负时，等于等待线程的数量。虽然信号量的用户通常看不到这个值，但这个不变量值得了解，也许可以帮助您记住信号量的工作原理。

暂时不要担心信号量中可能出现的竞争条件；假设它们所做的操作是原子执行的。我们很快将使用锁和条件变量来实现这一点。

# 31.2 Binary Semaphores (Locks)
现在我们可以使用信号量了。我们第一次使用的信号量是我们已经熟悉的：将信号量用作锁。请参见图 31.3 中的代码片段；在其中，您会看到我们只是用 sem wait()/sem post() 对包围了感兴趣的关键部分。但是，要使这项工作成功，信号量 m 的初始值（在图中初始化为 X）至关重要。X 应该是什么？

![[Pasted image 20241028152930.png]]
回顾上面 sem wait() 和 sem post() 例程的定义，我们可以看到初始值应该是 1。

为了更清楚地说明这一点，让我们想象一个有两个线程的场景。第一个线程（线程 0）调用 sem wait()；它首先会减少信号量的值，将其更改为 0。然后，只有当值小于 0 时，它才会等待。由于值为 0，sem wait() 将简单地返回，调用线程将继续；线程 0 现在可以自由进入临界区。如果在线程 0 处于临界区内时没有其他线程尝试获取锁，则当它调用 sem post() 时，它将简单地将信号量的值恢复为 1（并且不会唤醒等待线程，因为没有线程）。图 31.4 显示了此场景的轨迹。

![[Pasted image 20241028153255.png]]
当线程 0“持有锁”（即，它已调用 sem wait() 但尚未调用 sem post()）时，会出现一个更有趣的情况，另一个线程（线程 1）试图通过调用 sem wait() 进入临界区。在这种情况下，线程 1 将信号量的值减少为 -1，从而等待（使自己进入睡眠状态并放弃处理器）。当线程 0 再次运行时，它最终将调用 sem post()，将信号量的值增加回零，然后唤醒等待线程（线程 1），然后该线程将能够为自己获取锁。当线程 1 完成时，它将再次增加信号量的值，将其再次恢复为 1。

![[Pasted image 20241028153339.png]]

图 31.5 显示了此示例的轨迹。除了线程操作之外，该图还显示了每个线程的调度程序状态：运行（线程正在运行）、就绪（即可运行但未运行）和休眠（线程被阻止）。请注意，当线程 1 尝试获取已持有的锁时，它会进入休眠状态；只有当线程 0 再次运行时，线程 1 才能被唤醒并可能再次运行。

如果您想通过自己的示例进行操作，请尝试以下场景：多个线程排队等待锁定。在这样的跟踪过程中，信号量的值会是多少？因此，我们能够将信号量用作锁定。由于锁定只有两种状态（保持和不保持），因此我们有时将用作锁定的信号量称为二进制信号量。请注意，如果您仅以这种二进制方式使用信号量，则可以采用比我们在此处介绍的通用信号量更简单的方式实现它。

# 31.3 Semaphores For Ordering
信号量还可用于对并发程序中的事件进行排序。例如，一个线程可能希望等待列表变为非空，以便它可以从中删除一个元素。在这种使用模式中，我们经常发现一个线程在等待某事发生，而另一个线程使某事发生，然后发出信号表示已经发生，从而唤醒等待的线程。因此，我们将信号量用作排序原语（类似于我们之前对条件变量的使用）。

下面是一个简单的例子。假设一个线程创建了另一个线程，然后想要等待它完成执行（图 31.6）。当这个程序运行时，我们希望看到以下内容：
![[Pasted image 20241028153606.png]]
![[Pasted image 20241028153628.png]]
那么，问题是如何使用信号量来实现这种效果；事实证明，答案相对容易理解。正如您在代码中看到的，父进程只需调用 sem wait() 和子进程 sem post() 即可等待子进程完成执行的条件变为真。然而，这提出了一个问题：这个信号量的初始值应该是多少？

答案当然是信号量的值应该设置为 0。有两种情况需要考虑。首先，让我们假设父进程创建了子进程，但子进程尚未运行（即，它位于就绪队列中但未运行）。在这种情况下，父进程将在子进程调用 sem post() 之前调用 sem wait()；我们希望父进程等待子进程运行。发生这种情况的唯一方法是信号量的值不大于 0；因此，0 是初始值。父进程运行，将信号量减少（至 -1），然后等待（休眠）。
当子进程最终运行时，它将调用 sem post()，将信号量的值增加到 0，并唤醒父进程，然后父进程将从 sem wait() 返回并完成程序。

第二种情况发生在子进程运行完成之前，父进程还没有机会调用 sem wait()。在这种情况下，子进程将首先调用 sem post()，从而将信号量的值从 0 增加到 1。当父进程有机会运行时，它将调用 sem wait() 并发现信号量的值为 1；因此，父级将减少该值（至 0）并从 sem wait() 返回而无需等待，从而达到预期的效果。

# 31.4 The Producer/Consumer (Bounded Buffer) Problem
本章中我们将要面对的下一个问题称为生产者/消费者问题，有时也称为有界缓冲区问题。
## First Attempt
我们第一次尝试解决这个问题时引入了两个信号量，empty 和 full，线程将分别使用它们来指示缓冲区条目何时被清空或填满。put 和 get 例程的代码如图 31.9 所示，我们尝试解决生产者和消费者问题的代码如图 31.10 所示。
![[Pasted image 20241028154025.png]]

![[Pasted image 20241028154041.png]]
在这个例子中，生产者首先等待缓冲区变空，以便将数据放入其中，而消费者同样等待缓冲区变满，然后再使用它。让我们首先假设 MAX=1（数组中只有一个缓冲区），看看这是否有效。

再想象有两个线程，一个生产者和一个消费者。让我们在单个 CPU 上检查一个特定的场景。假设消费者首先运行。因此，消费者将到达图 31.10 中的 C1 行，调用 sem wait(&full)。因为 full 被初始化为值 0，该调用将减少 full（至 -1），阻塞消费者，并等待另一个线程在 full 上调用 sem post()，如所期望的那样。
假设生产者随后运行。它将命中 P1 行，从而调用sem wait(&empty) 例程。与消费者不同，生产者将继续执行此行，因为 empty 被初始化为值MAX（在本例中为 1）。因此，empty 将减少为 0，生产者将数据值放入缓冲区的第一个条目（P2 行）。然后，生产者将继续执行 P3 并调用 sem post(&full)，将 full 信号量的值从 -1 更改为 0 并唤醒消费者（例如，将其从阻塞状态移至就绪状态）。

在这种情况下，可能会发生以下两种情况之一。如果生产者继续运行，它将循环并再次命中 P1 行。然而，这一次它会阻塞，因为空信号量的值为 0。如果生产者被中断，而消费者开始运行，它会从 sem wait(&full)（C1 行）返回，发现缓冲区已满，并使用它。无论哪种情况，我们都实现了所需的行为。您可以尝试使用更多线程（例如，多个生产者和多个消费者）执行相同示例。它应该仍然有效。

现在让我们假设 MAX 大于 1（假设 MAX=10）。对于此示例，让我们假设有多个生产者和多个消费者。现在我们遇到了一个问题：竞争条件。您看到它发生在哪里了吗？（花点时间寻找它）如果您看不到它，这里有一个提示：仔细查看 put() 和 get() 代码。好的，让我们了解这个问题。想象两个生产者（Pa 和 Pb）都大致同时调用 put()。假设生产者 Pa 首先运行，并开始填充第一个缓冲区条目（在 F1 行处 fill=0）。在 Pa 有机会将填充计数器增加到 1 之前，它被中断了。生产者 Pb 开始运行，在 F1 行它还将其数据放入缓冲区的第 0 个元素中，这意味着那里的旧数据被覆盖了！这个动作是不行的；我们不希望生产者的任何数据丢失。

## A Solution: Adding Mutual Exclusion
如您所见，我们在这里忘记了互斥。填充缓冲区和将索引递增到缓冲区是关键部分，因此必须小心保护。所以让我们使用我们的朋友二进制信号量并添加一些锁。图 31.11 显示了我们的尝试。

![[Pasted image 20241028155354.png]]

现在，我们已经在代码的整个 put()/get() 部分周围添加了一些锁，如 NEW LINE 注释所示。这似乎是正确的想法，但它也行不通。为什么？死锁。为什么会发生死锁？花点时间考虑一下；试着找出发生死锁的情况。程序死锁必须发生哪些步骤顺序？

## 避免死锁
好的，既然您已经搞清楚了，下面就是答案。想象两个线程，一个生产者，一个消费者。消费者首先运行。它获取互斥锁（行 C0），然后在已满信号量（行 C1）上调用 sem wait()；由于还没有数据，此调用会导致消费者阻塞，从而让出 CPU；但重要的是，消费者仍然持有锁。

然后生产者运行。它有数据要生产，如果它能够运行，它就能够唤醒消费者线程，一切都会好起来。不幸的是，它做的第一件事就是在二进制互斥信号量（行 P0）上调用 sem wait()。锁已经被持有。因此，生产者现在也陷入了等待状态。

这里有一个简单的循环。消费者持有互斥锁，正在等待某人发出已满信号。生产者可以发出已满信号，但正在等待互斥锁。因此，生产者和消费者都陷入了等待对方的状态：典型的死锁。

## At Last, A Working Solution
为了解决这个问题，我们只需缩小锁的范围。图 31.12（第 10 页）显示了正确的解决方案。如您所见，我们只需将互斥锁的获取和释放移动到临界区附近；满的和空的等待和信号代码留在外面2。结果是一个简单而有效的有界缓冲区，这是多线程程序中常用的模式。现在理解它；以后使用它。你会在未来几年感谢我们。或者至少，当期末考试或求职面试中问到同样的问题时，你会感谢我们。

![[Pasted image 20241028155720.png]]

# 31.5 Reader-Writer Locks
另一个经典问题源于对更灵活的锁定原语的需求，该原语承认不同的数据结构访问可能需要不同类型的锁定。例如，想象许多并发列表操作，包括插入和简单查找。虽然插入会改变列表的状态（因此传统的临界区是有意义的），但查找只是读取数据结构；只要我们能够保证没有插入正在进行，我们就可以允许许多查找同时进行。我们现在将开发一种支持此类操作的特殊类型的锁，称为读写锁。这种锁的代码如图 31.13所示。
![[Pasted image 20241028155852.png]]
代码非常简单。如果某个线程想要更​​新相关的数据结构，它应该调用新的一对同步操作：rwlock_acquire_writelock()，以获取写锁，以及 rwlock_release_writelock()，以释放它。在内部，这些只是使用 writelock 信号量来确保只有一个写入器可以获取锁，从而进入临界区来更新相关数据结构。
更有趣的是获取和释放读锁的一对例程。获取读锁时，读取器首先获取锁，然后增加 reader 变量以跟踪数据结构中当前有多少读取器。然后在 rwlock_acquire_readlock() 中采取的重要步骤发生在第一个读取器获取锁时；在这种情况下，读取器还通过在 writelock 信号量上调用 sem_wait() 来获取写锁，然后通过调用 sem_post() 释放锁。

因此，一旦读取器获得了读锁，将允许更多读取器也获取读锁；但是，任何希望获取写锁的线程都必须等到所有读取器完成；最后一个退出临界区的线程在“writelock”上调用 sem_post()，从而使等待的写入器能够获取锁。

这种方法可行（如预期），但确实有一些缺点，尤其是在公平性方面。特别是，读者很容易让写者挨饿。这个问题有更复杂的解决方案；也许你能想到更好的实现？提示：想想你需要做什么来防止写者在等待时进入锁。

最后，需要注意的是，使用读写锁时应谨慎一些。它们通常会增加更多开销（尤其是在更复杂的实现中），因此与仅使用简单快速的锁定原语相比，最终不会提高性能。无论哪种方式，它们再次展示了我们如何以一种有趣且有用的方式使用信号量


## 提示：简单而愚蠢可能更好（希尔定律）

您永远不应低估简单而愚蠢的方法可能是最佳方法这一概念。对于锁定，有时简单的自旋锁效果最好，因为它易于实现且速度快。虽然像读/写锁这样的东西听起来很酷，但它们很复杂，而复杂可能意味着速度慢。因此，总是先尝试简单而愚蠢的方法。

这种诉诸简单的想法在很多地方都有发现。一个早期来源是 Mark Hill 的论文 ，该论文研究了如何为 CPU 设计缓存。Hill 发现简单的直接映射缓存比花哨的组相联设计效果更好（原因之一是在缓存中，更简单的设计可以实现更快的查找）。正如 Hill 简洁地总结他的工作：“大而愚蠢更好。”因此我们将这种类似的建议称为希尔定律。

# 31.6 The Dining Philosophers
Dijkstra 提出并解决的最有名的并发问题之一是哲学家就餐问题。这个问题之所以出名，是因为它很有趣，而且在智力上也很有趣；然而，它的实际效用很低。然而，它的名气迫使它被纳入这里；事实上，你可能会在某次面试中被问到这个问题，如果你答错了这个问题而没有得到这份工作，你一定会非常讨厌你的操作系统教授。相反，如果你得到了这份工作，请随时给你的操作系统教授发一张漂亮的便条，或者一些股票期权。

这个问题的基本设置是这样的（如图 31.14 所示）：假设有五个“哲学家”围坐在一张桌子旁。每对哲学家之间都有一个叉子（因此总共有五个）。哲学家们都有思考的时间，不需要任何叉子，也有吃饭的时间。为了吃饭，哲学家需要两把叉子，左边的一把，右边的一把。这些叉子的争用以及随之而来的同步问题，使得这个问题成为我们在并发编程中研究的问题。

以下是每个哲学家的基本循环，假设每个哲学家都有一个唯一的线程标识符 p，范围从 0 到 4（含）：

![[Pasted image 20241028202654.png]]

![[Pasted image 20241028202532.png]]

那么，关键的挑战是编写例程 get forks() 和 put forks()，使得没有死锁，没有哲学家挨饿，并且永远吃不到东西，并且并发性很高（即尽可能多的哲学家可以
同时吃饭）。

按照 Downey 的解决方案，我们将使用一些辅助函数来找到解决方案。它们是：
![[Pasted image 20241028202739.png]]
当哲学家 p 希望引用他们左边的叉子时，他们只需调用 left(p)。类似地，哲学家 p 右边的叉子通过调用 right(p) 来引用；其中的模运算符处理最后一位哲学家 (p=4) 试图抓住他们右边的叉子（即叉子 0）的情况。

我们还需要一些信号量来解决这个问题。假设我们有五个信号量，每个叉子一个：sem t forks。

## Broken Solution
我们尝试对问题进行第一次求解。假设我们将每个信号量（在 forks 数组中）初始化为值 1。还假设每个哲学家都知道自己的编号 (p)。因此，我们可以编写 get forks() 和 put forks() 例程（图 31.15）。

![[Pasted image 20241028202904.png]]

这种（不完善的）解决方案背后的直觉如下。要获得叉子，我们只需抓住每个叉子的“锁”：首先是左边的，然后是右边的。吃完饭后，我们释放它们。很简单，不是吗？不幸的是，在这种情况下，简单意味着不完善。你能看出出现的问题吗？想一想。问题是死锁。如果每个哲学家碰巧在任何哲学家抓住右边的叉子之前抓住左边的叉子，那么每个人都将永远只能拿着一个叉子等待另一个。具体来说，哲学家 0 抓住叉子 0，哲学家 1 抓住叉子 1，哲学家 2 抓住叉子 2，哲学家 3 抓住叉子 3，哲学家 4 抓住叉子 4；所有叉子都已获得，所有哲学家都陷入等待另一位哲学家拥有的叉子的境地。我们很快会更详细地研究死锁；目前，可以肯定地说，这不是一个可行的解决方案。

## A Solution: Breaking The Dependency
解决这个问题的最简单方法是改变至少一位哲学家获取餐叉的方式；事实上，这就是 Dijkstra 自己解决这个问题的方法。具体来说，我们假设哲学家 4（编号最高的哲学家）获取餐叉的顺序与其他人不同（图 31.16）；put forks() 代码保持不变。

因为最后一位哲学家试图先拿右边的，再拿左边的，所以不会出现每个哲学家都拿了一把餐叉，然后又要等待另一把的情况；等待的循环被打破了。仔细考虑一下这个解决方案的后果，并说服自己它是有效的。还有其他“著名”的问题与此类似，例如吸烟者问题或睡觉的理发师问题。它们中的大多数只是思考并发的借口；其中一些有着迷人的名字。

# 31.7 Thread Throttling
信号量的另一个简单用例偶尔会出现，因此我们在此介绍它。具体问题是：程序员如何防止“太多”线程同时执行某项操作并导致系统瘫痪？答案：确定“太多”的阈值，然后使用信号量来限制同时执行相关代码的线程数。我们将这种方法称为节流，并将其视为一种准入控制形式。

让我们考虑一个更具体的例子。假设您创建了数百个线程来并行处理某个问题。但是，在代码的某个部分，每个线程都需要大量内存来执行部分计算；我们将这部分代码称为内存密集型区域。如果所有线程同时进入内存密集型区域，则所有内存分配请求的总和将超过机器上的物理内存量。因此，机器将开始抖动（即，将页面交换到磁盘和从磁盘交换），整个计算将变得非常缓慢。

一个简单的信号量可以解决这个问题。通过将信号量的值初始化为您希望一次进入内存密集型区域的最大线程数，然后在该区域周围放置 sem wait()
和 sem post()，信号量可以自然地限制代码危险区域中同时存在的线程数。

# 31.8 How To Implement Semaphores
最后，让我们使用低级同步原语、锁和条件变量，来构建我们自己的信号量版本，称为Zemaphores。这个任务相当简单，如图 31.17所示。

![[Pasted image 20241028203525.png]]

在上面的代码中，我们只使用一个锁和一个条件变量，加上一个状态变量来跟踪信号量的值。自己研究代码，直到你真正理解它。动手吧！

25行signal是一个全局signal，唤醒所有broadcast signal

我们的 Zemaphore 和 Dijkstra 定义的纯信号量之间的一个细微差别是，我们不维护信号量的值为负时反映等待线程数；事实上，该值永远不会低于零。这种行为更容易实现，并且与当前的 Linux 实现相匹配。

奇怪的是，用信号量构建条件变量是一个更棘手的命题。一些经验丰富的并发程序员试图在 Windows 环境中这样做，结果出现了许多不同的错误。自己尝试一下，看看你是否能弄清楚为什么用信号量构建条件变量比表面上看起来更具挑战性。

# 31.9 总结
信号量是编写并发程序的强大而灵活的原语。由于信号量简单实用，一些程序员专门使用它们，而避开锁和条件变量。

## 提示：谨慎进行泛化
因此，泛化的抽象技术在系统设计中非常有用，一个好主意可以稍微扩大一点，从而解决更大范围的问题。但是，泛化时要小心；正如 Lampson 警告我们的那样，“不要泛化；泛化通常是错误的” 。

人们可以将信号量视为锁和条件变量的泛化；但是，这样的泛化有必要吗？而且，考虑到在信号量之上实现条件变量的难度，也许这种泛化并不像您想象的那么普遍。

