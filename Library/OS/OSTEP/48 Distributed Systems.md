The major one we focus on is failure.
# The Crux:
How to build systems that work when components fall? How can we build a working system out of parts that don't work correctly all the time?

**System performance** is often critical; with a network connecting our distributed system together, system designers must often think carefully about how to accomplish their given tasks, trying to reduce the number of messages sent and further make communication as efficient (low latency, high bandwidth) as possible.

**Security** is also important.

In this introduction, we'll cover the most basic aspect that is new in a distributed system: **communication**. Namely, how should machines within a distributed system communicate with one another? We'll start with the most basic primitives available, messages, and build a few higher-level primitives on top of them. As we said above, failure will be a central focus: how should communication layers handle failures?

# 48.1 Communication Basics
通信不可靠，经常会有丢包。

然而，更根本的是由于网络交换机、路由器或端点内缺乏缓冲而导致的数据包丢失。具体来说，即使我们可以保证所有链路正常工作，并且系统中的所有组件（交换机、路由器、终端主机）都按预期启动和运行，仍然可能出现丢失，原因如下。假设一个数据包到达路由器；要处理该数据包，必须将其放在路由器内存中的某个位置。如果许多这样的数据包同时到达，路由器内的内存可能无法容纳所有数据包。路由器此时唯一的选择是丢弃一个或多个数据包。同样的行为也会发生在终端主机上；当您向一台机器发送大量消息时，该机器的资源很容易不堪重负，因此再次出现数据包丢失。

Thus, packet loss is fundamental in networking. The question thus becomes: how should we deal with it?

# 48.2 Unreliable Communication Layers
One simple way is this: we don't deal with it. 因为有些应用程序知道如何处理数据包丢失，所以有时让它们与基本的不可靠消息层进行通信很有用，这是人们经常听到的端到端论点的一个示例（请参阅本章末尾的旁注）。这种不可靠层的一个很好的例子是当今几乎所有现代系统上都可用的 UDP/IP 网络堆栈。要使用 UDP，进程使用套接字 API 来创建通信端点；其他机器（或同一台机器）上的进程将 UDP 数据报发送到原始进程（数据报是固定大小的消息，最大大小为某个值）。

图 48.1 和 48.2 显示了基于 UDP/IP 构建的简单客户端和服务器。客户端可以向服务器发送消息，然后服务器回复。有了这个少量的代码，您就拥有了开始构建分布式系统所需的一切！

UDP 是不可靠通信层的一个很好的例子。如果您使用它，您将遇到数据包丢失（丢弃）并因此无法到达目的地的情况；发送方永远不会被告知丢失。但是，这并不意味着 UDP 根本无法防范任何故障。例如，UDP 包含一个校验和来检测某些形式的数据包损坏。

但是，由于许多应用程序只是想将数据发送到目的地而不担心数据包丢失，因此我们需要更多。具体来说，我们需要在不可靠的网络上进行可靠的通信。

# 48.3 Reliable Communication Layers
为了构建可靠的通信层，我们需要一些新的机制和技术来处理数据包丢失。让我们考虑一个简单的示例，其中客户端通过不可靠的连接向服务器发送消息。我们必须回答的第一个问题是：发送者如何知道接收者确实收到了消息？

The technique is **acknowledgment**, or **ack** for short. The idea is simple: the sender sends a message to the receiver; the receiver then sends a short message back to acknowledge its receipt. 
![[Pasted image 20241209153554.png]]
When the sender receives an acknowledgment of the message, it can then rest assured that the receiver did indeed receive the original message. However, what should the sender do if it does not receive an acknowledgment?

为了处理这种情况，我们需要一种额外的机制，称为超时。当发送者发送消息时，发送者现在设置一个计时器，在一段时间后关闭。如果在这段时间内没有收到确认，发送者就会断定消息已丢失。然后，发送者只需重试发送，再次发送相同的消息，希望这次能够成功。为了使这种方法奏效，发送者必须保留消息的副本，以防需要再次发送。超时和重试的结合导致一些人将这种方法称为超时/重试；那些网络类型的人真是聪明，不是吗？图 48.4 显示了一个例子。
![[Pasted image 20241209153915.png]]

不幸的是，这种形式的超时/重试还不够。图 48.5 显示了可能导致麻烦的数据包丢失示例。在此示例中，丢失的不是原始消息，而是确认。从发送方的角度来看，情况似乎相同：没有收到确认，因此需要超时和重试。但从接收方的角度来看，情况完全不同：现在同一条消息被收到了两次！虽然在某些情况下这是可以接受的，但一般来说并非如此；想象一下，当您下载文件时，如果下载过程中重复了额外的数据包，会发生什么。因此，当我们瞄准可靠的消息层时，我们通常还希望保证接收方只收到每条消息一次。
![[Pasted image 20241209154005.png]]

为了使接收方能够检测到重复的消息传输，发送方必须以某种独特的方式识别每条消息，而接收方需要某种方式来跟踪它是否已经看到过每条消息。当接收方看到重复传输时，它只会确认该消息，但（关键的是）不会将消息传递给接收数据的应用程序。因此，发送方会收到确认，但不会两次接收消息，从而保留上面提到的恰好一次语义。

检测重复消息的方法有很多种。例如，发送者可以为每条消息生成一个唯一的 ID；接收者可以跟踪它见过的每个 ID。这种方法可能有效，但成本过高，需要无限的内存来跟踪所有 ID。

一种更简单的方法解决了这个问题，只需要很少的内存，这种机制被称为序列计数器。使用序列计数器，发送方和接收方就双方将维护的计数器的起始值（例如 1）达成一致。每当发送一条消息时，计数器的当前值都会随消息一起发送；这个计数器值（N）用作消息的 ID。发送消息后，发送方会将值递增（至 N + 1）。

接收方使用其计数器值作为来自该发送方的传入消息 ID 的预期值。如果收到的消息的 ID (N) 与接收方的计数器（也是 N）匹配，它会确认该消息并将其传递给应用程序；在这种情况下，接收方会得出结论，这是第一次收到此消息。然后，接收方增加其计数器（至 N + 1），并等待下一条消息。

如果确认丢失，发送方将超时并重新发送消息 N。这一次，接收方的计数器更高（N + 1），因此接收方知道它已经收到了此消息。因此，它会确认该消息，但不会将其传递给应用程序。以这种简单的方式，可以使用序列计数器来避免重复。

最常用的可靠通信层称为 TCP/IP，或简称为 TCP。TCP 比我们上面描述的要复杂得多，包括处理网络拥塞的机制、多个未完成的请求以及数百个其他小调整和优化。

# 48.4 Communications Abstractions
多年来，系统社区开发了许多方法。其中一项工作采用了操作系统抽象并将其扩展为在分布式环境中运行。例如，分布式共享内存 (DSM) 系统使不同机器上的进程能够共享一个大型虚拟地址空间。这种抽象将分布式计算变成了看起来像多线程应用程序的东西；唯一的区别是这些线程在不同的机器上运行，而不是在同一台机器的不同处理器上运行。

大多数 DSM 系统的工作方式是通过操作系统的虚拟内存系统。当在一台机器上访问页面时，可能会发生两件事。在第一种（最佳）情况下，页面已经在机器上本地，因此可以快速获取数据。在第二种情况下，页面当前在另一台机器上。发生页面错误，页面错误处理程序向其他机器发送消息以获取页面，将其安装到请求进程的页表中，然后继续执行。

由于多种原因，这种方法目前并未得到广泛使用。DSM 最大的问题是如何处理故障。例如，想象一下，如果一台机器发生故障；该机器上的页面会发生什么？如果分布式计算的数据结构分布在整个地址空间中会怎样？在这种情况下，这些数据结构的某些部分会突然变得不可用。当部分地址空间丢失时，处理故障很困难；想象一下一个链接列表，其中的“下一个”指针指向已消失的地址空间部分。

另一个问题是性能。在编写代码时，人们通常认为访问内存很便宜。在 DSM 系统中，某些访问很便宜，但其他访问会导致页面错误和昂贵的远程机器提取。因此，此类 DSM 系统的程序员必须非常小心地组织计算，以至于几乎不发生任何通信，这在很大程度上违背了这种方法的初衷。尽管在这个领域进行了大量研究，但几乎没有实际影响；今天没有人使用 DSM 构建可靠的分布式系统。

# 48.5 Remote Procedure Call (RPC)
虽然事实证明 OS 抽象对于构建分布式系统来说并不是一个好选择，但编程语言 (PL) 抽象却更有意义。最主要的抽象基于远程过程调用（简称 RPC）的思想。

远程过程调用包都有一个简单的目标：使在远程机器上执行代码的过程像调用本地函数一样简单直接。因此，对于客户端，会进行过程调用，并在一段时间后返回结果。服务器只需定义一些它希望导出的例程。其余的魔法由 RPC 系统处理，它通常有两个部分：a stub generator (sometimes called a **protocol compiler**), and the **run-time library**.

## Stub Generator
存根生成器的工作很简单：通过自动化来消除将函数参数和结果打包到消息中的一些麻烦。这样做有很多好处：通过设计可以避免手工编写此类代码时出现的简单错误；此外，存根编译器也许可以优化此类代码，从而提高性能。

这种编译器的输入只是服务器希望导出到客户端的一组调用。从概念上讲，它可以是这样的简单的东西：
![[Pasted image 20241209154930.png]]
存根生成器采用这样的接口并生成一些不同的代码片段。对于客户端，会生成一个客户端存根，其中包含接口中指定的每个函数；希望使用此 RPC 服务的客户端程序将与此客户端存根链接并调用它以进行 RPC。

在内部，客户端存根中的每个函数都执行执行远程过程调用所需的所有工作。对于客户端，代码只是作为函数调用出现（例如，客户端调用 func1(x)）；在内部，客户端存根中 func1() 的代码执行以下操作：
- Create a message buffer. A message buffer is usually just a contiguous array of bytes of some size.
- Pack the needed information into the message buffer. 此信息包括要调用的函数的某种标识符，以及该函数所需的所有参数（例如，在上面的示例中，func1 的一个整数）。将所有这些信息放入单个连续缓冲区的过程有时称为参数的编组或消息的序列化 
- Send the message to the destination RPC server. 与 RPC 服务器的通信以及使其正常运行所需的所有细节均由 RPC 运行时库处理，如下所述。
- Wait for the reply. 由于函数调用通常是同步的，因此调用将等待其完成。
- Unpack return code and other arguments. 如果函数仅返回单个返回代码，则此过程很简单；但是，更复杂的函数可能会返回更复杂的结果（例如，列表），因此存根可能也需要解包这些结果。此步骤也称为解组或反序列化。
- Return to the caller. 最后，只需从客户端存根返回客户端代码即可。

For the server, code is also generated. The steps taken on the server are as follows:
- **Unpack the message**. This step, called unmarshaling or deserialization, takes the information out of the incoming message. The function identifier and arguments are extracted.
- **Call into the actual function.** 终于！我们已经到达远程函数实际执行的阶段。RPC 运行时调用 ID 指定的函数并传入所需的参数。
- Package the results. The return arguments are marshaled back into a single reply buffer.
- Send the reply. The reply is finally sent to the caller.

在存根编译器中，还有一些其他重要问题需要考虑。首先是复杂参数，即如何打包和发送复杂数据结构？例如，当调用 write()系统调用时，会传入三个参数：一个整数文件描述符、一个指向缓冲区的指针和一个大小，该大小指示要写入多少字节（从
指针开始）。如果 RPC 包传递了一个指针，它需要能够弄清楚如何解释该指针并执行
正确的操作。通常，这是通过众所周知的类型（e.g., a `buffer_t` that is used to pass chunks of data given a size, which the RPC compiler understands) 或通过使用更多信息注释数据结构来实现的，从而使编译器能够知道哪些字节需要序列化。

另一个重要问题是服务器在并发方面的组织。一个简单的服务器只是在一个简单的循环中等待请求，并一次处理一个请求。但是，正如您可能已经猜到的那样，这可能非常低效；如果一个 RPC 调用阻塞（例如，在 I/O 上），服务器资源就会被浪费。因此，大多数服务器都是以某种并发方式构建的。一种常见的组织是线程池。在这个组织中，服务器启动时会创建一组有限的线程；当消息到达时，它会被分派到其中一个工作线程，然后该线程执行 RPC 调用的工作，最终回复；在此期间，主线程不断接收其他请求，并可能将它们分派给其他工作线程。这样的组织允许在服务器内并发执行，从而提高其利用率；标准成本也随之增加，主要是编程复杂性，因为 RPC 调用现在可能需要使用锁和其他同步原语来确保其正确运行。

## Run-Time Library
运行时库处理 RPC 系统中的大部分繁重工作；大多数性能和可靠性问题都在这里处理。我们现在将讨论构建此类运行时层的一些主要挑战。

我们必须克服的首要挑战之一是如何定位远程服务。命名问题在分布式系统中很常见，从某种意义上说超出了我们当前讨论的范围。最简单的方法建立在现有命名系统的基础上，例如，当前互联网协议提供的主机名和端口号。在这样的系统中，客户端必须知道运行所需 RPC 服务的机器的主机名或 IP 地址，以及它正在使用的端口号（端口号只是一种识别机器上发生的特定通信活动的方式，允许同时使用多个通信通道）。然后，协议套件必须提供一种机制，将数据包从系统中的任何其他机器路由到特定地址。

一旦客户端知道了它应该与哪个服务器进行特定远程服务的通信，下一个问题就是应该在哪种传输层协议上构建 RPC。具体来说，RPC 系统应该使用可靠的协议（如 TCP/IP），还是应该在不可靠的通信层（如 UDP/IP）上构建？

乍一看，这个选择似乎很简单：显然我们希望请求能够可靠地传递到远程服务器，显然我们希望可靠地收到回复。因此，我们应该选择可靠的传输协议，例如 TCP，对吗？

不幸的是，在可靠通信层之上构建 RPC 会导致性能严重低下。回想一下上面的讨论，可靠通信层的工作方式：使用确认和超时/重试。因此，当客户端向服务器发送 RPC 请求时，服务器会以确认进行响应，以便调用者知道请求已收到。同样，当服务器向客户端发送答复时，客户端会确认该答复，以便服务器知道已收到答复。通过在可靠通信层之上构建请求/响应协议（例如 RPC），可以发送两条“额外”消息。

因此，许多 RPC 包都建立在不可靠的通信层（如 UDP）之上。这样做可以实现更高效的 RPC 层，但确实增加了为 RPC 系统提供可靠性的责任。RPC 层通过使用超时/重试和确认来实现所需的责任级别，就像我们上面描述的一样。通过使用某种形式的序列编号，通信层可以保证每个 RPC 只发生一次（在没有故障的情况下），或者最多发生一次（在发生故障的情况下）。

## Other Issues
RPC 运行时还必须处理其他一些问题。例如，当远程调用需要很长时间才能完成时会发生什么？考虑到我们的超时机制，长时间运行的远程调用可能会在客户端看来是失败的，从而触发重试，因此需要小心谨慎。一种解决方案是在未立即生成答复时使用显式确认（从接收方到发送方）；这让客户端知道服务器已收到请求。然后，经过一段时间后，客户端可以定期询问服务器是否仍在处理请求；如果服务器一直说“是”，客户端应该很高兴并继续等待（毕竟，有时过程调用可能需要很长时间才能完成执行）。

运行时还必须处理带有大参数的过程调用，这些参数大于单个数据包所能容纳的参数。一些较低级别的网络协议提供了这种发送方分段（将较大的数据包分解为一组较小的数据包）和接收方重组（将较小的部分重组为一个较大的逻辑整体）；如果没有，RPC 运行时可能必须自己实现这种功能。

许多系统处理的一个问题是字节顺序。您可能知道，有些机器以所谓的大端顺序存储值，而其他机器则使用小端顺序。大端存储字节（例如，整数）从最高有效位到最低有效位，就像阿拉伯数字一样；小端则相反。两者都是存储数字信息的有效方式；这里的问题是如何在不同字节顺序的机器之间进行通信。

RPC 包通常通过在其消息格式中提供明确定义的字节序来处理此问题。在 Sun 的 RPC 包中，XDR（外部数据表示）层提供此功能。如果发送或接收消息的机器与 XDR 的字节序匹配，则消息将按预期发送和接收。但是，如果通信的机器具有不同的字节序，则必须转换消息中的每条信息。因此，字节序的差异可能会产生较小的性能成本。

最后一个问题是是否向客户端公开通信的异步特性，从而实现一些性能优化。
具体来说，典型的 RPC 是同步进行的，即当客户端发出过程调用时，它必须等待过程调用返回才能继续。由于这种等待可能很长，并且客户端可能还有其他工作要做，因此某些 RPC 包允许您异步调用 RPC。发出异步 RPC 时，RPC 包会发送请求并立即返回；然后客户端可以自由地执行其他工作，例如调用其他 RPC 或其他有用的计算。客户端在某个时候会希望看到异步 RPC 的结果；因此它会回调到 RPC 层，告诉它等待未完成的 RPC 完成，此时可以访问返回参数。

# 48.6 Summary
我们已经看到了一个新主题的引入，即分布式系统，以及它的主要问题：如何处理现在司空见惯的故障。正如谷歌内部所说，当你只有一台台式机时，故障很少见；当你身处拥有数千台机器的数据中心时，故障随时都在发生。任何分布式系统的关键在于如何处理故障。

我们还看到，通信是任何分布式系统的核心。这种通信的一个常见抽象是在远程过程调用 (RPC) 中发现的，它使客户端能够对服务器进行远程调用；RPC 包处理所有复杂的细节，包括超时/重试和确认，以便提供与本地过程调用非常相似的服务。

真正理解 RPC 包的最佳方式当然是自己使用一个。Sun 的 RPC 系统使用存根编译器 rpcgen，是一个较老的系统；谷歌的 gRPC 和 Apache Thrift 是它的现代版本。尝试一下，看看有什么值得大惊小怪的。