Hardware-based address translation, or just address translation. With address translation, the hardware transforms each memory access, changing the virtual address provided by the instruction to a physical address where the desired information is actually located. 硬件完成虚拟地址到物理地址的转换。OS管理页表基址寄存器 CR3，每个进程都有一个CR3。硬件只是提供了 the low-level mechanism for doing so efficiently. 

The OS must thus manage memory, keeping track of which locations are free and which are in use, and judiciously intervening to maintain control over how memory is used.

The goal of this work is to create a beautiful illusion: that the program has its own private memory, where its own code and data reside. 背后，每个进程都被撕开，丢在了仓库里，OS完成组装。Behind that virtual reality lies the ugly physical 
truth: that many programs are actually sharing memory at the same time.

# 15.2 An Example
![[Pasted image 20241118154702.png]]
An example of what physical memory might look like once this process's address space has been placed in memory is found in Figure 15.2.

![[Pasted image 20241118155320.png]]

# 15.3 Dynamic (Hardware-based) Relocation
Introduced in the first time-sharing machines of the late 1950's is a simple idea referred to as base and bounds; Called dynamic relocation.

We'll need two hardware registers within each CPU:
- the base register
- the bounds register
In this setup, each program is written and compiled as if it is loaded at address zero. When a program starts running, the OS decides where in physical memory it should be loaded and sets the base register to that value.

Now when any memory reference is generated by the process, it is translated by the processor in the following manner:
```
physical address = virtual address + base
```

Each memory reference generated by the process is a **virtual address**; the hardware in turn adds the contents of the base register to this address and the result is a **physical address** that can be issued to the memory system.

We should note that the base and bounds registers are hardware structures kept on the chip (one pair per CPU). Called MMU.

# 15.4 Hardware Support: A Summary
![[Pasted image 20241118162748.png]]

First, as discussed in the chapter on CPU virtuallization, we require two different CPU modes. A single bit, perhaps stored in some kind of **processor status word**, indicates which mode the CPU is currently running in.

The hardware must also provide the **base and bounds registers** themselves; each CPU thus has an additional pair of registers, part of the **memory management unit (MMU)** of the CPU.

The hardware should provide special instructions to modify the base and bounds registers, allowing the OS to change them when different processes run. These instructions are **privileged**; only in kernel mode can the registers be modified.

Finally, the CPU must be able to generate **exceptions** in situations where a user program tries to access memory illegally; in this case, the CPU should stop executing the user program and arrange for the OS **exception handler** to run.  The CPU also must provided a method to inform it of the location of these handlers; a few more privileged instructions are thus needed.

# 15.5 OS Issues
![[Pasted image 20241118165218.png]]

First, the OS must take action when a process is created, finding space for its address space in memory. When a new process is created, the OS will have to search a data structure (often called a **free list**) to find room for the new address space and then mark it used. 但是这样用户的进程空间就是可变的。

Second, the OS must do some work when a process is terminated, reclaiming all of its memory for use in other processes or the OS. Upon termination of a process, the OS thus puts its memory back on the free list, and cleans up any associated data structures as need be.

==Third, the OS must also perform a few additional steps when a context switch occurs. There is only one base and bounds register pair on each CPU, after all, and their values differ for each running program, as each program is loaded at a different physical address in memory. Thus, the OS must ___save___ and ___restore___ the base-and bounds pair when it switches between processes. Specifically, when the OS decides to stop running a process, it must save the values of the base and bounds registers to memory, in some per-process structure such as the process structure or **process control block** (PCB). Similarly, when the OS resumes a running process (or runs it the first time), it must set the values of the base and bounds on the CPU to the correct values for this process.==

Fourth, the OS must provide **exception handlers**, or functions to be called; ==the OS installs these handlers at boot time (via privileged instructions).== 

![[Pasted image 20241118165332.png]]

![[Pasted image 20241118184701.png]]

Figures 15.5 and 15.6 illustrate much of the hardware/OS interaction in a timeline. The first figure shows what the OS does at boot time to ready the machine for use, and the second shows what happens when a process (Process A) starts running;

# 15.6 Summary
internal fragmentation, 内部碎片


