到目前为止，我们已经开发了锁的概念，并了解了如何通过正确的硬件和操作系统支持组合来正确构建锁。锁并不是构建并发程序所需的唯一原语。

具体来说，在很多情况下，线程希望在继续执行之前检查某个条件是否为真。例如，父线程可能希望在继续执行之前检查子线程是否已完成（这通常称为 join()）；应该如何实现这种等待？让我们看看图 30.1。

![[Pasted image 20241027151741.png]]
![[Pasted image 20241027151805.png]]

我们可以尝试使用共享变量，如图 30.2 所示。这种解决方案通常可行，但效率极低，因为父进程会旋转并浪费 CPU 时间。我们在这里想要的是让父进程进入休眠状态，直到我们等待的条件（例如，子进程执行完毕）实现。

![[Pasted image 20241027151850.png]]

								关键：如何等待条件
在多线程程序中，线程通常需要等待某个条件变为真后再继续执行。简单的方法，只是旋转直到条件变为真，效率极低并且浪费 CPU 周期，在某些情况下，可能不正确。因此，线程应该如何等待条件？

# 30.1 定义和例程
为了等待条件变为真，线程可以使用所谓的条件变量。条件变量是一个显式的队列，当某些执行状态（即某些条件）不符合要求时（通过等待条件），线程可以将其自身放入该队列；当其他线程改变所述状态时，可以唤醒其中一个（或多个）等待线程，从而允许它们继续（通过发出条件信号）。

要声明这样的条件变量，只需编写如下内容：pthread_cond_t c;，它将 c 声明为条件变量（注意：还需要进行适当的初始化）。条件变量有两个与之相关的操作：wait() 和 signal()。当线程希望使自己进入睡眠状态时，将执行 wait() 调用；当线程更改了程序中的某些内容并因此想要唤醒等待此条件的睡眠线程时，将执行 signal() 调用。具体来说，POSIX 调用如下所示：
![[Pasted image 20241027152356.png]]

为了简单起见，我们经常将它们称为 wait() 和 signal()。wait() 调用还接受一个互斥锁作为参数；**它假定在调用 wait() 时此互斥锁已被锁定。wait() 的职责是释放锁并使调用线程进入休眠状态（原子操作）；当线程唤醒时（在其他线程发出信号后），它必须重新获取锁，然后才能返回调用者**。这种复杂性源于希望在线程试图使自己进入休眠状态时防止发生某些竞争条件。让我们看一下 join 问题的解决方案（图 30.3），以便更好地理解这一点。

有两种情况需要考虑。在第一种情况下，父线程创建子线程但继续运行自身（假设我们只有一个处理器），因此立即调用 join() 等待子线程完成。在这种情况下，它将获取锁，检查子进程是否已完成（尚未完成），然后通过调用 wait() 使自己进入休眠状态（从而释放锁）。子进程最终将运行，打印消息“child”，并调用 exit() 唤醒父线程；此代码只是获取锁，设置状态变量 done，并向父进程发出信号，从而唤醒它。最后，父进程将运行（从 wait() 返回并持有锁），解锁，并打印最终消息“parent: end”

![[Pasted image 20241027152246.png]]

在第二种情况下，子进程在创建后立即运行，将 done 设置为 1，调用 signal 唤醒休眠线程（但没有，因此它只是返回），然后完成。然后父进程运行，调用 thr join()，看到 done 为 1，因此不等待并返回。

最后注意：您可能会观察到父进程在决定是否等待条件时使用 while 循环而不是 if 语句。虽然这似乎不是程序逻辑所必须的，但正如我们将在下面看到的，这始终是一个好主意。

为了确保您理解 thr_exit() 和 thr_join() 代码中每个部分的重要性，让我们尝试一些替代实现。首先，您可能想知道我们是否需要状态变量 done。如果代码看起来像下面的示例会怎样？（图 30.4）
![[Pasted image 20241027153147.png]]

不幸的是，这种方法是不可行的。想象一下子进程立即运行并立即调用 thr_exit() 的情况；在这种情况下，子进程将发出信号，但没有任何线程处于休眠状态。当父进程运行时，它只会调用 wait 并被卡住；没有线程会唤醒它。从这个例子中，您应该意识到状态变量 done 的重要性；它记录了线程想要知道的值。休眠、唤醒和锁定都是围绕它构建的。
![[Pasted image 20241027153444.png]]

这里（图 30.5）是另一个糟糕的实现。在这个例子中，我们假设不需要持有锁就可以发出信号并等待。这里会出现什么问题？想一想！

这里的问题是微妙的竞争条件。具体来说，如果父进程调用 join() 然后检查 done 的值，它将看到它是 0，因此尝试进入睡眠状态。但就在它调用 wait 进入睡眠状态之前，父进程被中断，子进程运行。子进程将状态变量 done 更改为 1 并发出信号，但没有线程在等待，因此没有线程被唤醒。当父进程再次运行时，它会永远休眠，这很可悲。

为了确保您理解，我们现在来看一个更复杂的例子：生产者/消费者或有界缓冲区问题。

							提示：在发出信号时始终保持锁定
1. **持锁信号的建议**：虽然在某些情况下不必严格要求，但通常在调用信号（signal）时持有锁是最简单和最好的做法。虽然有些情况可能在不持锁的情况下也能正常工作，但为了简单起见，最好始终在调用信号时持锁。
2. **等待时持锁的必要性**：与信号相反，等待（wait）时持锁不是仅仅建议，而是由其语义所决定的。等待操作有以下三个特性：
   - （a）调用等待时假设已经持有锁。
   - （b）在将调用者置于睡眠状态时会释放该锁。
   - （c）在返回之前，会重新获取锁。
因此，延伸出的通用建议是：在调用信号或等待时保持锁，这样就可以确保在多线程环境中保持良好的状态，避免潜在的竞争条件或不一致性。总之，持锁是确保线程安全的重要措施。

# 30.2 The Producer/Consumer (Bounded Buffer) Problem
本章中我们将要面对的下一个同步问题称为生产者/消费者问题，有时也称为有界缓冲区问题，它是由 Dijkstra 首次提出的。事实上，正是这个生产者/消费者问题促使 Dijkstra 和他的同事发明了广义信号量（可用作锁或条件变量）。

想象一个或多个生产者线程和一个或多个消费者线程。生产者生成数据项并将其放置在缓冲区中；消费者从缓冲区中获取所述项目并以某种方式使用它们。

由于有界缓冲区是共享资源，因此我们当然必须要求同步访问它，以免出现竞争条件。为了更好地理解这个问题，让我们检查一些实际的代码。

![[Pasted image 20241027154213.png]]


我们首先需要的是共享缓冲区，生产者将数据放入其中，消费者从中取出数据。为了简单起见，我们只使用一个整数（您当然可以想象将指向数据结构的指针放入此槽中），以及两个内部例程将值放入共享缓冲区并从缓冲区中获取值。请参见图 30.6。put() 例程假设缓冲区为空（并使用断言检查这一点），然后简单地将一个值放入共享缓冲区并通过将 count 设置为 1 来将其标记为已满。get() 例程执行相反的操作，将缓冲区设置为空（即，将 count 设置为 0）并返回该值。

现在我们需要编写一些例程，这些例程知道何时可以访问缓冲区以将数据放入其中或从中获取数据。这样做的条件应该是显而易见的：只有当 count 为零时（即缓冲区为空时）才将数据放入缓冲区，并且只有当 count 为 1 时（即缓冲区已满时）才从缓冲区获取数据。

这项工作将由两种类型的线程完成，其中一组我们称为生产者线程，另一组我们称为消费者线程。图 30.7 显示了将整数放入共享缓冲区循环次数的生产者的代码，以及从该共享缓冲区（永远）获取数据的消费者的代码，每次都打印出它从共享缓冲区中提取的数据项。

![[Pasted image 20241027154403.png]]

## A Broken Solution
现在想象一下我们只有一个生产者和一个消费者。显然，put() 和 get() 例程中都有临界区，因为 put() 会更新缓冲区，而 get() 会从缓冲区读取数据。但是，在代码周围加锁是行不通的；我们需要更多的东西。毫不奇怪，更多的东西就是一些条件变量。在这个（失败的）第一次尝试（图 30.8）中，我们有一个条件变量 cond 和关联的锁互斥锁。

![[Pasted image 20241027154729.png]]

让我们检查一下生产者和消费者之间的信号逻辑。当生产者想要填充缓冲区时，它会等待缓冲区为空（p1-p3）。消费者具有完全相同的逻辑，但等待的条件不同：满载（c1-c3）。

只有一个生产者和一个消费者时，图 30.8 中的代码可以工作。但是，如果我们有多个这样的线程（例如，两个消费者），解决方案就会出现两个关键问题。它们是什么？ 

1. **背景**：有一个条件变量 `cond` 和相关的互斥锁 `mutex`。生产者等待缓冲区为空，而消费者等待缓冲区满。对于单个生产者和消费者，这种逻辑是可行的，但当有多个消费者时，会出现问题。

2. **问题一：信号时机**：在消费者（例如 `Tc1`）等待的情况下，假设此时没有可消费的缓冲区，消费者进入睡眠状态。生产者（`Tp`）运行，填充了缓冲区并发出信号。此时，`Tc1` 被唤醒，但在它运行之前，另一个消费者（`Tc2`）可能已经消费了缓冲区中的值。这导致 `Tc1` 在获取锁后返回并尝试消费，但实际上缓冲区已经没有值可消费，触发断言错误。这个问题的根源在于，生产者唤醒 `Tc1` 后，缓冲区的状态发生了变化，但 `Tc1` 并不知道这个变化。

3. **Mesa 语义 vs. Hoare 语义**：
   - **Mesa 语义**：这是当前大多数系统使用的模型，信号只是一个提示，唤醒的线程并不能保证在被唤醒后立即运行。因此，唤醒的线程在运行时可能会发现条件已经不再满足。
   - **Hoare 语义**：这种模型更难实现，但它提供了更强的保证，即被唤醒的线程会立即运行，确保条件满足。这种语义能更好地解决线程之间的竞争问题。

## Better, But Still Broken: While, Not If
幸运的是，这个修复很容易（图 30.10）：将 if 改为 while。想想为什么这样做有效；现在消费者 Tc1 醒来并（在持有锁的情况下）立即重新检查共享变量的状态（c2）。如果此时缓冲区为空，消费者只需返回睡眠状态（c3）。推论 if 也在生产者中更改为 while（p2）。

![[Pasted image 20241027174143.png]]


由于 Mesa 语义，使用条件变量时要记住的一条简单规则是始终使用 while 循环。有时您不必重新检查条件，但这样做总是安全的；只需这样做并感到高兴即可。

但是，此代码仍然有一个错误，这是上面提到的两个问题中的第二个。您能发现它吗？这与只有一个条件变量有关。

问题发生在两个消费者首先运行（Tc1 和 Tc2）并且都进入睡眠状态（c3）时。然后，生产者运行，将一个值放入缓冲区，并唤醒其中一个消费者（例如 Tc1）。然后，生产者循环回来（在此过程中释放并重新获取锁）并尝试将更多数据放入缓冲区；因为缓冲区已满，所以生产者等待条件（因此处于睡眠状态）。现在，一个消费者已准备好运行（Tc1），并且两个线程因条件而处于睡眠状态（Tc2 和 Tp）。我们即将引发一个问题：事情变得令人兴奋！

然后，消费者 Tc1 通过从 wait() 返回（c3）而被唤醒，重新检查条件（c2），并发现缓冲区已满，因此使用该值（c4）。然后，这个消费者发出条件信号（c5），只唤醒一个处于休眠状态的线程。但是，它应该唤醒哪个线程呢？

因为消费者已经清空了缓冲区，所以它显然应该唤醒生产者。但是，如果它唤醒消费者 Tc2（这绝对是可能的，具体取决于等待队列的管理方式），我们就会遇到问题。具体来说，消费者 Tc2 将醒来并发现缓冲区为空（c2），然后重新进入睡眠状态（c3）。有值要放入缓冲区的生产者 Tp 处于睡眠状态。另一个消费者线程 Tc1 也重新进入睡眠状态。所有三个线程都处于睡眠状态，这是一个明显的错误；请参见图 30.11 了解这一可怕灾难的残酷分步过程。

![[Pasted image 20241027174346.png]]

信号显然是必要的，但必须更加有针对性。消费者不应该唤醒其他消费者，而只能唤醒生产者，反之亦然。

##  The Single Buffer Producer/Consumer Solution
这里的解决方案又是一个很小的解决方案：使用两个条件变量，而不是一个，以便正确地发出信号，指示当系统状态发生变化时应该唤醒哪种类型的线程。图 30.12 显示了生成的代码。
![[Pasted image 20241027182420.png]]

在代码中，生产者线程等待条件为空，并发出填充信号。相反，消费者线程等待填充并发出空信号。通过这样做，设计上避免了上述第二个问题：消费者永远不会意外唤醒消费者，生产者永远不会意外唤醒生产者。

					提示：使用 WHILE（而不是 IF）来检查条件

在多线程程序中检查条件时，使用while 循环始终是正确的；仅使用 if 语句可能是正确的，具体取决于信号的语义。因此，始终使用 while，您的代码将按预期运行。

在条件检查中使用 while 循环还可以处理发生虚假唤醒的情况。在某些线程包中，由于实现细节，虽然只发生了一个信号，但可能会唤醒两个线程。虚假唤醒是重新检查线程正在等待的条件的另一个原因。

## The Correct Producer/Consumer Solution
我们现在有一个可行的生产者/消费者解决方案，尽管它不是完全通用的。我们所做的最后一个更改是实现更多的并发性和效率；具体来说，我们添加了更多的缓冲区槽，以便在休眠之前可以生成多个值，同样，在休眠之前也可以使用多个值。如果只有一个生产者和消费者，这种方法会更有效，因为它减少了上下文切换；如果存在多个生产者或消费者（或两者兼有），它甚至允许并发生产或消费，从而提高并发性。幸运的是，这与我们当前的解决方案相比只是一个小变化。

这个正确解决方案的第一个变化是在缓冲区结构本身以及相应的 put() 和 get() 中（图 30.13）。我们还稍微改变了生产者和消费者检查的条件，以确定是否休眠。我们还展示了正确的等待和信号逻辑（图 30.14）。生产者只有在所有缓冲区都已填满时才会休眠（p2）；同样，消费者只有在所有缓冲区都为空时才会休眠（c2）。这样我们就解决了生产者/消费者问题。

![[Pasted image 20241028132522.png]]

# 30.3 覆盖条件
现在我们再看一个如何使用条件变量的例子。

他们遇到的问题最好通过简单的例子来展示，在这个例子中是一个简单的多线程内存分配库。图 30.15 显示了演示该问题的代码片段。

正如您在代码中看到的，当线程调用内存分配代码时，它可能必须等待更多内存可用。相反，当线程释放内存时，它会发出更多内存可用信号。但是，我们上面的代码有一个问题：应该唤醒哪个等待线程（可以有多个）？
![[Pasted image 20241028132730.png]]
考虑以下场景。假设有零字节可用；线程 Ta 调用 allocate(100)，随后线程 Tb 通过调用 allocate(10) 请求较少的内存。因此，Ta 和 Tb 都等待条件并进入睡眠状态；没有足够的可用字节来满足这两个请求。

此时，假设第三个线程 Tc 调用 free(50)。不幸的是，当它调用 signal 唤醒等待线程时，它可能无法唤醒正确的等待线程 Tb，该线程只等待释放 10 个字节；Ta 应该保持等待状态，因为还没有足够的内存可用。因此，图中的代码不起作用，因为唤醒其他线程的线程不知道要唤醒哪个线程（或多个线程）。

Lampson 和 Redell 提出的解决方案很简单：将上述代码中的 pthread_cond_signal() 调用替换为 pthread_cond_broadcast() 调用，这将唤醒所有等待线程。通过这样做，我们保证应该唤醒的任何线程都被唤醒。当然，缺点是会对性能产生负面影响，因为我们可能会不必要地唤醒许多其他不应该（暂时）唤醒的等待线程。这些线程将简单地唤醒，重新检查条件，然后立即返回睡眠状态。Lampson 和 Redell 将这种条件称为覆盖条件，因为它涵盖了线程需要唤醒的所有情况（保守地说）；正如我们所讨论的，代价是可能会唤醒太多线程。精明的读者可能还注意到我们可以更早地使用这种方法（参见只有一个条件变量的生产者/消费者问题）。但是，在这种情况下，我们有更好的解决方案，因此我们使用了它。一般来说，如果您发现您的程序仅在您将信号更改为广播时才有效（但您认为它不需要），则可能是存在错误；修复它！但在上面的内存分配器等情况下，广播可能是最直接的解决方案。

# 30.4 总结
我们已经看到了除了锁之外的另一个重要的同步原语的引入：条件变量。通过允许线程在某些程序状态不符合要求时休眠，CV 使我们能够巧妙地解决许多重要的同步问题，包括著名的（并且仍然很重要的）生产者/消费者问题，以及覆盖条件。

