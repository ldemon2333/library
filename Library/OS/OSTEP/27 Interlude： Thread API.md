# 27.1 线程创建
在POSIX标准中，线程创建是：
![[Pasted image 20241021230148.png]]

这里有四个参数：thread，attr，start_routine 和 arg。

第一个 thread 是一个指针，指向结构体类型pthread_t；第二个参数 attr 用于指定此线程可能具有的任何属性。一些示例包括设置栈大小或有关线程调度优先级的信息。属性通过单独调用 pthread attr init() 进行初始化；有关详细信息，请参阅手册页。但是，在大多数情况下，默认值就可以了；在这种情况下，我们只需传入 NULL 。

第三个参数是最复杂的，但实际上只是在问：这个线程应该在哪个函数中开始运行？在 C 语言中，我们称之为函数指针，这个指针告诉我们需要以下内容：一个函数名称（start_routine），它被传递一个 void * 类型的参数（如start_routine后的括号中所示），并返回一个 void * 类型的值（即 void 指针）。

如果这个routine 需要一个整型声明，而不是一个void 指针，声明就会这样：
![[Pasted image 20241021231047.png]]
如果函数返回一个整型，就是：
![[Pasted image 20241021231130.png]]
最后，第四个参数 arg 正是要传递给线程开始执行的函数的参数。您可能会问：为什么我们需要这些 void 指针？答案很简单：将 void 指针作为函数start_routine 的参数允许我们传入任何类型的参数；将其作为返回值允许线程返回任何类型的结果。

让我们看图 27.1 中的示例。这里我们只创建一个线程，该线程被传递了两个参数，并打包成我们自己定义的单个类型 (myarg_t)。线程一旦创建，就可以简单地将其参数转换为它期望的类型，从而根据需要解包参数。

就是这样！一旦创建了一个线程，您实际上就有了另一个实时执行实体，它具有自己的调用栈，在与程序中所有当前存在的线程相同的地址空间内运行。

![[Pasted image 20241021231558.png]]

# 27.2 Thread Completion
上面的例子展示了如何创建线程。但是，如果你想等待线程完成会发生什么？你需要做一些特殊的事情来等待完成；特别是，你必须调用例程 pthread join()。

![[Pasted image 20241021231710.png]]

此例程有两个参数。第一个参数为 pthread_t 类型，用于指定要等待的线程。此变量由线程创建例程初始化（当您将指向它的指针作为参数传递给 pthread_create() 时）；如果您保留它，则可以使用它等待该线程终止。

第二个参数是指向返回值的指针。由于例程可以返回任何内容，因此它被定义为返回指向 void 的指针；由于 pthread_join() 例程会更改传入参数的值，因此您需要传入指向该值的指针，而不仅仅是值本身。

让我们看另一个示例（图 27.2）。在代码中，再次创建了一个线程，并通过 myarg_t 结构传递了几个参数。要返回值，使用 myret_t 类型。一旦线程运行完毕，主线程（它一直在 pthread_join() 例程中等待）就会返回，然后我们就可以访问线程返回的值，即访问 myret_t 中的任何值。

关于这个例子，有几点需要注意。首先，很多时候我们不必做所有这些痛苦的参数打包和解包工作。例如，如果我们只是创建一个没有参数的线程，我们可以在创建线程时将 NULL 作为参数传入。同样，如果我们不关心返回值，我们可以将 NULL 传入 pthread_join()。

![[Pasted image 20241021232225.png]]

其次，如果我们只传递一个值（例如，一个 long long int），我们不必将其打包为参数。图 27.3显示了一个示例。在这种情况下，生活会简单一些，因为我们不必将参数和返回值打包在结构内。

![[Pasted image 20241021234123.png]]

第三，我们应该注意，必须非常小心如何从线程返回值。具体来说，永远不要返回指向线程调用堆栈上分配的内容的指针。如果你这样做了，你认为会发生什么？（想一想！）下面是一个例子
![[Pasted image 20241021233817.png]]

在这种情况下，变量 oops 被分配在 mythread 的栈上。但是，当它返回时，该值会自动释放（毕竟，这就是堆栈如此易于使用的原因！），因此，将指针传回给现在已释放的变量将导致各种不良结果。当然，当您打印出您认为返回的值时，您可能会（但不一定！）感到惊讶。

最后，您可能会注意到，使用 pthread_create() 创建线程，然后立即调用 pthread_join()，这是一种非常奇怪的创建线程的方式。事实上，有一种更简单的方法可以完成这个任务；它被称为过程调用。显然，我们通常会创建不止一个线程并等待它完成，否则使用线程就没有多大意义了。

我们应该注意，并非所有多线程代码都使用 join 例程。例如，多线程 Web 服务器可能会创建多个工作线程，然后使用主线程接受请求并将它们传递给工作线程，无限期地如此。因此，这种长寿命程序可能不需要 join。但是，创建线程来执行特定任务（并行）的并行程序可能会使用 join 来确保所有这些工作在退出或进入下一计算阶段之前完成。

# 27.3 Locks
除了线程创建和连接之外，POSIX 线程库提供的下一个最有用的函数集可能是用于通过锁为临界区提供互斥的函数。用于此目的的最基本的一对例程由以下程序提供：
![[Pasted image 20241021235640.png]]

这些例程应该易于理解和使用。当您的代码区域是临界区，因此需要保护以确保正确操作时，锁非常有用。您可能可以想象代码是什么样子的：

![[Pasted image 20241021235759.png]]
代码的意图如下：如果调用 pthread_mutex_lock() 时没有其他线程持有锁，则线程将获取锁并进入临界区。如果另一个线程确实持有锁，则试图获取锁的线程将不会从调用中返回，直到它获得锁（这意味着持有锁的线程已通过 unlock 调用释放了锁）。当然，在给定时间，许多线程可能会卡在锁获取函数内等待；但是，只有获得锁的线程才应调用 unlock。

不幸的是，此代码在两个重要方面存在问题。第一个问题是缺乏正确的初始化。所有锁都必须正确初始化，以保证它们一开始就具有正确的值，从而在调用 lock 和 unlock 时按预期工作。对于 POSIX 线程，有两种初始化锁的方法。一种方法是使用 PTHREAD_MUTEX_INITIALIZER，如下所示：

![[Pasted image 20241022100828.png]]

这样做会将锁设置为默认值，从而使锁可用。执行此操作的动态方法（即在运行时）是调用pthread_mutex_init()，如下所示：
![[Pasted image 20241022100952.png]]

此例程的第一个参数是锁本身的地址，而第二个参数是一组可选的属性。有关属性的更多信息，请自行阅读；传入 NULL 只会使用默认值。两种方法都可以，但我们通常使用动态（后者）方法。请注意，当您使用完锁时，还应相应地调用 pthread_mutex_destroy()；

上述代码的第二个问题是，它在调用 lock 和 unlock 时无法检查错误代码。就像您在 UNIX 系统中调用的几乎任何库例程一样，这些例程也可能失败！如果您的代码没有正确检查错误代码，则失败将悄无声息地发生，在这种情况下，可能会允许多个线程进入临界区。至少，使用包装器，它断言例程成功，如图 27.4所示；更复杂（非玩具）的程序在出现问题时不能简单地退出，而应该检查失败情况，并在调用不成功时采取适当的措施。

![[Pasted image 20241022101303.png]]

lock 和 unlock 例程并不是 pthreads 库中唯一与锁交互的例程。另外两个值得关注的例程如下：
![[Pasted image 20241022101335.png]]
这两个调用用于获取锁。如果锁已被持有，trylock 版本将返回失败；获取锁的 timedlock 版本将在超时或获取锁后返回，以先发生者为准。因此，超时为零的 timedlock 退化为 trylock 情况。这两个版本通常应避免使用；然而，在某些情况下，避免在锁获取例程中卡住（可能无限期地卡住）可能会很有用，我们将在以后的章节中看到（例如，当我们研究死锁时）。

# 27.4 条件变量
任何线程库的另一个主要组件（POSIX 线程的情况当然如此）是条件变量的存在。当线程之间必须进行某种信号传递时，如果一个线程正在等待另一个线程执行某项操作才能继续，则条件变量非常有用。希望以这种方式进行交互的程序使用两个主要例程：

![[Pasted image 20241022101623.png]]

要使用条件变量，还必须有一个与此条件关联的锁。调用上述任一例程时，都应持有此锁。

第一个程序，pthread_cond_wait()，使调用线程进入休眠状态，从而等待其他线程向其发出信号，通常是当程序中某些内容发生变化而当前处于休眠状态的线程可能关心时。典型用法如下：

![[Pasted image 20241022101828.png]]

在此代码中，在初始化相关锁和条件之后，线程会检查变量 ready 是否已设置为除零以外的值。如果没有，线程只需调用 wait 例程即可休眠，直到其他线程将其唤醒。

唤醒将在其他线程中运行的线程的代码如下所示：

![[Pasted image 20241022101950.png]]

关于此代码序列，有几点需要注意。首先，在发出信号时（以及在修改全局变量 ready 时），我们始终确保持有锁。这确保我们不会意外地将竞争条件引入到我们的代码中。

其次，您可能会注意到 wait 调用将锁作为其第二个参数，而 signal 调用仅接受条件。造成这种差异的原因是，除了使调用线程进入睡眠状态外，wait 调用还会在使所述调用者进入睡眠状态时释放锁。想象一下，如果它不这样做：另一个线程如何获取锁并发出信号唤醒它？但是，在被唤醒后返回之前，pthread_cond_wait() 会重新获取锁，从而确保在等待序列开始时获取锁和结束时释放锁之间的任何时间，等待线程都会持有锁。

最后一个奇怪之处：等待线程在 while 循环中重新检查条件，而不是简单的 if 语句。我们将在后续章节中研究条件变量时详细讨论这个问题，但一般来说，使用 while 循环是简单且安全的做法。虽然它会重新检查条件（可能增加一点开销），但有些 pthread 实现可能会错误地唤醒等待线程；在这种情况下，如果不重新检查，等待线程将继续认为条件已更改，即使它没有更改。因此，将唤醒视为某些事情可能已更改的暗示，而不是绝对事实，会更安全。

请注意，有时很容易使用简单的标志在两个线程之间发出信号，而不是条件变量和相关锁。例如，我们可以重写上面的等待代码，使其在等待代码中看起来更像这样：
![[Pasted image 20241022102339.png]]
相关的signaling 代码是：

![[Pasted image 20241022102401.png]]
永远不要这样做，原因如下。首先，在许多情况下，它的性能很差（长时间旋转只会浪费 CPU 周期）。其次，它容易出错。正如最近的研究所示，使用标志（如上所述）在线程之间进行同步时，出错非常容易；在该研究中，大约一半的这些临时同步的使用都是错误的！不要偷懒；即使您认为不用条件变量也可以，也要使用条件变量。

如果条件变量听起来令人困惑，请不要太担心（暂时）——我们将在后续章节中详细介绍它们。在此之前，只要知道它们的存在并了解它们的使用方式和原因就足够了。

# 27.5 编译与运行
编译一个多线程程序，+ pthread.h 和
![[Pasted image 20241022102714.png]]

# 27.6 总结
我们介绍了 pthread 库的基础知识，包括线程创建、通过锁构建互斥以及通过条件变量发送信号和等待。除了耐心和细心之外，您不需要太多其他东西来编写强大而高效的多线程代码！

现在，我们以一组可能对您编写多线程代码有用的提示结束本章（有关详细信息，请参阅下一页的旁注）。API 还有其他有趣的方面；如果您想要更多信息，请在 Linux 系统上键入 man -k pthread 以查看构成整个接口的一百多个 API。但是，本文讨论的基础知识应该使您能够构建复杂的（希望是正确且高性能的）多线程程序。线程的难点不是 API，而是构建并发程序的棘手逻辑。继续阅读以了解更多信息。

# ASIDE：线程API 指导
- 保持简单。最重要的是，任何用于在线程之间锁定或发送信号的代码都应尽可能简单。棘手的线程交互会导致错误。
- 尽量减少线程交互。尽量将线程交互的方式数量保持在最低限度。每个交互都应经过仔细考虑，并使用经过验证的方法构建（我们将在接下来的章节中了解其中的许多方法）。
- 初始化锁和条件变量。不这样做会导致代码有时有效，有时会以非常奇怪的方式失败。
- 检查您的返回代码。当然，在您进行的任何 C 和 UNIX 编程中，您都应该检查每个返回代码，这里也是如此。不这样做会导致奇怪且难以理解的行为，使您很可能 (a) 尖叫，(b) 拔掉头发，或 (c) 两者兼而有之。
- 小心传递参数给线程和从线程返回值的方式。具体来说，任何时候传递对堆栈上分配的变量的引用时，您可能做错了什么。
- 每个线程都有自己的堆栈。与上述观点相关，请记住每个线程都有自己的堆栈。因此，如果您在线程正在执行的某个函数内部有一个本地分配的变量，则该变量本质上是该线程私有的；没有其他线程可以（轻松）访问它。要在线程之间共享数据，值必须位于堆中或某个全局可访问的区域。
- 始终使用条件变量在线程之间发出信号。虽然使用简单的标志通常很诱人，但不要这样做。
- 
- 使用手册页。特别是在 Linux 上，pthread 手册页非常有用，讨论了这里介绍的许多细微差别，通常甚至更详细。仔细阅读！