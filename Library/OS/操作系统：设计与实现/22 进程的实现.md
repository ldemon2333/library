# 22.1 进程与虚拟地址空间
![[Pasted image 20241118202948.png]]

![[Pasted image 20241118202955.png]]

![[Pasted image 20241118203006.png]]

![[Pasted image 20241118203038.png]]

fork() 在进行状态机复制时，虽然理论上需要做出完整的状态复制，但本着 “复制的数据可能立即被浪费掉” 的观察，操作系统希望只在 “不得不复制” 时才复制。

现代操作系统会维护页面的共享情况，并在 fork 后将父子进程的地址空间都标记为 read-only，而当双方中的任何一个进程写入发生 page fault 时，才复制一页。对于连续的 fork()，则会产生多个进程共享页面的情况。

# Take-away Messages
Everything is a state machine; 而操作系统在中断/系统调用时，“封存” 了所有进程的状态机，并且可以将它们重新加载到 CPU 上执行。顺着这个思路，我们不难看到 UNIX 操作系统和系统调用的 “直接” 实现。而进程不过是 “线程” 加上了一个地址翻译函数。
