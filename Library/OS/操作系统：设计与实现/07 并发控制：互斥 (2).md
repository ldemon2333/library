如何在OS内核和用户态应用程序中实现互斥

# OS内核中的互斥
lock/unlock 并没"stop the world"
- 只是同一把锁保护的代码被串行化了

OS的状态迁移（内核态自旋锁可以自由开关中断）
- 选择任意CPU：
	- 从PC 取指令执行或响应中断信号（中断打开时）
		- 计算：改变内存/寄存器数值
		- I/O：与“计算机系统外”交换数据

正确实现互斥

内核态下，需要考虑中断机制对锁的影响。进入临界区后，如果在执行代码的过程中发生中断，就会无条件地跳转进入中断处理程序，而万一处理中断时需要用到的数据正是之前临界区中正在使用的数据，则会发生死锁。为避免此情况发生，当初进入临界区时就应该关闭中断，即令CPU不再响应中断信号，退出临界区时再恢复中断状态。但是要保证lock/unlock前后中断状态不变。

用户态下，要实现互斥可以使用自旋锁，但自旋锁的性能有缺陷，会造成资源浪费。为了在互斥的同时保证性能，用户程序一般不实现自己的锁，而是通过系统调用，让OS帮自己实现互斥。具体方法是，进入OS 内核态，做一次小的自旋锁操作，查看释放能获得锁。若用户可以立即获取锁，则正常进入临界区；若无法立即拿到锁，则进入内核态，内核行使进程调度的权力，直接将用户从运行态变为就绪态，让其他程序先执行，直到其他程序将锁释放，再将之前请求锁的用户恢复运行，此时用户线程即可进入临界区。OS 把一个长的临界区划分为多个短的临界区，进行一个上下文切换。

- 先关中断+自旋可以保证实现互斥

lock/unlock前后中断状态不变
- 不得在关中断时随意打开中断（例如处理中断时）
- 不得随意关闭中断（否则可能导致中断丢失）
- 因此我们需要保存中断状态
- xv6 自旋锁

**操作系统内核中的自旋锁实现**：利用计算机系统状态机的视角，操作系统内核中的自旋锁不仅要实现处理器间的互斥，还要正确处理中断，以及锁的嵌套。当多个需求叠加时，作出一个正确的实现就不再显然。

# OS内核中的（半）无锁互斥
![[Pasted image 20241024161618.png]]



自旋锁具有较差的Scalability，性能和多处理器数不是线性增长。

自旋锁的使用场景
- OS 内核的并发数据结构（短临界区）：临界区几乎不“拥堵”，迅速结束

![[Pasted image 20241024164915.png]]
![[Pasted image 20241024164927.png]]

![[Pasted image 20241024164942.png]]

# 应用程序中的互斥
![[Pasted image 20241024165028.png]]

如何实现互斥：
- 使用syscall，进入临界区前，使用syscall
- 把锁的实现放到OS

![[Pasted image 20241024165145.png]]

![[Pasted image 20241024171519.png]]
![[Pasted image 20241024171540.png]]


# Take-away Messages

“互斥” 看起来简单，用自旋就能实现，但如果在实际的场景 (例如可被中断的操作系统内核、不希望浪费 CPU 资源的应用程序等)，实际的互斥实现就不再简单。我们在 xv6 的自旋锁实现中，发现了许多 “防御性编程” 的例子，先假设程序员可能会犯一切可能的错误——然后不断加以检查。而 “正确性完全由开发者负责” 的时代将要过去，我们将会在未来越来越多地看到编程语言中的机制，帮助我们写出正确的代码。

软件不够 硬件来凑 用户不够 内核来凑。


---
`atoi`是一个C标准库函数，用于将字符串转换为整数。其全称是“ASCII to Integer”，主要功能是将表示数字的字符串（如"123"）转换为对应的整数值（如123）。

### 函数原型
```c
int atoi(const char *str);
```

### 参数
- `str`：指向要转换的字符串的指针。字符串可以包含空白字符（如空格、制表符）和正负号。

### 返回值
- 返回转换后的整数值。如果字符串不包含可转换的数字部分，`atoi`将返回0。
- 注意，如果转换的数字超出了`int`类型的范围，结果是未定义的。

### 特点
- `atoi`不进行错误检查，因此如果传入无效字符串（如"abc"），它将返回0，但你无法判断这是由于无效输入还是输入的数字本身就是0。
- 由于这个缺陷，推荐使用`strtol`或`strtod`等函数，这些函数提供了更好的错误处理机制。

---
`void (*entry)(int);` 是 C 语言中的函数指针声明，具体解释如下：

- `void`：表示该函数没有返回值。
- `(*entry)`：这是一个函数指针，名为 `entry`。括号用于指明这是一个指针，而不是一个普通的函数。
- `(int)`：表示这个函数接受一个 `int` 类型的参数。

因此，这个声明的意思是：`entry` 是一个指向接受一个 `int` 类型参数并返回 `void` 的函数的指针。你可以将具体的函数地址赋值给 `entry`，然后通过 `entry` 调用这个函数。

---
这段代码定义了一个线程的包装函数，具体解释如下：

1. **函数声明**：
   ```c
   static inline void *wrapper_(void *arg) {
   ```
   - `static inline`：`static` 表示这个函数只能在定义它的文件中访问，`inline` 表示编译器可以选择将其展开，以提高性能。
   - `void *wrapper_(void *arg)`：函数返回一个 `void *` 指针，接受一个 `void *` 类型的参数 `arg`。

2. **参数转换**：
   ```c
   struct thread *t = (struct thread *)arg;
   ```
   - 将传入的 `void *` 类型的参数 `arg` 转换为 `struct thread *` 类型，以便访问线程信息。

3. **函数调用**：
   ```c
   t->entry(t->id);
   ```
   - 调用结构体 `thread` 中的 `entry` 函数，传入 `t->id` 作为参数。这意味着 `entry` 是一个指向函数的指针，代表线程要执行的具体功能。

这个包装函数的目的是为了使自定义的线程函数（`entry`）能够符合 POSIX 线程库的要求，允许用户通过 `pthread_create` 创建线程时传递自定义参数。

---
![[Pasted image 20241025150119.png]]

这段代码使用了 GCC 提供的 `__attribute__((constructor))` 特性来定义一个构造函数。具体解释如下：

1. **构造函数属性**：
   ```c
   __attribute__((constructor))
   ```
   - 这个属性用于标记 `startup` 函数，使其在程序启动时自动调用。这意味着在 `main` 函数执行之前，`startup` 函数会被自动执行。

2. **函数定义**：
   ```c
   static void startup() {
   ```
   - `static` 关键字表示该函数的作用域仅限于定义它的文件，不能被其他文件访问。

3. **注册退出处理函数**：
   ```c
   atexit(join);
   ```
   - 在 `startup` 函数中，调用 `atexit(join)` 注册一个退出处理函数 `join`。这意味着当程序正常终止时，`join` 函数将被自动调用。

总结来说，这段代码确保了在程序启动时执行 `startup` 函数，并在程序结束时调用 `join` 函数。这是一种管理程序生命周期的有效方式，常用于进行初始化和清理操作。

---
这段代码使用了内联汇编语法来执行一个原子操作。具体解释如下：

1. **`asm volatile`**：
   - `asm` 是用于嵌入汇编代码的关键字。
   - `volatile` 表示编译器在优化时不会删除或重排序这段代码，以确保它在执行时不被忽略或优化掉。

2. **汇编指令**：
   ```asm
   "lock addq $1, %0"
   ```
   - `"lock"`：这是一个前缀，表示接下来的操作是原子的，适用于多线程环境，确保该操作在多核处理器上不会被中断。
   - `"addq $1, %0"`：这是要执行的汇编指令。
     - `addq`：表示执行加法操作，`q` 代表操作的是 64 位的整数。
     - `$1`：表示要加的值，这里是 1。
     - `%0`：是占位符，用于表示输出变量。

3. **输出约束**：
   ```c
   : "+m"(sum)
   ```
   - `"+m"`：表示该操作是对内存的读写（read-write）。`m` 表示这个操作会涉及内存中的一个变量。
   - `(sum)`：这是对应的变量名，表示汇编指令会直接操作 `sum` 变量。

总结来说，这段代码的作用是以原子的方式将 `sum` 变量的值增加 1，确保在多线程环境下操作的安全性。

---
`subprocess.run` 是 Python 的 `subprocess` 模块中的一个函数，用于在子进程中执行外部命令。它提供了简单的接口来运行命令并获取结果。以下是 `subprocess.run` 的基本用法和常见参数解释：

### 基本用法

```python
import subprocess

result = subprocess.run(['命令', '参数1', '参数2'], capture_output=True, text=True)
```

### 重要参数

1. **args**：要执行的命令及其参数，可以是字符串列表或字符串（如果是字符串，则需要注意在字符串中正确使用空格和引号）。
   ```python
   subprocess.run(['ls', '-l'])
   ```

2. **capture_output**：如果设置为 `True`，会捕获标准输出（stdout）和标准错误（stderr）。
   ```python
   result = subprocess.run(['ls'], capture_output=True)
   ```

3. **text**：如果设置为 `True`，输出将以字符串形式返回，而不是字节串。这在处理文本数据时非常有用。
   ```python
   result = subprocess.run(['ls'], capture_output=True, text=True)
   ```

4. **check**：如果设置为 `True`，当命令返回非零状态码时，会抛出 `subprocess.CalledProcessError` 异常。
   ```python
   result = subprocess.run(['ls', '不存在的文件'], check=True)
   ```

5. **cwd**：设置命令执行时的当前工作目录。
   ```python
   result = subprocess.run(['ls'], cwd='/path/to/directory')
   ```

6. **env**：可以指定环境变量的字典，来修改子进程的环境变量。
   ```python
   result = subprocess.run(['命令'], env={'VAR': 'value'})
   ```

### 获取结果

执行后，返回的 `result` 对象包含多个属性：

- **result.returncode**：命令的返回码。
- **result.stdout**：捕获的标准输出（如果使用 `capture_output=True`）。
- **result.stderr**：捕获的标准错误输出（如果使用 `capture_output=True`）。

### 示例

以下是一个完整的示例：

```python
import subprocess

result = subprocess.run(['ls', '-l'], capture_output=True, text=True)

if result.returncode == 0:
    print('Output:')
    print(result.stdout)
else:
    print('Error:')
    print(result.stderr)
```

在这个示例中，我们执行 `ls -l` 命令并捕获输出。如果命令成功执行，将打印输出；如果出现错误，则打印错误信息。