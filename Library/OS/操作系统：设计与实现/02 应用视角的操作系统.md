所有程序都是状态机模型，状态机是由严格数学定义的。
![[Pasted image 20241016151054.png]]

函数调用有一个专门留一个寄存器给栈（SP，Stack Pointer）

Everything (高级语言代码、机器代码) 都是状态机；而编译器实现了两种状态机之间的翻译。无论何种状态机，在没有操作系统时，它们只能做纯粹的计算，甚至都不能把结果传递到程序之外——而程序与操作系统沟通的唯一桥梁是系统调用 (例如 x86-64 的 syscall 指令)。如此重要的桥梁，操作系统中自然也有工具：strace 可以查看程序运行过程中的系统调用序列。

`gcc -c` 命令用于将源代码文件编译为**目标文件**（object file），而不进行链接。

### 编译流程：
1. **预处理**：处理宏定义、头文件包含、条件编译等（通常生成 `.i` 文件）。
2. **编译**：将预处理后的代码转换成汇编代码（生成 `.s` 文件）。
3. **汇编**：将汇编代码转换成机器码，生成目标文件（通常为 `.o` 文件）。
4. **链接**：将多个目标文件和库链接在一起，生成可执行文件。

当使用 `gcc -c` 时，编译器会：
- 完成前 3 个步骤，生成 `.o`（目标文件），但是不会执行第 4 步（链接）。
  
### 示例：
```bash
gcc -c main.c
```
这条命令会将 `main.c` 编译成 `main.o`，这是一个二进制的目标文件，不能直接运行，需要进一步链接生成可执行文件。

---

`objdump -d` 是 `objdump` 命令中的一个选项，用于**反汇编**可执行文件或目标文件中的机器代码，输出可读的汇编代码。

### 详细解释：

- `-d` 是 `disassemble` 的缩写，表示将文件中的机器码转换为汇编语言（反汇编），并显示汇编指令。

### 典型用法：

```bash
objdump -d <binary_file>
```
		
- `<binary_file>` 是需要反汇编的二进制文件，可以是可执行文件（如 `a.out`），也可以是目标文件（如 `.o` 文件）。

### 输出内容：
1. **地址**：显示二进制指令的内存地址。
2. **机器码**：每条指令的原始机器码（十六进制表示）。
3. **汇编指令**：与机器码对应的汇编代码（例如 `mov`, `add` 等）。

例如，对一个简单的 C 文件编译生成的可执行文件运行 `objdump -d`，你会看到类似以下的输出：

```
0000000000401136 <main>:
  401136:	55                   	push   %rbp
  401137:	48 89 e5             	mov    %rsp,%rbp
  40113a:	48 83 ec 10          	sub    $0x10,%rsp
  ...
```

- `0000000000401136`: 这是代码段中每条指令的地址。
- `push %rbp`, `mov %rsp,%rbp`: 这是将机器码反汇编为汇编语言的结果。

----
```c
#include <sys/syscall.h>

// The x86-64 system call Application Binary Interface (ABI):
//     System call number: RAX
//     Arguments: RDI, RSI, RDX, RCX, R8, R9
//     Return value: RAX
// See also: syscall(2) syscalls(2)

#define syscall3(id, a1, a2, a3) \
    movq $SYS_##id, %rax; \
    movq $a1, %rdi; \
    movq $a2, %rsi; \
    movq $a3, %rdx; \
    syscall

#define syscall2(id, a1, a2)  syscall3(id, a1, a2, 0)
#define syscall1(id, a1)  syscall2(id, a1, 0)

.globl _start
_start:
    syscall3(write, 1, addr1, addr2 - addr1)
    syscall1(exit, 0)

addr1:
    .ascii "\033[01;31mHello, OS World\033[0m\n"
addr2:

```
这段代码是用 **x86-64 汇编** 写的，它展示了如何通过系统调用直接与操作系统交互。它用汇编语言实现了两个常见的系统调用：`write` 和 `exit`，并在终端中输出一条彩色字符串，然后退出程序。

这条汇编指令 `movq $a2, %rsi` 是 x86-64 架构中的一条指令，用于将一个立即数（即立即数常量）赋值给寄存器 `%rsi`。让我们逐步解释它：

- `movq`: 这是汇编指令的名称，表示将数据移动（move）到目标操作数。在 x86-64 汇编中，`movq` 通常用于操作 64 位数据。

- `$a2`: `$` 符号表示其后是一个立即数，即直接的常数值。

- `%rsi`: 这是目标操作数，表示目标寄存器。在 x86-64 汇编中，`%rsi` 是一个通用寄存器，用于存储数据或地址。

因此，`movq $a2, %rsi` 指令的作用是将立即数 `$a2` 的值加载到 `%rsi` 寄存器中。

### 逐行解释：

#### 1. `#include <sys/syscall.h>`
- 这一行是包含 **C 语言系统调用常量** 的头文件，`sys/syscall.h` 定义了系统调用的编号（如 `SYS_write`, `SYS_exit` 等），这些编号对应内核提供的系统调用。

#### 3. `#define syscall3(id, a1, a2, a3)`
这是一个宏定义，用来简化通过汇编指令调用系统调用的过程。它定义了具有 3 个参数的系统调用。

```c
#define syscall3(id, a1, a2, a3) \
    movq $SYS_##id, %rax; \
    movq $a1, %rdi; \
    movq $a2, %rsi; \
    movq $a3, %rdx; \
    syscall
```

**解释：**
- `movq $SYS_##id, %rax;`：将系统调用编号加载到寄存器 **RAX** 中。`##` 是连接符，表示将 `SYS_` 和 `id` 拼接起来生成系统调用编号。
- `movq $a1, %rdi;`：将第一个参数 **a1** 加载到寄存器 **RDI** 中。
- `movq $a2, %rsi;`：将第二个参数 **a2** 加载到寄存器 **RSI** 中。
- `movq $a3, %rdx;`：将第三个参数 **a3** 加载到寄存器 **RDX** 中。
- `syscall`：执行 `syscall` 指令，它会将寄存器中的数据作为系统调用的输入，进行系统调用。



#### 6. `.globl _start`
- 这一行告诉汇编器，`_start` 是全局符号，表示程序的入口点。程序从这里开始执行。通常，`_start` 是一个程序的起始点，被操作系统加载器调用。


#### 8. `syscall3(write, 1, addr1, addr2 - addr1)`
- 这里调用 `syscall3` 宏，使用 `write` 系统调用。
  - **`write`**：系统调用编号。它的编号会自动通过宏展开为 `SYS_write`。
  - **1**：第一个参数，表示文件描述符，`1` 代表标准输出（即向屏幕打印输出）。
  - **`addr1`**：第二个参数，表示要写入的数据的内存地址。
  - **`addr2 - addr1`**：第三个参数，表示要写入数据的长度，即从 `addr1` 到 `addr2` 之间的字节数。

  这段代码的作用是输出从 `addr1` 到 `addr2` 之间存储的字符串（即 "Hello, OS World"）到标准输出。

#### 9. `syscall1(exit, 101)`
- 这里调用 `exit` 系统调用，它只需要一个参数。
  - **101**：这是程序的退出状态码，表示程序将以退出码 101 结束执行。

#### 10. `addr1:`
- 这是一个 **标签**，表示该内存位置存储一个字符串数据。后面的 `.ascii` 指令将在 `addr1` 处存储 ASCII 编码的字符串。

#### 11. `.ascii "\033[01;31mHello, OS World\033[0m\n"`
- **`.ascii`**：这是汇编指令，表示将后面的字符串以 ASCII 格式存储到内存中。
- **字符串**：这个字符串包含 ANSI 转义序列，用于在终端中显示带有颜色的文本。
  - `\033[01;31m`：这是 ANSI 转义序列，表示设置文本颜色为红色。
  - `Hello, OS World`：要显示的文本。
  - `\033[0m`：重置颜色设置，使后续输出恢复默认颜色。
  - `\n`：表示换行符。

#### 12. `addr2:`
- 这是一个 **标签**，表示字符串结束的位置。它的主要作用是与 `addr1` 一起用于计算字符串的长度。

### 整体流程
1. 程序从 `_start` 标签开始执行。
2. 调用 `write` 系统调用，将 "Hello, OS World" 以红色输出到终端。
3. 调用 `exit` 系统调用，以退出码 `101` 结束程序。

**输出效果**：
程序会在终端输出以下内容，并使用红色字体：
```
Hello, OS World
```

---

宏定义是在编程中使用预处理指令 `#define` 来定义一些常量或代码块，以便在整个代码中多次使用，从而减少重复编写和提高代码可维护性。宏可以有不同的形式，主要分为 **对象宏** 和 **函数宏**。

### 1. **对象宏定义**
对象宏用于定义 **常量**，通常是一些数值、字符串或表达式。

#### 语法：
```c
#define NAME value
```

#### 示例：
```c
#define PI 3.14159
#define MAX_BUFFER_SIZE 1024
#define GREETING "Hello, World!"
```


### 2. **函数宏定义**
函数宏用于定义带参数的代码块，类似于函数。参数的替换在预处理阶段完成。

#### 语法：
```c
#define MACRO_NAME(parameter1, parameter2, ...) expression
```

#### 示例：
```c
#define SQUARE(x) ((x) * (x))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define PRINT_MESSAGE(msg) printf("Message: %s\n", msg)
```

**解释**：
- `SQUARE(x)`：这是一个简单的宏，用于计算 `x` 的平方。在代码中调用时，`SQUARE(5)` 会被替换为 `((5) * (5))`。
- `MAX(a, b)`：这个宏返回两个值中较大的一个。比如 `MAX(3, 5)` 会被替换为 `((3) > (5) ? (3) : (5))`。
- `PRINT_MESSAGE(msg)`：这是一个带有参数 `msg` 的宏，会被替换为 `printf("Message: %s\n", msg)`。

### 3. **带续行符的宏定义**
如果宏定义的表达式很长，可以使用续行符 `\` 来将宏定义分成多行，以提高可读性。

#### 语法：
```c
#define MACRO_NAME(parameter1, parameter2, ...) \
    statement1; \
    statement2; \
    ...
```

#### 示例：
```c
#define PRINT_VALUES(a, b) \
    printf("The value of a: %d\n", a); \
    printf("The value of b: %d\n", b)
```

**解释**：
- `PRINT_VALUES(a, b)`：这个宏会打印两个参数的值，宏定义使用续行符 `\` 将语句分成多行。在代码中调用时，`PRINT_VALUES(10, 20)` 会生成两行 `printf` 语句。

### 4. **带条件逻辑的宏定义**
宏定义还可以与条件编译结合使用，以定义根据不同的条件使用不同的代码。

#### 示例：
```c
#if !defined(PI)
    #define PI 3.14159
#endif
```

**解释**：
- `#if !defined(PI)`：检查是否未定义 `PI`，如果没有定义，则定义 `PI` 为 `3.14159`。这样可以避免重复定义同一个宏。

### 5. **宏中的注意事项**
使用宏时，有几个常见的陷阱和注意事项：

- **括号保护**：在函数宏定义中，应该用括号将每个参数和整个表达式括起来，避免由于运算符优先级问题导致的错误。
  
  示例：
  ```c
  #define SQUARE(x) ((x) * (x))
  ```

  如果不加括号，`SQUARE(1 + 2)` 会被替换为 `1 + 2 * 1 + 2`，按照运算符优先级，这相当于 `1 + (2 * 1) + 2`，结果将是 `5`，而不是预期的 `9`。

- **重复求值问题**：如果函数宏的参数是表达式，则每次宏展开时，参数会被重复计算。
  
  示例：
  ```c
  #define SQUARE(x) ((x) * (x))
  int y = 5;
  int z = SQUARE(y++);  // z = (y++ * y++) 会导致 y 被递增两次
  ```

  这可能会产生意外的副作用。为避免这种情况，尽量不要在宏参数中传入带有副作用的表达式（如 `++` 或 `--`）。

### 6. **宏替换流程**
在编译时，宏定义是在 **预处理阶段** 展开的，这意味着编译器在正式编译代码之前，会用宏的定义内容替换代码中出现的宏。

#### 宏的展开过程：
```c
#define PI 3.14159
#define SQUARE(x) ((x) * (x))

int main() {
    float area = PI * SQUARE(5);
    return 0;
}
```
在预处理阶段，上述代码会被替换为：
```c
int main() {
    float area = 3.14159 * ((5) * (5));
    return 0;
}
```

### 宏定义的优点和缺点

#### 优点：
1. **提高代码复用性**：宏定义允许你重用常量或代码片段，避免重复编写代码。
2. **减少计算开销**：如果某些计算是静态的（如常量），宏可以在编译时展开，避免运行时的计算开销。
3. **提高代码可维护性**：如果一个常量或表达式需要改变，你只需要修改宏定义即可，不需要修改每一处代码。

#### 缺点：
1. **调试困难**：由于宏在预处理阶段展开，错误或调试信息可能不直接指向宏定义所在的位置，而是展开后的代码位置。
2. **重复计算副作用**：如果宏参数是带有副作用的表达式，宏会导致重复求值，从而产生意外的副作用。

---
在 **x86-64 (64-bit)** 架构下，系统调用的实现与 32 位架构不同。64 位架构使用的是 `syscall` 指令来执行系统调用，而不是 32 位架构的 `int 0x80` 中断。系统调用的参数通过特定的寄存器传递，而不是堆栈或其他方式。64 位架构允许更高效地处理数据和系统调用，因为它提供了更多的寄存器和更大的寻址空间。

### **x86-64 系统调用机制**

在 x86-64 Linux 中，系统调用的参数通过以下寄存器传递：

- **RAX**：系统调用号。
- **RDI**：第 1 个参数。
- **RSI**：第 2 个参数。
- **RDX**：第 3 个参数。
- **R10**：第 4 个参数。
- **R8**：第 5 个参数。
- **R9**：第 6 个参数。
- **RAX**：返回值存放在 **RAX** 中。

### **x86-64 系统调用步骤**

- 将系统调用号放入 **RAX** 寄存器。
- 将所需的参数依次放入 **RDI**, **RSI**, **RDX**, **R10**, **R8**, 和 **R9** 中（根据系统调用需要的参数个数）。
- 执行 `syscall` 指令。
- 系统调用的返回值放入 **RAX** 中。

### 示例：使用 x86-64 汇编实现 `write` 和 `exit` 系统调用

我们将使用 `write` 系统调用向标准输出打印 `"Hello, world!\n"`，并使用 `exit` 系统调用正常退出程序。

#### 汇编代码：

![[Pasted image 20241015234452.png]]

### **逐行解释**：

1. **数据段（section .data）**：
   - `message db "Hello, world!", 0xA`：定义字符串 `"Hello, world!"`，并在最后添加换行符 `0xA`，总长度为 13 字节。

2. **代码段（section .text）**：
   - `global _start`：定义程序的入口点为 `_start`。

3. **系统调用 `write`**：
   - `mov rax, 1`：将系统调用号 1（`sys_write`）放入 **RAX** 寄存器中。
   - `mov rdi, 1`：将文件描述符 `1`（表示标准输出 stdout）放入 **RDI** 寄存器中。
   - `mov rsi, message`：将字符串的地址（`message`）放入 **RSI** 寄存器中。
   - `mov rdx, 13`：将要写入的字节数（13 字节）放入 **RDX** 寄存器中。
   - `syscall`：执行系统调用，向标准输出写入 `"Hello, world!\n"`。

4. **系统调用 `exit`**：
   - `mov rax, 60`：将系统调用号 60（`sys_exit`）放入 **RAX** 寄存器中。
   - `xor rdi, rdi`：将退出状态码 `0` 放入 **RDI**，表示正常退出。
   - `syscall`：执行系统调用，退出程序。

### **编译和运行这个程序**

你可以使用 `nasm` 来编译这个汇编程序，并用 `ld` 链接生成可执行文件。具体步骤如下：

1. 将上述汇编代码保存到一个文件中，比如 `hello.asm`。
2. 使用 `nasm` 编译为目标文件：

   ```bash
   nasm -f elf64 hello.asm -o hello.o
   ```

3. 使用 `ld` 链接生成可执行文件：

   ```bash
   ld hello.o -o hello
   ```

4. 运行可执行文件：

   ```bash
   ./hello
   ```

运行后，终端将输出 `"Hello, world!"`，并且程序将正常退出。

### 小结

- 在 **x86-64** 架构下，系统调用通过 `syscall` 指令执行，参数通过寄存器传递，返回值也通过 **RAX** 传递。
- 使用 `sys_write` 可以向标准输出打印内容，使用 `sys_exit` 退出程序。
- 与 32 位架构不同的是，64 位架构中不再使用 `int 0x80` 中断，而是使用 `syscall` 指令来更高效地处理系统调用。


---
要将 `strace` 命令产生的输出导出到一个文件中，可以使用输出重定向。

### 方法一：直接重定向输出

```bash
strace <command> > output.txt 2>&1
```

- `strace <command>`：运行 `strace` 监视的命令。
- `> output.txt`：将标准输出（stdout）重定向到文件 `output.txt`。
- `2>&1`：将标准错误（stderr）也重定向到标准输出，以便所有输出都写入文件中。

### 方法二：使用 `-o` 选项

`strace` 提供了一个 `-o` 选项，直接将输出写入指定的文件：

```bash
strace -o output.txt <command>
```

这样可以将所有的 `strace` 输出自动保存到 `output.txt` 文件中，而不需要重定向。



