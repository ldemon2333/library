# x86_64 汇编风格
x86_64 架构下的 CPU 有两种主要的汇编风格：Intel 风格和AT&T 风格。

这里`风格`是指汇编代码的书写语法，它们通过汇编器汇编生成的二进制指令是一样的，因为最终都要在`x86_64`架构下的`CPU`下运行。

支持`Intel`汇编风格的操作系统主要是`Windows`，支持`AT&T`汇编风格的操作系统主要是`Unix`以及`Unix-like`操作系统，这主要是因为`AT&T`贝尔实验室发明了`Unix`操作系统。

本文主要介绍`AT&T`汇编的基本语法。

  
# 2 AT&T 汇编
```
// AT&T 汇编风格
mnemonic source, destination
//助记符 源操作数，目的操作数
```

从左向右执行，Intel 汇编是从右往作左

```
// Intel 汇编风格 
mnemonic destination, source
```

AT&T 寄存器前面有一个 %

`AT&T`汇编中，字面量前面都有一个`$`，比如:
```
mov $100, %ax
```

上面汇编代码将字面量`100`移动到寄存器`ax`。

`AT&T`的内存寻址方式通用语法为:

```
segment-override:signed-offset(base,index,scale)
```

`segment-override`是段地址。

`signed-offset(base, index, scale)`是段内偏移，计算方式为`base + signed-offset + index * scale`。

通过段地址:段内偏移，就可以定位到具体的内存。

![[Pasted image 20241120184659.png]]

```
100					    // 访问 当前段:100 处内存
%es:100					// 访问 es:100 处内存
(%eax)					// 访问 当前段:eax 处内存
(%eax,%ebx)				// 访问 当前段:(eax+ebx) 处内存
(%ecx,%ebx,2)		    // 访问 当前段:(ecx+ebx*2) 处内存
(,%ebx,2)				// 访问 当前段:(ebx*2) 处内存
-10(%eax)				// 访问 当前段:(eax-10) 处内存
%ds:-10(%ebp)		    // 访问 ds:(ebp-10) 处内存
```

假设有如下`AT&T`汇编代码:

```
mov $100, %es:(%eax)
```
上面代码将字面量`100`移动到内存地址`es:eax`处，但是`100`到底在内存中占用多少字节呢?

如果占用`1`字节，那么`es:eax`内存地址存储的就会是`0x64`。

如果占用`2`字节，那么`es:eax`内存地址存储的就会是`0x00` `0x64`。

为了做出区分，`AT&T`汇编在助记符后面添加后缀进行区分:

后缀`b`代表`1`个字节；

后缀`w`代表`2`个字节；

后缀`l`代表`4`个字节；

后缀`q`代表`8`个字节。

那么，如果上面例子`100`占用`4`个字节，那么正确的写法就是:

```
movl $100, %es:(%eax)
```

`AT&T`汇编中控制转移包括`jump`、`call`、`ret`。

如果代码的转移在相同的代码段，那么就是近(`Near`)转移。

如果代码转移到不同的代码段，那么就是远(`Far`)转移。在远转移的情况下，助记符前面需要加上前缀`l`，比如`ljump`、`lcall`、`lret`。

![[Pasted image 20241120185242.png]]


转移指令中目的内存地址表示可以分为 `label`、寄存器、直接内存地址、段地址-段内偏移 这`4`种形式:

```
// 1. label 形式
label1:
	.
	.
  jmp	label1 // near 跳转
  
// 2. 寄存器形式
jmp	*%eax			// near 跳转，跳转到 eax 指向的地址
jmp	*%ecx			// near 跳转，跳转到 ecx 指向的地址
jmp	*(%eax)			// near 跳转，先取出 eax 指向内存处的值，然后跳转到这个地址
call	*(%ebx)		// near 调用，先取出 ebx 指向内存处的值，然后转移到这个地址
ljmp	*(%eax)		// far 跳转，先取出 eax 指向内存处的值，然后跳转到这个地址
lcall	*(%ebx)		// far 调用，先取出 ebx 指向内存处的值，然后转移到这个地址

// 3. 直接内存地址
jmp	*100		   // near 跳转，跳转到内存地址 100
call	*100	  // near 调用，转移到内存地址 100
ljmp	*100	  // far 跳转，跳转到内存地址 100
lcall	*100	 // far 调用，转移到内存地址 100

// 4. 段地址-段内偏移
jmp	$0x10, $0x100000 // 跳转到地址 0x10:0x100000 出

```

从上面例子可以看到，除了第`1`种和第`4`种形式，其他形式地址前都需要加一个`*`。


# x86 寄存器
![[Pasted image 20241120195838.png]]


# x64 寄存器
![[Pasted image 20241120195914.png]]

# 整体介绍
x86的通用寄存器有`eax、ebx、ecx、edx、edi、esi`

x86的特殊寄存器有`ebp、esp、eip、eflags`。eip是程序计数器。eflags保存计算过程中产生的标记位，包括进位、溢出、零、负数等标记，在x86的文档中，这几个标记位分别称为CF、OF、ZF、SF。ebp和esp用于维护函数调用过程的栈帧（stack frame）。

一般情况下，esp指向栈顶（低地址），而ebp为栈帧（stack frame）指针，指向当前调用栈的底（高地址）。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着函数运行所需要的各种信息。对esp做减法，就是在扩展栈空间。

由于x86_64架构惊人的后向兼容性（也许这种兼容性单纯从技术上看并无必要），同一个寄存器，我们可以使用其中的8bit、16bit、32bit、64bit，以ax寄存器为例，分别是ah/al、ax、eax、rax，如下图所示：

![[Pasted image 20241120200250.png]]

- 前缀R，表示64位寄存器。例如RAX。
- 前缀E，表示32位寄存器。例如EAX。
- 后缀L，表示寄存器的低8位。
- 后缀H，表示寄存器的9~16位，高8位。

x64中的寄存器，都用`r`开头，表示64bit，他们分别是`rax，rbx，rcx，rdx，rsi，rdi，rbp，rsp`，另外，在x64中还新增了`r8 -- r15`，他们作为普通寄存器存在，可以任意使用。



