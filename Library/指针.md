https://coolshell.cn/articles/8990.html
二级指针奇淫技巧

# 1. 细说指针
指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。让我们分别说明。
```
(1)int*ptr;
(2)char*ptr;
(3)int**ptr;
(4)int(*ptr)[3];
(5)int*(*ptr)[4];
```

## 1.1 指针的类型
从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。
(1)int\*ptr;//指针的类型是int*  
(2)char\*ptr;//指针的类型是char*  
(3)int** ptr;//指针的类型是int**  
(4)int(\*ptr)[3];//指针的类型是int(\*)[3]  
(5)int* (\*ptr)[4];//指针的类型是int*(\*)[4]

## 1.2 指针所指向的类型
当你通过指针来访问所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当作什么来看待。从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符\*去掉，剩下的就是指针所指向的类型。例如
(1)int\*ptr; //指针所指向的类型是int  
(2)char\*ptr; //指针所指向的的类型是char  
(3)int\*\*ptr; //指针所指向的的类型是int*  
(4)int(\*ptr)[3]; //指针所指向的的类型是int()[3]  
(5)int*(\*ptr)[4]; //指针所指向的的类型是int*()[4]

## 1.3 指针的值
指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32为程序里，所有类型的指针的值都是一个32为整数，因为32位程序里内存地址全都是32位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。

**以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？（重点注意）**

## 1.4 指针本身所占据的内存区
指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。

# 2.指针的算术运算
指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。例如：  
例二：
```
char a[20];
int *ptr=(int *)a; //强制类型转换并不会改变a 的类型
ptr++;
```
在上例中，指针ptr的类型是int \*，它指向的类型是int，它被初始化为指向整型变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr 的值加上了sizeof(int)，在32 位程序中，是被加上了4，因为在32 位程序中，int 占4 个字节。由于地址是用字节做单位的，故ptr 所指向的地址由原来的变量a 的地址向高地址方向增加了4 个字节。由于char 类型的长度是一个字节，所以，原来ptr 是指向数组a 的第0 号单元开始的四个字节，此时指向了数组a 中从第4 号单元开始的四个字节。我们可以用一个指针和一个循环来遍历一个数组，看例子：  
例三：
```
int array[20]={0};
int *ptr=array;
for(i=0;i<20;i++)
{
    (*ptr)++;
    ptr++；
}
```
这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1 个单元，所以每次循环都能访问数组的下一个单元。
再看例子：  
例四：
```
char a[20]="You_are_a_girl";
int *ptr=(int *)a;
ptr+=5;
```
在这个例子中，ptr 被加上了5，编译器是这样处理的：将指针ptr 的值加上5 乘sizeof(int)，在32 位程序中就是加上了5 乘4=20。由于地址的单位是字节，故现在的ptr 所指向的地址比起加5 后的ptr 所指向的地址来说，向高地址方向移动了20 个字节。  
在这个例子中，没加5 前的ptr 指向数组a 的第0 号单元开始的四个字节，加5 后，ptr 已经指向了数组a 的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。如果上例中，ptr 是被减去5，那么处理过程大同小异，只不过ptr 的值是被减去5 乘sizeof(int)，新的ptr 指向的地址将比原来的ptr 所指向的地址向低地址方向移动了20 个字节。  

在 C 语言中，**数组名并不是一个真正的指针，而是一个常量表达式，它在绝大多数情况下会被转换为指向数组首元素的指针**。以下是详细说明：

---

### 数组名的本质

1. **数组名是常量地址**：
    
    - 数组名表示数组的起始地址，即首元素的地址。
    - 它并不是一个指针变量，因为不能对数组名赋值（它是常量，不可修改）。
    
    示例：
    
    ```c
    int arr[5] = {1, 2, 3, 4, 5};
    int *ptr = arr;      // OK: 数组名表示首元素地址
    arr = ptr;           // 错误: 数组名是常量，不能赋值
    ```
    
2. **隐式转换为指针**： 在绝大多数上下文中，数组名会隐式转换为指向数组首元素的指针。
    
    ```c
    int arr[5] = {1, 2, 3, 4, 5};
    printf("%p\n", arr);       // 输出首元素地址
    printf("%p\n", &arr[0]);   // 等价于 arr
    ```
    
3. **不转换为指针的情况**： 在以下情况下，数组名不会转换为指针：
    
    - 作为 `sizeof` 运算符的操作数时，表示整个数组的大小。
    - 作为一元 `&` 运算符的操作数时，表示整个数组的地址。
    
    ```c
    int arr[5] = {1, 2, 3, 4, 5};
    printf("%zu\n", sizeof(arr));  // 数组的总字节大小，假设每个元素 4 字节，输出 20
    printf("%p\n", &arr);          // 数组的整体地址
    ```
    

---

### 数组名与指针的区别

|特性|数组名|指针变量|
|---|---|---|
|**本质**|常量表达式，表示数组首地址|变量，存储内存地址|
|**可修改性**|不可修改|可以通过赋值修改指向|
|**大小**|`sizeof(arr)` 是数组的大小|`sizeof(ptr)` 是指针变量的大小|
|**运算**|支持加法运算（隐式转换为指针）|支持指针算术|
|**用途**|表示数组，访问其元素|动态指向任意内存地址|

---

### 示例：区别数组名与指针

```c
#include <stdio.h>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int *ptr = arr;

    printf("sizeof(arr) = %zu\n", sizeof(arr)); // 数组大小 (20 bytes if int = 4 bytes)
    printf("sizeof(ptr) = %zu\n", sizeof(ptr)); // 指针大小 (4 or 8 bytes depending on architecture)

    printf("arr = %p\n", arr);    // 数组首地址
    printf("&arr = %p\n", &arr);  // 数组整体地址，可能相同，但语义不同
    printf("ptr = %p\n", ptr);    // 指针指向数组首地址

    return 0;
}
```

**输出（假设 64 位系统，`sizeof(int) = 4`）：**

```
sizeof(arr) = 20
sizeof(ptr) = 8
arr = 0x7ffee57d18a0
&arr = 0x7ffee57d18a0
ptr = 0x7ffee57d18a0
```

### 总结

- 数组名是一个常量，通常会被隐式转换为指针（指向首元素）。
- 数组名不是一个真正的指针变量，不能修改其值。
- 在一些特殊情况下（如 `sizeof` 和 `&` 运算），数组名表示整个数组。


在 C 语言中，指针与二维数组的关系稍微复杂一些，因为二维数组是以行和列形式存储的，而指针通常被用来访问数组的内存地址。以下是关于指针与二维数组的详细说明：

---

### 二维数组的内存布局

二维数组在内存中是**连续存储的**，按行优先存储（Row-Major Order）。

**示例：**

```c
int arr[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

**内存布局：**

```
地址（假设起始地址为 0x100）：内容
0x100 -> 1
0x104 -> 2
0x108 -> 3
0x10C -> 4
0x110 -> 5
0x114 -> 6
```

---

### 数组名与指针的关系

1. **二维数组名**：
    
    - `arr` 表示二维数组的首地址，即第一行的地址（`arr` 等价于 `&arr[0]`）。
    - `arr[0]` 表示第一行的首地址，即 `arr[0]` 等价于 `&arr[0][0]`。
2. **访问方式**：
    
    - `arr[i][j]` 等价于 `*(*(arr + i) + j)`。
3. **类型对应关系**：
    
    - `arr` 的类型是 `int (*)[3]`，表示指向一个包含 3 个 `int` 的数组的指针。
    - `arr[i]` 的类型是 `int*`，表示指向行首元素的指针。
    - `&arr[i][j]` 的类型是 `int*`，表示指向单个元素的指针。

---

### 使用指针访问二维数组

1. **通过数组名访问**：
    
    ```c
    int arr[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };
    
    printf("%d\n", arr[1][2]);      // 输出 6
    printf("%d\n", *(*(arr + 1) + 2)); // 输出 6
    ```
    
2. **通过指针访问**：
    
    ```c
    int arr[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };
    int (*p)[3] = arr; // 定义一个指向二维数组的指针
    
    printf("%d\n", p[1][2]);        // 输出 6
    printf("%d\n", *(*(p + 1) + 2)); // 输出 6
    ```
    
3. **通过指针算术操作访问**：
    
    ```c
    int arr[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };
    int *ptr = &arr[0][0]; // 指向二维数组的首元素
    
    for (int i = 0; i < 6; i++) {
        printf("%d ", *(ptr + i)); // 顺序输出所有元素
    }
    // 输出：1 2 3 4 5 6
    ```
    

---

### 指针与二维数组的区别

|特性|二维数组|指针|
|---|---|---|
|**内存分配**|编译时确定，固定大小|可以动态分配，灵活性高|
|**数组名**|是指向第一行的指针|指针变量可以指向任意内存地址|
|**访问元素**|使用 `arr[i][j]` 形式|需要通过指针算术进行访问|
|**类型**|`int (*)[列数]`，表示指向行的指针|`int*` 或 `int**`，根据上下文变化|

---

### 函数参数传递

二维数组作为函数参数时，可以通过指针传递，但需要指定列数。

#### 示例 1：直接传递数组名

```c
void printArray(int arr[2][3]) {
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", arr[i][j]);
        }
    }
}

int main() {
    int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
    printArray(arr); // 数组名传递
    return 0;
}
```

#### 示例 2：使用指针参数

```c
void printArray(int (*arr)[3], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", arr[i][j]);
        }
    }
}

int main() {
    int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
    printArray(arr, 2); // 数组名传递
    return 0;
}
```

---

### 总结

1. **二维数组名**是指向第一行的指针。
2. **访问二维数组的方式**：
    - 使用下标表示法：`arr[i][j]`
    - 使用指针表示法：`*(*(arr + i) + j)`
3. **指针的灵活性**允许指向二维数组的任意位置。
4. **函数参数传递时**需要指定列数。


`argv[1]` 指向一个 `char*`，而 **`char*` 并不是字符串数组**。  
在 C 语言中，`char*` 是指向字符串的指针，而字符串本质上是一块以 **`'\0'`（空字符）** 结尾的字符数组。

---

### 理解 `char*` 和字符串数组的关系

1. **`char*` 的本质**：
    
    - `char*` 是一个指针，指向内存中某个字符的地址。
    - 如果该地址指向的是以 `'\0'` 结尾的一串字符，则我们通常称之为字符串。
    
    示例：
    
    ```c
    char *str = "hello";  // 指针指向字符串字面量
    ```
    
    在内存中的布局：
    
    ```
    str -> 指向 "hello\0"
    ```
    
2. **字符串数组的本质**：
    
    - 字符串数组是存储字符的数组，其末尾通常以 `'\0'` 结束。
    - 数组本身占用一块连续的内存。
    
    示例：
    
    ```c
    char str[] = "hello"; // 字符数组
    ```
    
    在内存中的布局：
    
    ```
    str[0] -> 'h'
    str[1] -> 'e'
    str[2] -> 'l'
    str[3] -> 'l'
    str[4] -> 'o'
    str[5] -> '\0'
    ```
    

---

### 区别 `char*` 和字符串数组

|特性|`char*`|字符串数组|
|---|---|---|
|**存储方式**|指针指向某块内存|数组直接存储字符串内容|
|**是否可修改**|指针可以重新指向其他内存|数组固定（但内容可修改）|
|**内存大小**|大小固定为指针大小（4/8 字节）|由数组长度决定|
|**适用场景**|适合动态操作字符串|适合存储固定大小的字符串|

示例代码对比：

```c
#include <stdio.h>
#include <string.h>

int main() {
    char *p = "hello";        // 指针指向字符串字面量，存储在只读区域
    char arr[] = "hello";     // 字符数组，存储在栈区

    printf("%s\n", p);        // 输出 hello
    printf("%s\n", arr);      // 输出 hello

    // 修改内容
    // p[0] = 'H';            // 错误：指针指向的内容不可修改（只读区域）
    arr[0] = 'H';             // 正确：修改字符数组内容
    printf("%s\n", arr);      // 输出 Hello

    // 重新赋值
    p = "world";              // 正确：指针可以指向其他字符串
    // arr = "world";         // 错误：数组名是常量，不可修改

    return 0;
}
```

---

### 回到问题：`argv[1]` 是什么？

1. **`argv[1]` 的含义**：
    
    - `argv[1]` 是一个 `char*`，它指向命令行传递的第二个参数字符串的首地址。
    - 这个字符串是由系统分配的，通常是以 `'\0'` 结尾的一段内存。
2. **它不是字符串数组**：
    
    - 虽然 `argv[1]` 指向一个字符串，但它本身是一个指针，而不是字符数组。
3. **示例验证**：
    
    ```c
    #include <stdio.h>
    
    int main(int argc, char **argv) {
        if (argc > 1) {
            printf("argv[1]: %s\n", argv[1]);    // 输出第一个参数字符串
            printf("argv[1][0]: %c\n", argv[1][0]); // 输出第一个字符
        }
        return 0;
    }
    ```
    
    **运行命令：**
    
    ```bash
    ./program hello
    ```
    
    **输出：**
    
    ```
    argv[1]: hello
    argv[1][0]: h
    ```
    

---

### 总结

- **`argv[1]` 是 `char*`，表示一个指向字符串的指针，而不是字符串数组。**
- **`char*` 和字符串数组的区别**在于内存管理方式不同：
    - `char*` 是指针，可以动态指向不同的字符串。
    - 字符串数组是固定大小的内存块，直接存储字符串内容。


在 C 语言中，`char*` 是一个指针类型，它可以指向一个字符，也可以指向一个字符串（即以 `'\0'` 结尾的字符数组）。**如果你只想定义一个指向单个字符的指针，也可以使用 `char*`，关键在于指针所指向的内容。**

---

### 定义指向字符的指针

#### 1. 基本定义

```c
char c = 'A';      // 定义一个字符
char *p = &c;      // 定义一个指向字符的指针，指向字符变量 c
```

#### 2. 访问指针指向的字符

```c
#include <stdio.h>

int main() {
    char c = 'A';      // 定义一个字符
    char *p = &c;      // 定义一个指向字符的指针

    printf("Character: %c\n", *p);  // 使用 *p 解引用，获取指向的字符
    printf("Address: %p\n", p);     // 打印指针的地址
    return 0;
}
```

**输出示例：**

```
Character: A
Address: 0x7ffee3b1e44f (示例地址)
```

---

### 修改指针指向的字符

你可以通过指针修改字符的值：

```c
#include <stdio.h>

int main() {
    char c = 'A';
    char *p = &c;

    printf("Before: %c\n", c);  // 输出 A
    *p = 'B';                  // 修改指针指向的值
    printf("After: %c\n", c);   // 输出 B

    return 0;
}
```

---

### 指向字符与字符串的区别

- **指向单个字符：**
    
    ```c
    char c = 'A';
    char *p = &c;  // 指针 p 指向单个字符
    ```
    
- **指向字符串：**
    
    ```c
    char *str = "Hello";  // 指针 str 指向字符串 "Hello"
    ```
    

|特性|指向字符|指向字符串|
|---|---|---|
|**指向内容**|单个字符|以 `'\0'` 结尾的字符数组|
|**解引用结果**|单个字符（如 `'A'`）|字符串的第一个字符（如 `'H'`）|
|**内存布局**|单个字符的地址|字符串字面量的首地址|

---

### 注意事项

1. **字符指针的初始化**：
    
    ```c
    char *p; // 声明一个指针，但未初始化
    char c = 'A';
    p = &c;  // 初始化指针，指向字符 c
    ```
    
2. **指针的指向**： 指针是否指向单个字符还是字符串，取决于它的初始化方式和解引用后的内容：
    
    - 指向单个字符：`char *p = &c;`，`*p` 是一个字符。
    - 指向字符串：`char *p = "Hello";`，`*p` 是字符串的第一个字符。
3. **操作字符串可能会误解为字符**： 如果未正确区分指针的内容，可能会产生混淆。例如：
    
    ```c
    char *p = "Hello";
    printf("%c\n", *p);  // 输出 H，表示字符串的第一个字符
    ```
    
字符是单引号，字符串是双引号。


`leaveq` 是 x86-64 架构中汇编语言的一条指令，通常与函数的返回过程相关。它是 `leave` 指令在 64 位模式下的版本（`q` 表示 quadword，即 64 位操作）。

---

### `leaveq` 的功能

`leaveq` 的作用是帮助函数恢复调用者的栈帧，在函数返回时清理栈空间。具体来说，它完成了以下两步操作：

1. **恢复栈指针** (`rsp`)： 将栈指针 `rsp` 设置为基址指针 `rbp` 的值，恢复栈顶到函数调用前的状态。
    
    ```assembly
    mov rsp, rbp
    ```
    
2. **弹出基址指针** (`rbp`)： 从栈顶弹出值到基址指针 `rbp`，恢复调用者的基址指针。
    
    ```assembly
    pop rbp
    ```
    

这两步操作可以手动拆分写成：

```assembly
mov rsp, rbp
pop rbp
```

但使用 `leaveq` 是更简洁的方式。

---

### 使用场景

`leaveq` 指令通常出现在函数的结束部分，与 `ret`（返回）指令连用。例如：

```assembly
leaveq
ret
```

这段代码完成了：

1. 恢复栈帧。
2. 返回到调用者的地址。

---

### 栈帧恢复的背景

在调用函数时，函数通常会建立一个栈帧，典型过程如下：

1. **保存调用者的 `rbp`**： 将调用者的基址指针 `rbp` 保存到栈上（通过 `push rbp`）。
2. **设置新的栈帧**： 将当前的栈指针 `rsp` 赋值给 `rbp`，建立新的基址。

这对应于以下指令：

```assembly
push rbp       ; 保存调用者的 rbp
mov rbp, rsp   ; 建立当前函数的栈帧
```

在函数结束时，需要逆向操作恢复栈帧，这正是 `leaveq` 的作用。

---

### 示例

#### 函数使用 `leaveq` 的完整例子

C 语言代码：

```c
int add(int a, int b) {
    return a + b;
}
```

对应的汇编代码（简化版）：

```assembly
add:
    push rbp         ; 保存调用者的基址指针
    mov rbp, rsp     ; 建立新的栈帧
    mov eax, edi     ; 将参数 a (edi) 赋值到 eax
    add eax, esi     ; 将参数 b (esi) 加到 eax
    leaveq           ; 恢复栈帧 (mov rsp, rbp + pop rbp)
    ret              ; 返回到调用者
```

---

### `leaveq` 的作用总结

- **清理当前栈帧**：恢复 `rsp` 和 `rbp`。
- **常用于函数返回过程**，简化栈帧管理。
- 是以下两条指令的简写：
    
    ```assembly
    mov rsp, rbp
    pop rbp
    ```




