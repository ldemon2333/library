![[Pasted image 20250716224136.png]]

---

## Git Pull 教学

`git pull` 是 Git 中一个非常常用的命令，用于从远程仓库获取最新的更改并将其合并到你当前的分支。简单来说，它就是把别人提交的代码同步到你本地。

### `git pull` 的基本用法

最基本的 `git pull` 命令是：

```
git pull
```

当你运行这个命令时，Git 会做两件事：

1. **`git fetch`**: 从你当前分支所跟踪的远程仓库（通常是 `origin`）下载最新的提交和引用（比如分支信息），但不会修改你本地的工作目录。这些下载下来的内容会存储在本地的一个隐藏区域。
    
2. **`git merge`**: 将 `git fetch` 下载下来的远程分支内容合并到你当前所在的本地分支。如果远程分支有你本地没有的提交，这些提交就会被合并进来。
    

### 常用场景和选项

#### 1. 拉取特定远程分支到当前本地分支

如果你想从一个特定的远程仓库的特定分支拉取更新，并将其合并到你当前的本地分支，可以使用：

```
git pull <远程仓库名> <远程分支名>
```

例如，从 `origin` 远程仓库的 `main` 分支拉取并合并到你当前分支：

```
git pull origin main
```

#### 2. 配置跟踪分支（Upstream Branch）

当你从远程仓库克隆一个项目时，本地分支通常会自动设置一个跟踪分支（upstream branch）。这意味着当你运行 `git pull` 时，Git 知道应该从哪个远程仓库的哪个分支拉取更新。

你可以使用 `git branch -vv` 命令查看当前本地分支跟踪的远程分支信息。

如果你想手动设置跟踪分支，可以使用 `git branch --set-upstream-to=<远程仓库名>/<远程分支名> <本地分支名>`。例如：

```
git branch --set-upstream-to=origin/main my-local-branch
```

设置好跟踪分支后，你就可以直接使用 `git pull` 而无需指定远程仓库和分支名。

#### 3. 使用 `git pull --rebase`

默认情况下，`git pull` 会执行 `fetch` 后跟着 `merge`。但在某些情况下，你可能希望使用 **rebase** 而不是 **merge** 来整合远程更改。

**`merge` 的特点：**

- 会创建一个新的合并提交（merge commit）。
    
- 保留了完整的提交历史，包括分支的合并点。
    
- 适用于多人协作，因为它清晰地显示了何时何地进行了合并。
    

**`rebase` 的特点：**

- 不会创建新的合并提交。
    
- 它会将你的本地提交“移动”到远程最新提交的**顶部**，从而形成一个更线性、更“干净”的提交历史。
    
- 适用于在将本地更改推送到远程之前，保持提交历史的整洁。
    

要使用 rebase，你可以运行：


```
git pull --rebase
```

或者，你可以通过配置来默认使用 rebase：


```
git config --global pull.rebase true
```

**何时选择 `rebase`？**

- 如果你在本地有一些未推送的提交，并且希望在拉取远程更新后，你的这些提交能出现在远程最新提交的**后面**，形成一条直线般的历史，那么 `rebase` 是一个好选择。
    
- 在你即将推送你的本地分支之前，使用 `rebase` 可以让你的提交历史看起来更整洁，避免不必要的合并提交。
    

**重要提示：**

- **永远不要对已经推送到共享远程仓库的提交进行 rebase。** Rebase 会改变提交的哈希值，如果其他人已经基于这些提交进行了工作，这会引起严重的冲突和混乱。Rebase 应该只用于你本地私有的、尚未共享的提交。
    
- 如果在使用 `rebase` 过程中遇到冲突，你需要解决冲突，然后使用 `git rebase --continue` 继续 rebase 过程。
    

#### 4. 处理冲突

当 `git pull`（无论是 `merge` 还是 `rebase`）尝试将远程更改应用到你的本地分支时，如果远程和本地修改了同一个文件的同一部分，就会发生**合并冲突**。

当冲突发生时，Git 会暂停合并过程，并在冲突文件中用特殊标记（`<<<<<<<`, `=======`, `>>>>>>>`）标识出冲突的部分。你需要手动编辑这些文件，解决冲突，然后：

- 对于 `merge`：
    
    1. 解决冲突。
        
    2. `git add <冲突文件>`
        
    3. `git commit` (Git 会自动为你准备一个合并提交信息)
        
- 对于 `rebase`：
    
    1. 解决冲突。
        
    2. `git add <冲突文件>`
        
    3. `git rebase --continue`
        

在 Git 中，理解 **`main` 分支**和 **`HEAD` 指针**对于有效管理你的代码非常重要。它们各自扮演着不同的角色，但又紧密相关。

---

### `main` 分支

`main` 分支（以前通常叫做 `master` 分支）是 Git 仓库的**默认主分支**。你可以把它想象成项目的“主线”或“稳定版本”：

- **约定俗成的主线：** 当你创建一个新的 Git 仓库时，通常会自动生成一个名为 `main` 的分支（或者 `master`，取决于 Git 版本和配置）。这个分支被认为是项目的“核心”开发线，通常包含着可发布或最稳定的代码版本。
    
- **起始点：** 绝大多数新功能开发或 Bug 修复都会从 `main` 分支派生出新的分支。
    
- **默认检出：** 当你克隆一个 Git 仓库时，Git 默认会检出 `main` 分支到你的本地工作目录。
    
- **名称可配置：** 虽然 `main` 是当前推荐的默认名称，但你可以配置 Git 更改新仓库的默认分支名称，或者更改现有仓库的默认分支名称。
    

简而言之，`main` 分支代表着你项目的“真相”和主要发展路径。

---

### `HEAD` 指针

`HEAD` 是 Git 中一个**特殊的指针**，它总是指向你**当前所在的本地分支**。你可以把它理解为 Git 告诉你“你现在正在哪个分支上工作”：

- **当前工作分支：** 当你在 Git 仓库中切换分支时，`HEAD` 就会随之移动，指向你新切换到的那个分支。
    
- **指向分支的指针：** 更准确地说，`HEAD` **不是直接指向某一个提交（commit）**，而是指向一个**分支引用（branch reference）**。例如，如果 `HEAD` 指向 `main` 分支，那么 `main` 分支本身是一个指向最新提交的指针。所以，`HEAD` 实际上是 `HEAD -> main -> <最新提交>` 这样的关系。
    
- **`.git/HEAD` 文件：** `HEAD` 的信息存储在 `.git/HEAD` 文件中。你可以查看这个文件的内容，通常会看到 `ref: refs/heads/main` 这样的信息，表示 `HEAD` 指向 `refs/heads/main`（即 `main` 分支）。
    
- **分离 `HEAD` 状态：** 在某些情况下（例如，你使用 `git checkout <commit_hash>` 直接检出某个提交而不是分支），`HEAD` 可能会直接指向一个提交哈希值，而不是一个分支。这被称为“分离 HEAD”（detached HEAD）状态。在这种状态下，你所做的任何新提交都不会属于任何一个分支，如果你不创建一个新分支来保存它们，它们可能会在将来被垃圾回收。
    

---

### 两者之间的关系

`main` 和 `HEAD` 的关系可以用一个简单的例子来说明：

1. 当你刚克隆一个仓库时，你通常位于 `main` 分支。此时，`HEAD` 指向 `main` 分支。
    
    - `HEAD` -> `main` -> `最新提交A`
        
2. 你创建一个新分支 `feature` 并切换到它：`git checkout -b feature`。
    
3. 现在，`HEAD` 将指向 `feature` 分支。
    
    - `HEAD` -> `feature` -> `最新提交A` (此时 `feature` 和 `main` 指向同一个提交)
        
4. 你在 `feature` 分支上进行了一些提交。
    
    - `HEAD` -> `feature` -> `最新提交C` (而 `main` 仍然指向 `最新提交A`)
        
5. 你切换回 `main` 分支：`git checkout main`。
    
6. `HEAD` 又会指向 `main` 分支，你的工作目录也会回到 `main` 分支所指向的提交状态。
    
    - `HEAD` -> `main` -> `最新提交A`
        

### 总结

- **`main` 分支**代表着项目的**主线开发路径**，通常包含着稳定或可发布的代码。
    
- **`HEAD` 指针**则始终指向你**当前正在工作的本地分支**。
    

