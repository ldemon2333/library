在 C++ 中，函数参数可以通过三种方式传递：**值传递**、**引用传递** 和 **指针传递**。每种方式有其特定的应用场景和行为特性。你提到的“应用传递”和“指针传递”应该是指 **引用传递** 和 **指针传递**，两者都可以修改原始数据，但其语法和行为有所不同。

### 1. 引用传递（应用传递）

引用传递是通过 `&` 来实现的，它将参数作为一个“别名”传递给函数。函数内对引用的修改会直接影响到原始数据。

#### 特点：

- 不会进行数据的复制，因此效率较高。
- 可以通过引用直接修改外部变量。
- 语法上像直接使用变量一样，方便易懂。

#### 示例代码：

```cpp
#include <iostream>
#include <vector>

void modifyVector(std::vector<int>& nums) {
    nums.push_back(10);  // 修改传入的 nums 向量
}

int main() {
    std::vector<int> nums = {1, 2, 3, 4};

    std::cout << "Before modification: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    modifyVector(nums);  // 传递引用

    std::cout << "After modification: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 输出：

```
Before modification: 1 2 3 4 
After modification: 1 2 3 4 10 
```

### 解释：

- 在 `modifyVector` 函数中，`nums` 是通过引用传递的。该函数将 `10` 添加到 `nums` 向量中。
- 因为 `nums` 是引用类型，函数内的修改会影响原始数据。

### 2. 指针传递

指针传递是通过指针（`*`）将变量的地址传递给函数。通过指针，函数可以访问并修改原始数据。

#### 特点：

- 需要明确传递对象的地址。
- 可能需要额外的指针解引用操作，语法稍微复杂一些。
- 允许函数修改原始数据，也可以使函数接收 `nullptr` 作为参数，表示一个空指针。

#### 示例代码：

```cpp
#include <iostream>
#include <vector>

void modifyVector(std::vector<int>* nums) {
    nums->push_back(10);  // 使用指针修改 nums 向量
}

int main() {
    std::vector<int> nums = {1, 2, 3, 4};

    std::cout << "Before modification: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    modifyVector(&nums);  // 传递指针

    std::cout << "After modification: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 输出：

```
Before modification: 1 2 3 4 
After modification: 1 2 3 4 10 
```

### 解释：

- 在 `modifyVector` 函数中，`nums` 是通过指针传递的。函数接收 `nums` 的地址，然后通过 `->` 操作符访问和修改原始数据。
- 通过指针传递，函数能够修改原始数据。

### 对比：引用传递与指针传递

|特性|引用传递（`&`）|指针传递（`*`）|
|---|---|---|
|语法简洁度|语法简洁，像直接使用变量。|需要使用 `*` 解引用和 `&` 获取地址。|
|是否需要显式空指针检查|不需要显式检查空引用。|需要显式检查指针是否为 `nullptr`。|
|是否支持 `nullptr`|不支持 `nullptr`，必须指向一个有效对象。|支持 `nullptr`，可以传递空指针。|
|可操作对象类型|可操作对象本身。|可操作对象本身，也可以修改指针指向的对象。|
|修改外部变量|可以直接修改外部变量。|可以通过解引用修改指针指向的对象。|

### 何时使用引用传递或指针传递？

- **引用传递**：推荐使用引用传递，当你不需要空指针检查，并且希望代码更简洁时，使用引用传递。引用传递在 C++ 中非常常见，尤其是当传递复杂对象（如 `std::vector`、`std::string`）时，因为它比值传递更高效。
    
- **指针传递**：当你需要传递 `nullptr`，或者当你希望函数能修改指针本身（例如指向不同对象）时，可以使用指针传递。指针传递允许你传递 `nullptr`，从而表示“无数据”或“空状态”，并且适合那些需要显式检查指针有效性的情况。
    

总之，如果只是希望修改传入的对象，而不需要担心指针是否为空，引用传递通常更简洁、直观。

**值传递** 是函数参数传递的另一种方式，它将参数的副本传递给函数，函数内的任何修改都不会影响外部的原始数据。也就是说，函数操作的是参数的副本，而不是原始数据本身。

### 1. 值传递的特点

- **副本传递**：函数接收的是参数的副本，原始数据在函数内外是独立的，修改副本不会影响原始数据。
- **内存开销**：因为要复制数据，所以如果传递的是较大的对象（比如大数组或大型对象），则会有一定的性能开销。
- **不受外部影响**：函数内部的改变不会对外部变量产生任何影响，因为它只操作的是副本。

### 2. 值传递的示例

```cpp
#include <iostream>
#include <vector>

void modifyVector(std::vector<int> nums) {
    nums.push_back(10);  // 修改传入的 nums 副本
    std::cout << "Inside function: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> nums = {1, 2, 3, 4};

    std::cout << "Before function call: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    modifyVector(nums);  // 传递副本

    std::cout << "After function call: ";
    for (int num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 输出：

```
Before function call: 1 2 3 4 
Inside function: 1 2 3 4 10 
After function call: 1 2 3 4 
```

### 解释：

- 在 `modifyVector` 函数中，`nums` 是通过值传递的。函数接收到 `nums` 的副本，因此对 `nums` 的修改（如 `push_back(10)`）不会影响到 `main` 函数中的原始 `nums`。
- 在 `main` 函数中，原始的 `nums` 没有被改变，尽管在 `modifyVector` 中修改了它的副本。

### 3. 值传递 vs 引用传递 vs 指针传递

|特性|值传递（`T`）|引用传递（`T&`）|指针传递（`T*`）|
|---|---|---|---|
|是否修改原始数据|不修改原始数据，操作的是副本。|可以修改原始数据。|可以修改原始数据，操作的是指针指向的对象。|
|语法简洁度|简单直接，参数就像普通变量一样使用。|语法简单，像直接操作变量。|需要使用 `*` 解引用操作，语法稍复杂。|
|内存开销|复制数据时会有内存开销，特别是传递大对象时。|无内存开销，因为没有复制数据。|只传递指针本身，内存开销较小。|
|是否需要空指针检查|不需要。|不需要。|需要显式检查指针是否为空（`nullptr`）。|

### 4. 何时使用值传递？

- **传递小的基本类型或小对象**：当参数是小的基本类型（如 `int`、`char`、`float` 等）或小的结构体对象时，使用值传递通常是合适的。这样做的开销较小且语法清晰。
    
- **避免修改原始数据**：如果你希望函数内部修改不影响外部变量，可以使用值传递。这样可以确保函数内部操作的数据是副本。
    
- **简化代码**：值传递的语法更简单，不需要考虑指针是否为空或引用是否有效。对于小的对象或简单类型，值传递非常方便。
    

### 5. 性能考虑

- **值传递的开销**：对于大对象（如大型数组、大型 `std::vector`、`std::string` 等），值传递会复制整个对象，可能会导致不必要的内存开销和性能下降。对于这些大对象，引用传递（或指针传递）会更高效，因为它们只传递对象的引用或指针，而不是复制整个对象。
    
    对于 `std::vector` 等容器，虽然它们会被复制，但因为 C++11 引入了“移动语义”（move semantics），如果是传递右值引用（`std::vector<int>&&`），编译器可以通过“移动”而不是复制来避免不必要的内存开销。
    

### 总结

- **值传递** 是最基本的一种传递方式，适合处理简单类型或者不需要修改外部数据的场景。
- **引用传递** 更高效且方便，适合修改传入的对象，避免了不必要的复制。
- **指针传递** 与引用传递类似，但需要更多的空指针检查，适用于需要处理空值的情况。

对于小型数据或不需要修改原数据的情况，使用值传递；对于需要修改外部数据的情况，使用引用传递或指针传递。