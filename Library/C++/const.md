# 1. const 含义
常类型是指使用类型修饰符**const**说明的类型，常类型的变量或对象的值是不能被更新的。

# 2. const 作用
1. 定义常量
```
const int a=100;
```

2. 类型检查
const常量与#define宏定义常量的区别：**const常量具有类型，编译器可以进行安全检查；#define宏定义没有数据类型，只是简单的字符串替换，不能进行安全检查。**

### 1. **`const` 修饰的变量**

`const` 关键字用于修饰变量，表示该变量是**只读的**，一旦初始化后，它的值不能再修改。然而，这并不意味着 `const` 变量只能是整数或枚举类型。`const` 变量可以是任何类型（如基本数据类型、结构体、类等）。

#### 例如：

```cpp
const int a = 10;         // 整数类型的常量
const double b = 3.14;    // 浮点类型的常量
const char c = 'A';       // 字符常量
const Vector2D v(1.0, 2.0); // 用户定义类型的常量
```

`const` 关键字确保了这些变量在初始化之后不能被修改。如果你尝试修改它们，编译器会报错。

### 2. **常量表达式（`constexpr`）**

`constexpr` 是 C++11 引入的一个关键字，表示一个变量、函数或构造函数在编译时就能被求值为常量。常量表达式是编译时计算的，必须满足特定的条件，通常用于提高性能（如在数组大小、`switch` 语句、`constexpr` 函数等中使用）。

`constexpr` 变量必须是 **常量表达式**，并且它的值必须在编译时已知。这是与 `const` 的一个重要区别：

- **`const`**：表示一个常量，值在运行时确定，可以是任意类型（即使它不能是常量表达式）。`const` 变量的值可以在运行时计算得出。
- **`constexpr`**：表示常量表达式，值必须在编译时就能确定，必须是编译时常量。`constexpr` 变量必须初始化为常量表达式，并且在编译时可以被求值。

#### `const` 与 `constexpr` 的关系：

- 如果你定义一个 `const` 变量，它的值是固定的，但编译器并不要求它是常量表达式。在某些情况下，`const` 变量可以在运行时计算出来。
- 如果你使用 `constexpr` 定义一个变量，它要求变量的值在编译时已知，因此是常量表达式。

### 3. **关于 `const` 变量与常量表达式的初始化**

你的问题中提到的“`const` 定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式”这个描述并不完全正确。实际上，`const` 变量**不要求**其值必须是常量表达式。`const` 变量的初始化可以是运行时值，只要该值在初始化时确定即可。

### 4. **示例**

#### `const` 变量初始化

```cpp
const int x = 10;          // 常规常量，值为10
const double y = x * 2.0;  // 使用常规常量初始化
```

在这个例子中，`x` 和 `y` 都是 `const` 变量，但它们不需要是常量表达式。`y` 是在运行时由 `x` 计算得出的，但它的值不能被修改。

#### `constexpr` 变量初始化

```cpp
constexpr int x = 10;      // 常量表达式
constexpr int y = x * 2;   // 使用常量表达式初始化
```

在这个例子中，`x` 和 `y` 都是 `constexpr` 变量，值必须是编译时可计算的常量表达式。`y` 的值也必须在编译时就能求出。

### 5. **常量表达式初始化的限制**

`constexpr` 变量要求在编译时可确定其值，因此不能使用运行时计算得到的值。换句话说：

- **`const` 变量**可以在运行时计算，并且它的值可以是非常量表达式。
- **`constexpr` 变量**要求初始化时必须是常量表达式，且不能在运行时求得。

#### 示例：

```cpp
const int x = 10;    // 运行时常量
int runtime_value = 20;
const int y = x + runtime_value;  // 合法，因为运行时值可以赋给 const 变量

constexpr int a = 10;
int runtime_value2 = 20;
// constexpr int b = a + runtime_value2; // 错误！无法将运行时值用于 constexpr 变量初始化
```

### 总结

- `const` 关键字用于声明只读变量，但该变量的值可以在运行时计算，不要求是常量表达式。
- `constexpr` 关键字用于声明编译时常量，要求变量的值在编译时已知，必须是常量表达式。
- `const` 变量不一定要是常量表达式，可以在运行时确定其值，而 `constexpr` 变量则必须是常量表达式，并且它的值必须在编译时已知。

3. 防止修改，起保护作用，增加程序健壮性
```
void f(const int i){ i++; //error! }
```

4. 可以节省空间，避免不必要的内存分配

const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝。

# 3. const 对象默认为文件局部变量
注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。

- 未被const修饰的变量在不同文件的访问
![[Pasted image 20241207151340.png]]
- const 常量在不同文件的访问
![[Pasted image 20241207151358.png]]
==小结：可以发现未被const修饰的变量不需要extern显式声明！而const常量需要显式声明extern，并且需要做初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。==

# 4. 定义常量
![[Pasted image 20241207151425.png]]
上述有两个错误，第一：b为常量，不可更改！第二：i为常量，必须进行初始化！(因为常量在定义后就不能被修改，所以定义时必须初始化。)

# 5. 指针与const
与指针相关的const有四种：
![[Pasted image 20241207151547.png]]
小结：如果 const 位于`*`的左侧，则 const 就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于`*`的右侧，const 就是修饰指针本身，即指针本身是常量。

具体使用如下：
1. 指向常量的指针
```
const int *ptr; 
*ptr = 10; //error
```

ptr是一个指向int类型const对象的指针，const定义的是int类型，也就是ptr所指向的对象类型，而不是ptr本身，所以ptr可以不用赋初始值。但是不能通过ptr去修改所指对象的值。

除此之外，也不能使用void`*`指针保存const对象的地址，必须使用const void`*`类型的指针保存const对象的地址。
![[Pasted image 20241207151919.png]]

另外一个重点是：**允许把非const对象的地址赋给指向const对象的指针**。

将非const对象的地址赋给const对象的指针:
![[Pasted image 20241207152018.png]]
我们不能通过ptr指针来修改val的值，即使它指向的是非const对象!

我们不能使用指向const对象的指针修改基础对象，然而如果该指针指向了非const对象，可用其他方式修改其所指的对象。可以修改const指针所指向的值的，但是不能通过const对象指针来进行而已！如下修改：
![[Pasted image 20241207152123.png]]

小结：对于指向常量的指针，不能通过指针来修改对象的值。  也不能使用void`*`指针保存const对象的地址，必须使用const void`*`类型的指针保存const对象的地址。  
允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。

# 7. 类中使用 const
在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字
明的成员函数不能用来操作常对象。




