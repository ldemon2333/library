类中定义了的函数是隐式内联函数，声明要想成为内联函数，必须在实现处（定义处）加 inline 关键字。
![[Pasted image 20250110113446.png]]

在 C++ 中，**内联函数**（`inline`）是一个提示编译器将函数的调用展开为直接的代码，从而避免函数调用的开销，通常用于函数体非常小的函数。类中的内联函数是一种特别的情况，因为类的成员函数通常会被定义在类定义内部，因此这些成员函数默认就是内联的。

### 1. **类中的内联函数**

如果你在类的定义中直接定义了一个成员函数，这个成员函数通常会被认为是内联函数，即使你没有显式地使用 `inline` 关键字。事实上，在类内定义的成员函数都会被编译器视为内联函数（除非编译器决定优化掉它）。

### 2. **显式的内联成员函数**

你可以在类外部使用 `inline` 关键字显式地标记一个成员函数，使其成为内联函数。这通常用于类外定义的成员函数。

### 示例：内联成员函数

```cpp
#include <iostream>
using namespace std;

class Person {
public:
    Person(const string& n, int a) : name(n), age(a) {}

    // 直接在类定义内定义成员函数，默认是内联的
    void set_age(int a) { age = a; }

    // 显式声明内联函数
    inline void set_name(const string& n) { name = n; }

    void display() const {
        cout << "Name: " << name << ", Age: " << age << endl;
    }

private:
    string name;
    int age;
};

int main() {
    Person p("Alice", 30);
    p.display();

    p.set_age(31);
    p.set_name("Bob");
    p.display();

    return 0;
}
```

### 3. **为什么使用内联函数**

- **减少函数调用的开销**：普通函数的调用需要通过堆栈传递参数、保存返回地址、跳转到函数地址等操作，而内联函数通过将函数代码直接嵌入到调用点来避免这些开销，适用于执行频繁且代码简短的函数。
    
- **优化小函数**：内联函数适合于函数体非常小、且调用频繁的情况。编译器通常会将这些函数的调用展开，从而提高效率。
    

### 4. **内联函数的限制**

虽然内联函数能提高性能，但也有一些限制和注意事项：

- **编译器控制**：`inline` 只是一个编译器的建议，编译器可能根据自己的优化策略决定是否内联一个函数。如果函数体复杂，编译器可能会忽略 `inline`，不将其展开为内联。
    
- **递归函数**：递归函数通常不能作为内联函数使用，因为每次递归调用会增加栈帧，内联展开可能导致栈溢出。
    
- **函数体过大**：如果函数体很大，内联可能会导致代码膨胀，反而降低程序的性能，因为会增加程序的大小，影响缓存命中率和指令执行效率。
    

### 5. **类成员函数和内联**

在类定义内部定义的成员函数通常会被编译器视为内联函数。这是因为内联函数的主要目的是减少调用开销，而类成员函数通常会涉及到对象的数据访问，因此为了避免性能损失，编译器倾向于将它们内联。

```cpp
class MyClass {
public:
    // 在类内部定义的成员函数通常会被视为内联函数
    void set_x(int x) { this->x = x; }

    int get_x() const { return x; }

private:
    int x;
};
```

在这种情况下，即使没有显式使用 `inline` 关键字，`set_x()` 和 `get_x()` 函数也会被编译器作为内联函数处理。

### 6. **内联函数与类外部定义**

如果你在类的外部定义了成员函数，可以显式地使用 `inline` 关键字来标记它：

```cpp
class Person {
public:
    Person(const string& n, int a) : name(n), age(a) {}

    inline void set_name(const string& n);  // 声明为内联函数
    void display() const;

private:
    string name;
    int age;
};

// 在类外定义内联函数
inline void Person::set_name(const string& n) {
    name = n;
}
```

### 7. **内联函数的优缺点**

#### 优点：

- **减少函数调用开销**：通过将函数代码直接插入到调用处，避免了函数调用的开销。
- **适用于小函数**：对短小的、频繁调用的函数，内联可以显著提高性能。

#### 缺点：

- **代码膨胀**：如果内联函数很大或者函数被调用的地方很多，会导致目标代码膨胀，进而影响程序的性能。
- **不能用于复杂函数**：函数体较复杂、递归、或者涉及循环的函数通常不适合内联。

### 8. **总结**

- **类内部成员函数**：在类内部定义的成员函数默认就是内联的，无需显式使用 `inline` 关键字，编译器通常会自动将它们视为内联函数。
- **类外部成员函数**：如果在类外部定义成员函数，可以使用 `inline` 关键字明确指定该函数为内联函数。
- 内联函数适用于函数体简单且频繁调用的情况，但过度使用内联可能导致代码膨胀，反而影响程序的性能。

