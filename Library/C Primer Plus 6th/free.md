c free 一个指针，该指针指向一个结构体，结构体里包含其他指针，那么其他指针指向的内容能被正确free吗

在 C 语言中，如果你 `free` 一个指向结构体的指针，结构体内包含的其他指针所指向的内存**不会**被自动释放。你需要手动 `free` 结构体内部的每一个指针指向的内存，之后再 `free` 结构体本身。

例如，假设有如下结构体：

```c
typedef struct {
    int *arr;
    char *str;
} MyStruct;
```

如果你直接 `free(myStruct)`，结构体本身会被释放，但 `myStruct->arr` 和 `myStruct->str` 指向的内存并不会被释放。

正确的做法是先释放结构体内部的指针指向的内存，再释放结构体本身：

```c
free(myStruct->arr);  // 释放 arr 指向的内存
free(myStruct->str);  // 释放 str 指向的内存
free(myStruct);       // 最后释放结构体本身
```

如果结构体内部有多个指针或者更复杂的嵌套结构，你也需要依次 `free` 每一个指针所指向的内存。

总结：**`free` 结构体不会自动释放结构体内部指针指向的内存，你需要手动释放这些内存**。