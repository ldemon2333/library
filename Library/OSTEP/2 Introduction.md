---

---
在 C 语言中，`printf` 系列函数用于格式化输出，它们的用法类似，但输出目标不同。以下是几种常见的 `printf` 函数及其作用：

### 1. `printf`
`printf` 用于将格式化的输出打印到标准输出（通常是控制台）。

#### 用法：
```c
int printf(const char *format, ...);
```

- **format**：格式化字符串，包含文字和格式化符（如 `%d`、`%s` 等）。
- **...**：要插入的参数。

#### 示例：
```c
int num = 42;
printf("Number: %d\n", num);  // 输出到控制台: Number: 42
```

### 2. `sprintf`
`sprintf` 用于将格式化的输出写入字符串中，而不是打印到控制台。

#### 用法：
```c
int sprintf(char *str, const char *format, ...);
```

- **str**：目标字符串，用于存放格式化的输出。
- **format**：格式化字符串。
- **...**：插入的参数。

#### 示例：
```c
char buffer[100];
int num = 42;
sprintf(buffer, "Number: %d", num);
```

### 3. `snprintf`
`snprintf` 与 `sprintf` 类似，但它可以指定要写入的最大字符数，以避免缓冲区溢出问题。

#### 用法：
```c
int snprintf(char *str, size_t size, const char *format, ...);
```

- **size**：最大写入字符数，包括字符串结尾的 `\0`。
- **str**：目标字符串。
- **format**：格式化字符串。
- **...**：插入的参数。

#### 示例：
```c
char buffer[10];
snprintf(buffer, sizeof(buffer), "Number: %d", 12345);
```

### 4. `fprintf`
`fprintf` 用于将格式化的输出写入指定的文件流中（如文件、标准输出或标准错误）。

#### 用法：
```c
int fprintf(FILE *stream, const char *format, ...);
```

- **stream**：目标文件流。
- **format**：格式化字符串。
- **...**：插入的参数。

#### 示例：
```c
FILE *fp = fopen("output.txt", "w");
if (fp != NULL) {
    fprintf(fp, "Writing to a file: %d\n", 42);
    fclose(fp);
}
```

### 5. `vprintf`
`vprintf` 是 `printf` 的变体，用于处理变长参数列表，通常与 `va_list` 一起使用。

#### 用法：
```c
int vprintf(const char *format, va_list arg);
```

- **format**：格式化字符串。
- **arg**：变长参数列表。

#### 示例：
```c
#include <stdarg.h>
#include <stdio.h>

void myPrint(const char *format, ...) {
    va_list args;
    va_start(args, format);
    vprintf(format, args);
    va_end(args);
}

int main() {
    myPrint("Number: %d\n", 100);
    return 0;
}
```

### 6. `vsprintf` / `vsnprintf`
`vsprintf` 和 `vsnprintf` 类似于 `sprintf` 和 `snprintf`，但处理的是变长参数列表。

- **vsprintf**：写入字符串，但不限定长度。
- **vsnprintf**：写入字符串，限定最大字符数。

#### 用法：
```c
int vsprintf(char *str, const char *format, va_list arg);
int vsnprintf(char *str, size_t size, const char *format, va_list arg);
```

---

总结：`printf` 系列函数的区别主要在于它们的输出目标是控制台、文件流还是字符串，以及是否处理变长参数。
`sprintf` 是 C 语言中用于格式化输出到字符串的函数。它的功能与 `printf` 类似，但不同的是，`sprintf` 不会将结果打印到控制台，而是将格式化的内容写入指定的字符串中。

---
### 用法：

```c
int sprintf(char *str, const char *format, ...);
```

- **str**：一个字符数组指针，用来存放格式化后的字符串。
- **format**：格式控制字符串，类似 `printf` 中使用的格式化方式。
- **...**：要插入到 `format` 中的变量。

### 常见格式化符号：
- `%d`：格式化为整数。
- `%f`：格式化为浮点数。
- `%s`：格式化为字符串。
- `%c`：格式化为字符。

### 示例：

```c
#include <stdio.h>

int main() {
    char buffer[100];
    int num = 42;
    float pi = 3.14159;
    char character = 'A';
    char str[] = "Hello, World!";
    
    sprintf(buffer, "Number: %d, Pi: %.2f, Character: %c, String: %s", num, pi, character, str);

    printf("Formatted string: %s\n", buffer);  // 输出到控制台
    return 0;
}
```

### 输出：
```
Formatted string: Number: 42, Pi: 3.14, Character: A, String: Hello, World!
```

在这个例子中，`sprintf` 将格式化后的字符串保存到 `buffer` 中，然后通过 `printf` 将其输出到控制台。

### 注意事项：
- 使用 `sprintf` 时要确保目标字符串有足够的空间存放格式化后的内容，否则可能导致缓冲区溢出。
- 为了安全性，可以使用 `snprintf`，它可以指定最大写入字符数，从而避免缓冲区溢出。


---
在 C 语言中，**标准流**（Standard Streams）是由运行环境自动打开的三个流，用于处理输入和输出操作。它们是：**标准输入**（`stdin`）、**标准输出**（`stdout`）、和**标准错误**（`stderr`）。每个流都与特定的 I/O 设备关联，例如键盘、显示器或错误日志等。

### C 中的标准流

1. **标准输入（`stdin`）**：
   - **用途**：从用户输入（通常是键盘）中获取数据。
   - **关联的流**：`stdin`
   - **常用函数**：`scanf`、`fgets`、`getc`、`fscanf` 等。

   #### 示例：
   ```c
   char name[50];
   printf("Enter your name: ");
   fgets(name, sizeof(name), stdin);  // 从标准输入获取用户输入
   printf("Hello, %s", name);
   ```

2. **标准输出（`stdout`）**：
   - **用途**：将输出显示到用户界面（通常是终端/显示器）。
   - **关联的流**：`stdout`
   - **常用函数**：`printf`、`putchar`、`fputs`、`fprintf` 等。

   #### 示例：
   ```c
   int num = 42;
   printf("The number is: %d\n", num);  // 输出到标准输出
   ```

3. **标准错误（`stderr`）**：
   - **用途**：输出错误消息，通常输出到用户界面（终端），与标准输出不同，`stderr` 默认不被重定向。
   - **关联的流**：`stderr`
   - **常用函数**：`fprintf(stderr, ...)`、`fputs(stderr)` 等。

   #### 示例：
   ```c
   fprintf(stderr, "An error occurred!\n");  // 输出错误信息到标准错误
   ```

### 标准流与文件流的关系
标准流在 C 语言中被表示为 `FILE` 类型的指针，分别是：
- `stdin`：`FILE *stdin` （用于标准输入）
- `stdout`：`FILE *stdout` （用于标准输出）
- `stderr`：`FILE *stderr` （用于标准错误输出）

这些流与 `fopen` 函数打开的文件流类型一致，所以可以使用诸如 `fscanf`、`fprintf` 之类的文件操作函数与标准流进行交互。

### 流的重定向
标准流可以通过操作系统的命令行进行重定向。例如：

- 重定向标准输出到文件：
   ```bash
   ./a.out > output.txt
   ```

- 将标准错误重定向到文件：
   ```bash
   ./a.out 2> error.txt
   ```

- 将标准输出和标准错误都重定向到同一文件：
   ```bash
   ./a.out > output.txt 2>&1
   ```

### 缓冲机制
- **`stdout`** 默认是**行缓冲**，即每输出一行（遇到换行符）时刷新缓冲区。
- **`stderr`** 是**无缓冲**的，意味着错误信息一旦输出就立即显示，不会等待缓冲区填满。
- **`stdin`** 是**行缓冲**，在用户按下回车键时，输入被提交。

### 典型用法
标准流的典型用法包括从键盘读取用户输入，将输出显示在屏幕上，以及输出错误信息到控制台或日志文件。例如：

```c
#include <stdio.h>

int main() {
    char name[50];
    
    // 从标准输入读取数据
    printf("Enter your name: ");
    fgets(name, sizeof(name), stdin);
    
    // 输出到标准输出
    printf("Hello, %s", name);
    
    // 输出错误信息到标准错误
    if (name[0] == '\n') {
        fprintf(stderr, "Error: No input provided!\n");
    }
    
    return 0;
}
```

这段程序将从标准输入获取用户的名字，如果用户没有输入任何内容，则会输出一条错误消息到标准错误流。

---
在 Linux 系统上，**系统调用（System Call）** 是用户态程序与内核进行交互的方式。每当程序需要执行某些操作（如文件读写、网络通信、内存分配等），它们通常会通过系统调用向内核发出请求。

要查看 Linux 系统中的系统调用函数，有几种不同的方式可用，具体取决于你想要的系统调用信息类型（如查看特定程序执行的系统调用，或查看可用的系统调用列表等）。以下是几种常用方法：

### 1. 使用 `man` 手册查看系统调用函数

你可以使用 `man` 命令来查看系统调用的文档。例如，以下是一些常用的系统调用及其 `man` 页面：

- 查看 `open` 系统调用：
  ```bash
  man 2 open
  ```

- 查看 `read` 系统调用：
  ```bash
  man 2 read
  ```

在 `man` 页面中，**第 2 部分** 是系统调用相关的文档，所以你可以通过 `man 2 <系统调用名>` 的方式来查找对应的系统调用函数说明。

### 2. 使用 `strace` 查看进程的系统调用

`strace` 是一个调试工具，可以用于跟踪进程执行的系统调用。如果你想查看一个运行的程序所发出的系统调用，`strace` 是非常有用的。

- 跟踪一个新启动的程序：
  ```bash
  strace ./my_program
  ```

  这会显示程序执行过程中所发出的所有系统调用。

- 跟踪一个已经运行的进程（假设进程 ID 为 `1234`）：
  ```bash
  strace -p 1234
  ```

- 只跟踪特定类型的系统调用（例如文件相关的系统调用）：
  ```bash
  strace -e trace=file ./my_program
  ```

`strace` 是查看程序与内核交互的强大工具，能够帮助你理解程序的运行状态及其调用的系统服务。

### 3. 查看内核的系统调用表

Linux 系统调用的编号和实现可通过查看内核的源代码来找到。以下是查看系统调用表的一些方法：

- **系统调用表文件**：
  如果你有 Linux 内核的源代码，你可以找到系统调用表（`syscall` table）文件。通常在内核源代码中，系统调用表位于：
  ```plaintext
  arch/x86/entry/syscalls/syscall_64.tbl
  ```

  这个文件包含所有系统调用及其对应的系统调用号和函数名称。

- **使用 `ausyscall` 命令**（需要安装 `audit` 工具）：
  `ausyscall` 是 Linux `audit` 系统的一部分，它可以列出系统调用及其对应的编号：
  ```bash
  ausyscall --dump
  ```

  这将输出一个系统调用编号和系统调用名称的列表。例如：
  ```
  0  read
  1  write
  2  open
  3  close
  ...
  ```

### 4. 在 C 代码中使用系统调用

在 C 语言中，系统调用通过 C 库的封装函数调用，如 `open()`, `read()`, `write()` 等。如果你想直接在代码中使用这些函数，可以直接包含头文件并调用相应的函数。例如：

```c
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main() {
    int fd = open("file.txt", O_RDONLY);
    if (fd < 0) {
        perror("open");
        return 1;
    }
    // Do something with the file descriptor...
    close(fd);
    return 0;
}
```

在这里，`open()`、`read()`、`write()` 等函数实际上都是系统调用的封装。当程序调用这些函数时，内核会通过系统调用机制执行这些操作。

### 5. 查看系统调用数量

如果你想知道当前 Linux 系统支持多少种系统调用，可以使用以下方法：

- **通过内核配置文件查看系统调用数**：
  使用以下命令来查看当前系统支持的系统调用数量（基于 `proc` 文件系统）：
  ```bash
  cat /proc/sys/kernel/threads-max
  ```

- **通过 `syscall` 命令**：
  在某些系统中，可以使用以下命令获取系统调用的总数：
  ```bash
  getconf SC_NPROCESSORS_CONF
  ```

### 6. 直接使用 `syscall()` 函数调用

C 库为我们提供了标准接口来使用系统调用，但如果你想直接调用系统调用，可以使用 `syscall()` 函数：

```c
#include <unistd.h>
#include <sys/syscall.h>

int main() {
    long result = syscall(SYS_write, 1, "Hello, World!\n", 14);
    return 0;
}
```

在这个例子中，`syscall()` 函数直接调用 `write` 系统调用，而不是通过标准库的 `write()` 函数。

---
使用strace查看进程的系统调用
![[Pasted image 20241015225529.png]]
这段输出是通过 `strace` 工具捕获的系统调用跟踪信息。它显示了一个程序执行时的两个主要系统调用，分别是 `execve` 和 `exit`，以及程序的退出状态。让我们逐行解释：

### 1. `execve("./minimal", ["./minimal"], 0x7ffd7af3cfa0 /* 30 vars */) = 0`

- **`execve`**：这是一个系统调用，用于执行一个可执行文件。在这个例子中，程序正在尝试执行一个名为 `./minimal` 的可执行文件。
- **`"./minimal"`**：这是程序的文件路径，表示可执行文件的名称。
- **`["./minimal"]`**：这是传递给该程序的参数列表，包含一个参数，即可执行文件名本身。通常，第一个参数是可执行文件名（类似于命令行中的 `argv[0]`）。
- **`0x7ffd7af3cfa0 /* 30 vars */`**：这是程序的环境变量指针，指向一个包含 30 个环境变量的内存地址。`strace` 没有详细列出这些环境变量，而是用注释 `/* 30 vars */` 来简化说明。
- **`= 0`**：这个部分表示 `execve` 系统调用的返回值。在成功执行时，`execve` 的返回值通常为 `0`，表示程序被成功加载并开始执行。

在这里，`execve("./minimal", ...) = 0` 表示系统成功执行了名为 `./minimal` 的程序。

### 2. `exit(101) = ?`

- **`exit(101)`**：这表示程序正在调用 `exit` 系统调用，并传递了一个退出状态码 `101`。
- **`= ?`**：这里表示系统调用返回的值是不确定的（`exit` 系统调用通常不会返回给调用程序，因为程序已经退出）。但这个退出码将传递给操作系统或父进程。

### 3. `+++ exited with 101 +++`

- **`exited with 101`**：这表示程序以退出码 `101` 退出。操作系统接收到该退出码并报告程序终止状态。
- **`+++`**：这是 `strace` 的输出格式，用来标记程序的终止。
---
## 2.1 虚拟CPU
![[Pasted image 20241016113006.png]]

![[Pasted image 20241016113019.png]]

![[Pasted image 20241016113029.png]]

## 2.2 虚拟内存
![[Pasted image 20241016002241.png]]
输出：
![[Pasted image 20241016002252.png]]
![[Pasted image 20241016002309.png]]
这个程序做这么几件事。首先，它分配一些内存（a1），内存指针执行p。然后它打印这个内存的地址（a2），然后将0放入这个新分配内存的第一个槽中（a3）。最后，循环，延迟一秒并自加这个值，每次输出PID和这个值。

多进程运行时，每个进程都分配到了同一个地址（0x200000），同时每个看起来都在独立的更新这个地址所存储的值。这好像每个进程都有自己私有内存，而不是与其他进程共享同一个物理内存。

确实，这就是OS虚拟内存。每个进程访问它私有虚拟地址（也称为它的地址空间），这是OS以某种方式映射到物理内存。一个在运行的进程的内存引用不会影响到其他进程的地址空间。

## 2.3 Concurrency
![[Pasted image 20241016003450.png]]
另一个主题是并发。现代多线程程序也有这个问题。

threads.c的main函数创建两个线程通过使用Pthread_create()。你可以认为一个线程是一个函数与其他函数运行在同一个内存空间，并且同时有多个线程在运行。在此示例中，每个线程开始在名为 worker() 的例程中运行，在该例程中，它只是在循环中按循环次数增加计数器。

下面是当我们将变量 loops 的输入值设置为 1000 来运行此程序时发生的情况的记录。 loops 的值决定了两个 worker 中每个 worker 在循环中将共享计数器增加多少次。当将 loops 的值设置为 1000 来运行程序时，您期望 counter 的最终值是多少？

![[Pasted image 20241016004432.png]]
当两个线程结束时，最终counter的值为2000，因为每个线程自增counter1000次。确实，当这输入loops值为$N$时，我们期待最终的输出是$2N$。但不是这样的。
![[Pasted image 20241016112351.png]]
这个共享counter自增的程序使用三种指令：一是从内存将counter的值加载到寄存器中，一是自增这个值，还有一个是将这个值存回内存中。因为这三条指令并没有原子执行（立刻执行），奇怪的事情就会发生。这就是并发性要解决的问题。


## 2.4 Persistence
在系统内存中，数据很容易丢失，因为DRAM以易失性存储值。当断电或系统崩溃时，任何内存内的数据都会丢失。因此我们需要硬件和软件能够去持久地存储数据。

硬件以某种输入/输出或 I/O 设备的形式出现；在现代系统中，硬盘是长期信息的常见存储库，尽管固态硬盘 (SSD) 也在这个领域取得了进展。

OS中软件通常管理硬盘通过文件系统。

与操作系统为 CPU 和内存提供的抽象不同，操作系统不会为每个应用程序创建私有的虚拟化磁盘。相反，它假设用户经常希望共享文件中的信息。例如，在编写 C 程序时，您可能首先使用编辑器（例如 Emacs）来创建和编辑 C 文件（emacs -nw main.c）。完成后，您可能使用编译器将源代码转换为可执行文件（例如 gcc -o main main.c）。完成后，您可以运行新的可执行文件（例如 ./main）。因此，您可以看到文件如何在不同的进程之间共享。首先，Emacs 创建一个文件作为编译器的输入；编译器使用该输入文件创建新的可执行文件（分为多个步骤 - 参加编译器课程了解详情）；最后，运行新的可执行文件。这样，一个新的程序就诞生了！

![[Pasted image 20241016233523.png]]
图2.6描述创建一个文件（/tmp/file）包含string ”hellp world“的代码。

为了完成这个任务，该程序进行了3次系统调用。
- 首先，open()系统调用，打开文件和创建它；
- write()，向这个文件写入一些数据；
- close()，简单地关闭这个文件因此表明程序不再会写入一些数据。
这些系统调用被路由到操作系统中称为文件系统的部分，然后该部分处理请求并向用户返回某种错误代码。

您可能想知道操作系统如何才能真正写入磁盘。我们会向您展示，但您必须先闭上眼睛；这太令人不快了。文件系统必须做相当多的工作：首先确定这些新数据将驻留在磁盘上的位置，然后在文件系统维护的各种结构中跟踪它。这样做需要向底层存储设备发出 I/O 请求，以读取现有结构或更新（写入）它们。任何编写过设备驱动程序的人都知道，让设备代表您做某事是一个复杂而详细的过程。它需要深入了解低级设备接口及其确切语义。幸运的是，操作系统提供了一种通过其系统调用访问设备的标准而简单的方法。因此，操作系统有时被视为标准库。

当然，关于如何访问设备，以及文件系统如何在所述设备上持久地管理数据，还有更多细节。出于性能原因，大多数文件系统首先会将此类写入延迟一段时间，希望将它们分批处理成更大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都采用了某种复杂的写入协议，例如日志记录或写时复制，仔细地对磁盘的写入进行排序，以确保如果在写入序列中发生故障，系统可以在之后恢复到合理的状态。为了使不同的常见操作高效，文件系统采用了许多不同的数据结构和访问方法，从简单的列表到复杂的 b-tree。如果所有这些还不合理，那就太好了！我们将在本书关于持久性的第三部分中更详细地讨论所有这些内容，我们将在其中讨论设备和 I/O 的一般情况，然后详细讨论磁盘、RAIDs 和文件系统。

## 2.5 设计目标
现在，您已经了解了操作系统的实际功能：它利用物理资源（例如 CPU、内存或磁盘）并对其进行虚拟化。它处理与并发相关的棘手问题。它持久存储文件，从而确保文件长期安全。鉴于我们想要构建这样的系统，我们希望在心中设定一些目标，以帮助专注于我们的设计和实施，并在必要时做出权衡；找到正确的权衡是构建系统的关键。

最基本的目标之一是建立一些抽象，以便使系统方便易用。抽象是我们在计算机科学中所做的一切的基础。抽象使得我们能够通过将大型程序分成小而易理解的部分来编写大型程序，在每一节中，我们将讨论一些随着时间的推移而发展起来的主要抽象，让您可以思考操作系统的各个部分。

设计OS的目的是提供高性能；或者说是最小化OS的开销。虚拟化使系统易于使用是值得的，但并非不惜一切代价；因此，我们必须努力提供虚拟化和其他操作系统功能，而不会产生过多的开销。这些开销有多种形式：额外的时间（更多指令）和额外的空间（在内存或磁盘上）。如果可能的话，我们将寻求最小化其中一个或另一个或两者的解决方案。然而，完美并不总是可以实现的，我们将学会注意并（在适当的情况下）容忍它。

另一个目标是在应用程序之间以及操作系统和应用程序之间提供保护。因为我们希望允许许多程序同时运行，所以我们要确保一个程序的恶意或意外不良行为不会损害其他程序；我们当然不希望应用程序能够损害操作系统本身（因为这会影响系统上运行的所有程序）。保护是操作系统主要原则之一的核心，即隔离；将进程彼此隔离是保护的关键，因此是操作系统必须执行的大部分操作的基础。

操作系统还必须不间断运行；当它发生故障时，系统上运行的所有应用程序也会发生故障。由于这种依赖性，操作系统通常努力提供高度的可靠性。

其他目标也很有意义：能源效率很重要；针对恶意应用程序的安全性（实际上是保护的延伸）至关重要，尤其是在这个高度网络化的时代；随着操作系统在越来越小的设备上运行，移动性变得越来越重要。根据系统的使用方式，操作系统将具有不同的目标，因此可能以至少略有不同的方式实现。但是，正如我们将看到的，我们将介绍的关于如何构建操作系统的许多原则在各种不同的设备上都很有用。

## 2.6 历史
### 早年OS：只是库
基本上，它只是一组常用函数库；例如，系统的每个程序员不必编写低级 I/O 处理代码，而是由“操作系统”提供此类 API，从而使开发人员的工作变得更轻松。

通常，在这些旧的大型机系统上，一次只运行一个程序，由人工操作员控制。您认为现代操作系统会做的大部分工作（例如，决定以什么顺序运行作业）都是由这个操作员执行的。如果您是一位聪明的开发人员，您会对这个操作员很友好，这样他们可能会将您的作业移到队列的最前面。

这种计算模式被称为批处理，因为操作员设置了许多作业，然后以“批处理”方式运行。从那时开始，由于成本原因，计算机还没有以交互方式使用：让用户坐在计算机前使用它实在是太昂贵了，因为大多数时候计算机都处于闲置状态，每小时要花费设施数十万美元。

### 超越库：保护机制
操作系统不再只是一个简单的常用服务库，而是在管理机器方面发挥了更重要的作用。这其中的一个重要方面是认识到代表操作系统运行的代码是特殊的；它控制着设备，因此应该与普通应用程序代码区别对待。为什么会这样？好吧，想象一下，如果你允许任何应用程序从磁盘上的任何位置读取；隐私的概念就不复存在了，因为任何程序都可以读取任何文件。因此，将文件系统（用于管理文件）实现为库是没有意义的。相反，需要其他东西。

因此，系统调用的概念应运而生，由 Atlas计算系统率先提出。这里的想法不是将操作系统例程作为库提供（您只需进行过程调用即可访问它们），而是添加一对特殊的硬件指令和硬件状态，以使进入操作系统的转换成为一个更正式、更受控的过程。

系统调用和过程调用之间的主要区别在于，系统调用将控制权（即跳转）转移到操作系统，同时提升硬件特权级别。用户应用程序在所谓的用户模式下运行，这意味着硬件限制了应用程序可以执行的操作；例如，在用户模式下运行的应用程序通常无法向磁盘发起 I/O 请求、访问任何物理内存页面或在网络上发送数据包。当启动系统调用时（通常通过称为陷阱的特殊硬件指令），硬件会将控制权转移到预先指定的陷阱处理程序（操作系统先前设置），同时将特权级别提升到内核模式。在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行诸如发起 I/O 请求或为程序提供更多内存之类的操作。当操作系统完成对请求的服务后，它会通过一个特殊的“从陷阱返回”指令将控制权交还给用户，该指令会恢复到用户模式，同时将控制权交还到应用程序停止的位置。

### 多道程序设计时代
操作系统真正腾飞的时代是在大型机之外的计算时代，即小型计算机时代。像 Digital Equipment 的 PDP 系列这样的经典机器使计算机的价格大大降低；因此，现在组织内一小部分人可以拥有自己的计算机，而不是每个大型组织都拥有一台大型机。毫不奇怪，成本下降的主要影响之一是开发人员活动的增加；更多聪明的人开始使用计算机，从而使计算机系统能够做更多有趣和美妙的事情。

尤其是，由于人们希望更好地利用机器资源，多道程序设计变得很普遍。操作系统不再一次只运行一个作业，而是将多个作业加载到内存中并在它们之间快速切换，从而提高 CPU 利用率。这种切换尤其重要，因为 I/O 设备速度很慢；让程序在 CPU 上等待其 I/O 得到服务会浪费 CPU 时间。相反，为什么不切换到另一个作业并运行一段时间呢？

支持多道程序设计和在 I/O 和中断存在的情况下实现重叠的愿望迫使操作系统在多个方向上进行概念开发创新。诸如内存保护之类的问题变得很重要；我们不希望一个程序能够访问另一个程序的内存。了解如何处理由多道程序设计引入的并发问题也至关重要；确保操作系统在存在中断的情况下正常运行是一项巨大的挑战。我们将在本书后面研究这些问题和相关主题。

当时最重大的实际进步之一是 UNIX 操作系统的推出，这主要归功于贝尔实验室（没错，就是电话公司）的 Ken Thompson（和 Dennis Ritchie）。UNIX 从不同的操作系统（特别是 Multics，以及 TENEX 和 Berkeley 分时系统等系统）中汲取了许多好的想法，但使它们更简单、更易于使用。很快，这个团队就将包含 UNIX 源代码的磁带发给了世界各地的人们，其中许多人随后参与其中并亲自为系统添加了代码；有关更多详细信息，请参阅旁注。

#### 旁注：UNIX的重要性
UNIX 在操作系统历史上的重要性怎么强调都不为过。受早期系统（尤其是 MIT 著名的 Multics 系统）的影响，UNIX 汇集了许多伟大的思想，并打造了一个既简单又强大的系统。

最初的“贝尔实验室” UNIX 的底层是构建小型、功能强大的程序，这些程序可以连接在一起形成更大的工作流程。shell（您在其中输入命令）提供了pipes等原语来实现这种元级编程，因此将程序串联起来完成更大的任务变得很容易。例如，要查找文本文件中包含单词“foo”的行，然后计算有多少这样的行，您可以输入：grep foo file.txt|wc -l，从而使用 grep 和 wc（字数统计）程序来完成您的任务。

UNIX 环境对程序员和开发人员都很友好，还为新的 C 编程语言提供了编译器。
程序员可以轻松编写自己的程序并共享它们，这使得 UNIX 非常受欢迎。作者免费向任何需要的人提供副本，这可能是很大的帮助，这是早期的开源软件形式。

代码的可访问性和可读性也至关重要。用 C 语言编写的精美小内核可以吸引其他人使用内核，添加新的酷炫功能。例如，伯克利的一个富有进取心的小组在 Bill Joy 的领导下制作了一个很棒的发行版（伯克利系统发行版，简称 BSD），它有一些先进的虚拟内存、文件系统和网络子系统。Joy 后来与他人共同创立了 Sun Microsystems。

不幸的是，由于各公司试图宣称拥有 UNIX 并从中获利，因此 UNIX 的传播速度有所减缓，这是律师介入的不幸（但很常见）结果。许多公司都有自己的变体：Sun Microsystems 的 SunOS、IBM 的 AIX、HP 的 HPUX（又名“H-Pucks”）和 SGI 的 IRIX。AT&T/贝尔实验室和其他参与者之间的法律纠纷给 UNIX 蒙上了一层阴影，许多人怀疑它是否能生存下来，尤其是在 Windows 推出并占领了大部分 PC 市场之后……

#### 旁注，LINUX的到来
幸运的是，一位名叫 Linus Torvalds 的年轻芬兰黑客决定编写自己的 UNIX 版本，该版本大量借鉴了原始系统背后的原理和思想，但没有借鉴代码库，从而避免了合法性问题。他从世界各地的许多人那里获得了帮助，利用了已经存在的复杂 GNU 工具，很快 Linux 就诞生了（以及现代开源软件运动）。

随着互联网时代的到来，大多数公司（如谷歌、亚马逊、Facebook 等）选择运行 Linux，因为它是免费的，而且可以根据自己的需求随时进行修改；事实上，如果没有这样的系统，很难想象这些新公司会取得成功。随着智能手机成为面向用户的主导平台，出于许多相同的原因，Linux 也在那里找到了据点（通过 Android）。史蒂夫·乔布斯将他基于 UNIX 的 NeXTStep 操作环境带到了苹果公司，从而使 UNIX 在桌面上流行起来（尽管许多苹果技术用户可能甚至没有意识到这一事实）。因此，UNIX 继续存在，今天比以往任何时候都更重要。如果你相信计算之神，就应该感谢他们带来这一美妙的结果。

### 现代
除了小型计算机之外，还出现了一种新型机器，它更便宜、更快速，而且适合大众：个人计算机，也就是我们今天所说的 PC。在 Apple 早期机器（例如 Apple II）和 IBM PC 的引领下，这种新型机器很快成为计算领域的主导力量，因为它们的低成本使每台桌面只有一台机器，而不是每个工作组共享一台小型计算机。

不幸的是，对于操作系统而言，PC 最初代表着一次巨大的倒退，因为早期的系统忘记了（或从未了解过）小型计算机时代所学到的教训。例如，早期的操作系统，如 DOS（微软的磁盘操作系统）并不认为内存保护很重要；因此，恶意（或可能只是编程不当）的应用程序可能会在内存上乱涂乱画。第一代 Mac OS（v9 及更早版本）采用协作方式进行作业调度；因此，意外陷入无限循环的线程可能会接管整个系统，从而强制重新启动。这一代系统缺少的操作系统功能列表很长，无法在此进行全面讨论。

幸运的是，经过几年的磨难，小型计算机操作系统的旧功能开始在桌面上找到出路。例如，Mac OS X/macOS 的核心是 UNIX，包括人们期望从这样一个成熟的系统中获得的所有功能。Windows 也同样采纳了计算历史上的许多伟大创意，特别是从 Windows NT 开始，这是微软操作系统技术的一大飞跃。即使是今天的手机运行的操作系统（如 Linux），也更像 20 世纪 70 年代的小型计算机运行的操作系统，而不是 20 世纪 80 年代的 PC 运行的操作系统（谢天谢地）；很高兴看到在操作系统开发鼎盛时期开发的好想法已经进入了现代世界。更棒的是，这些想法还在不断发展，提供更多功能，使现代系统对用户和应用程序来说更加出色。


## 2.7 总结
因此，我们对操作系统进行了介绍。当今的操作系统使系统相对易于使用，并且您今天使用的几乎所有操作系统都受到我们将在整本书中讨论的发展的影响。

不幸的是，由于时间限制，本书不会介绍操作系统的许多部分。例如，操作系统中有很多网络代码；我们留给您参加网络课程来了解更多相关信息。同样，图形设备也特别重要；参加图形课程以扩展您在这方面的知识。最后，一些操作系统书籍大量谈论安全性；我们将这样做，因为操作系统必须在运行程序之间提供保护，并让用户能够保护他们的文件，但我们不会深入探讨安全课程中可能发现的更深层次的安全问题。

但是，我们将介绍许多重要主题，包括 CPU 和内存虚拟化的基础知识、并发性以及通过设备和文件系统的持久性。别担心！虽然还有很多内容需要讲解，但大部分内容都很酷，在学习完这些内容后，你会对计算机系统的实际工作方式有全新的认识。

## 作业
本书的大多数（最终是所有）章节的末尾都有家庭作业部分。完成这些家庭作业很重要，因为每个家庭作业都可以让您（读者）更多地了解本章中介绍的概念。

家庭作业有两种类型。第一种是基于模拟的。计算机系统的模拟只是一个简单的程序，它假装执行真实系统所做的一些有趣的部分，然后报告一些输出指标以显示系统的行为方式。例如，硬盘驱动器模拟器可能会接受一系列请求，模拟它们需要多长时间才能由具有某些性能特征的硬盘驱动器提供服务，然后报告请求的平均延迟。

模拟的妙处在于，它们可以让您轻松探索系统的行为方式，而无需运行真实系统。事实上，它们甚至可以让您创建现实世界中不可能存在的系统（例如，具有难以想象的快速性能的硬盘驱动器），从而看到未来技术的潜在影响。

当然，模拟并非没有缺点。就其本质而言，模拟只是真实系统行为的近似值。
如果忽略了真实世界行为的一个重要方面，模拟将报告不良结果。因此，模拟结果应始终保持怀疑态度。最终，系统在真实世界中的行为才是最重要的。

第二种家庭作业需要与真实世界代码交互。其中一些家庭作业以测量为重点，而其他家庭作业只需要一些小规模的开发和实验。两者都只是您应该进入的更大世界的小小尝试，即如何在基于 UNIX 的系统上用 C 编写系统代码。事实上，需要超越这些家庭作业的更大规模的项目来推动您朝这个方向发展；因此，除了做家庭作业之外，我们强烈建议您做项目来巩固您的系统技能。请参阅此页面
(https://github.com/remzi-arpacidusseau/ostep-projects)
了解一些项目。

要完成这些作业，您可能必须在基于 UNIX 的计算机上运行 Linux、macOS 或类似系统。它还应该安装 C 编译器（例如 gcc）以及 Python。您还应该知道如何在某种真正的代码编辑器中编辑代码。