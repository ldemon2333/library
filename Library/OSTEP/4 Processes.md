分时操作系统
- low-level 机制和协议
- high-level intelligence

实现一个上下文切换器，即给予OS能力去停止运行一个程序然后去启动另一个程序在一个CPU上；

在这些机制之上，操作系统中还存在一些以策略形式存在的智能。策略是操作系统中用于做出某种决策的算法。例如，给定一些可以在 CPU 上运行的程序，操作系统应该运行哪个程序？操作系统中的调度策略将做出此决定，可能使用历史信息（例如，哪个程序在过去一分钟内运行得更多？）、工作负载知识（例如，运行了哪些类型的程序）和性能指标（例如，系统是否针对交互性能或吞吐量进行优化？）来做出决定。

## 4.1 The Abstraction: A Process
一个进程就是一个运行的程序。在任何时刻，我们都可以通过盘点系统在执行过程中访问或影响的不同部分来总结一个进程。

理解它的machine state：地址空间，寄存器，PC寄存器（哪条指令将会被下一条执行），栈指针，局部变量，返回地址，IO信息。


## 4.2 进程 API

- Create：创建一个进程
- Destroy：销毁进程
- Wait：等待一个进程停止运行
- 杂项控制：挂起，恢复一个进程
- 状态：获取进程相关信息


## 4.3 进程创建：一些更多细节
程序是如何转变为进程的。具体地，OS是如何运行一个程序并让它跑起来的，进程创建是如何工作的?

OS要运行一个程序首先就是加载它的代码和任何静态数据（初始化变量）到内存，加载到进程的地址空间。程序最初以某种可执行格式驻留在磁盘上（或者在某些现代系统中驻留在基于闪存的 SSD 上）；因此，将程序和静态数据加载到内存中的过程需要操作系统从磁盘读取这些字节并将它们放在内存中的某个位置（如图 4.1 所示）。

![[Pasted image 20241018163229.png]]

在早期（或简单）操作系统中，加载过程是急切完成的，即在运行程序之前一次性完成；现代操作系统以懒惰的方式执行该过程，即仅在程序执行期间需要时才加载代码或数据。要真正理解代码和数据片段的懒惰加载是如何工作的，您必须更多地了解分页和交换机制，我们将在讨论内存虚拟化时介绍这些主题。现在，只需记住，在运行任何内容之前，操作系统显然必须做一些工作来将重要的程序位从磁盘放入内存中。

一旦代码和静态数据被加载到内存中，有一些其他事情OS 需要做在运行进程前，一些内存必须被分配到程序的 run-time stack(or just stack)中。C 程序使用stack 存储局部变量，函数参数和返回地址；OS分配这些内存并给进程。OS也会用参数初始化stack；具体的，它会将参数填入main() 函数（例如，argc 和 argv 数组）。

OS 可能也会分配一些内存给程序的heap。在C 程序中，heap用于显示请求的动态分配数据；程序请求这些空间通过调用 malloc() 和显示释放 free()。堆一开始很小，后来会变大。

OS 也会做其他一些初始化工作，特别是I/O的工作。比如，在UNIX系统中，每个进程默认有三个打开的file descriptors，for standard input,output and error；这些描述符使得程序简单的从终端中读入和打印到显示屏上。

OS在程序运行前会做的工作：
- 加载代码和静态数据到内存中
- 创建和初始化stack，heap
- I/O 设置初始化

然后OS启动程序在进入点，也就是main()，通过跳转到 main() （通过我们将在下一章讨论的专门机制），操作系统将 CPU 的控制权转移到新创建的进程，从而程序开始执行。

## 4.4 进程状态
- Running：进程在执行指令
- Ready：only no cpu，ready to run
- Blocked：等待其他进程给他分配资源，而被动blocked
![[Pasted image 20241018165209.png]]

## 4.5 数据结构
操作系统是一个程序，与任何程序一样，它有一些关键的数据结构来跟踪各种相关信息。例如，为了跟踪每个进程的状态，操作系统可能会保留所有就绪进程的某种进程列表，以及一些其他信息来跟踪当前正在运行的进程。操作系统还必须以某种方式跟踪被阻止的进程；当 I/O 事件完成时，操作系统应确保唤醒正确的进程并使其准备好再次运行。

图 4.5 显示了操作系统需要跟踪 xv6 内核中每个进程的哪些类型的信息。Linux、Mac OS X 或 Windows 等“真实”操作系统中存在类似的进程结构；
![[Pasted image 20241018165533.png]]
寄存器内容，当进程停止时，其寄存器将保存到此内存位置；通过恢复这些寄存器（即，将其值放回实际的物理寄存器中），操作系统可以恢复运行该进程。我们将在后续章节中进一步了解这种称为上下文切换的技术。

从图中还可以看到，除了运行、就绪和阻塞之外，进程还可以处于其他一些状态。有时，系统会在创建进程时有一个初始状态。此外，进程可以处于最终状态，即进程已退出但尚未清理（在基于 UNIX 的系统中，这称为zombie状态）。此最终状态很有用，因为它允许其他进程（通常是父进程）检查进程的返回代码，并查看刚刚完成的进程是否成功执行（通常，在基于 UNIX 的系统中，当程序成功完成任务时返回零，否则返回非零）。完成后，父进程将进行最后一次调用（例如 wait()）以等待子进程完成，并向操作系统指示它可以清理任何引用现已消亡的进程的相关数据结构。


## 4.6 总结
我们已经介绍了操作系统最基本的抽象概念：进程。它被简单地视为一个正在运行的程序。考虑到这一概念，我们现在将讨论具体内容：实现进程所需的低级机制，以及以智能方式调度进程所需的高级策略。通过结合机制和策略，我们将加深对操作系统如何虚拟化 CPU 的理解。

