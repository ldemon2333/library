# Go 语言用途
Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。

对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。

## Go Hello World 实例

Go 语言的基础组成有以下几个部分：

- 包声明
- 引入包
- 函数
- 变量
- 语句 & 表达式
- 注释

# 包
每个 Go 程序都由包构成。

程序从 `main` 包开始运行。

本程序通过导入路径 `"fmt"` 和 `"math/rand"` 来使用这两个包。

按照约定，包名与导入路径的最后一个元素一致。例如，`"math/rand"` 包中的源码均以 `package rand` 语句开始。


# 导出名
在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，`Pizza` 就是个已导出名，`Pi` 也同样，它导出自 `math` 包。

`pizza` 和 `pi` 并未以大写字母开头，所以它们是未导出的。

在导入一个包时，你只能引用其中已导出的名字。 任何「未导出」的名字在该包外均无法访问。

# 函数 
函数可接受零个或多个参数。

在本例中，`add` 接受两个 `int` 类型的参数。

注意类型在变量名的 **后面**。

# 变量
`var` 语句用于声明一系列变量。和函数的参数列表一样，类型在最后。

如例中所示，`var` 语句可以出现在包或函数的层级。

# 变量的初始化
变量声明可以包含初始值，每个变量对应一个。

如果提供了初始值，则类型可以省略；变量会从初始值中推断出类型。

# 短变量声明
在函数中，短赋值语句 `:=` 可在隐式确定类型的 `var` 声明中使用。

函数外的每个语句都 **必须** 以关键字开始（`var`、`func` 等），因此 `:=` 结构不能在函数外使用。

# 类型转换
表达式 `T(v)` 将值 `v` 转换为类型 `T`。

一些数值类型的转换：
![[Pasted image 20250115192644.png]]

或者，更加简短的形式：
![[Pasted image 20250115192656.png]]
与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换。试着移除例子中的 `float64` 或 `uint` 的类型转换，看看会发生什么。


# 类型推断
在声明一个变量而不指定其类型时（即使用不带类型的 `:=` 语法 `var =` 表达式语法），变量的类型会通过右值推断出来。

当声明的右值确定了类型时，新变量的类型与其相同：

不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 `int`、`float64` 或 `complex128` 了，这取决于常量的精度：

# 常量
常量的声明与变量类似，只不过使用 `const` 关键字。

常量可以是字符、字符串、布尔值或数值。

常量不能用 `:=` 语法声明。


# 基本类型
![[Pasted image 20250115193412.png]]


# for 循环
Go 只有一种循环结构：`for` 循环。

基本的 `for` 循环由三部分组成，它们用分号隔开：

- 初始化语句：在第一次迭代前执行
- 条件表达式：在每次迭代前求值
- 后置语句：在每次迭代的结尾执行
是 i++，没有++i

初始化语句通常为一句短变量声明，该变量声明仅在 `for` 语句的作用域中可见。

一旦条件表达式求值为 `false`，循环迭代就会终止。

**注意**：和 C、Java、JavaScript 之类的语言不同，Go 的 `for` 语句后面的三个构成部分外没有小括号， 大括号 `{ }` 则是必须的。

初始化语句和后置语句是可选的。

此时你可以去掉分号，因为 C 的 `while` 在 Go 中叫做 `for`。

如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。

# if 和简短语句
和 `for` 一样，`if` 语句可以在条件表达式前执行一个简短语句。

该语句声明的变量作用域仅在 `if` 之内。

（在最后的 `return` 语句处使用 `v` 看看。）

在 `if` 的简短语句中声明的变量同样可以在对应的任何 `else` 块中使用。

（在 `main` 的 `fmt.Println` 调用开始前，两次对 `pow` 的调用均已执行并返回其各自的结果。）

![[Pasted image 20250115195822.png]]
先执行两个 pow，pow里有先打印，然后打印第一个 pow的返回值和第二个 pow 的返回值

# switch 分支
`switch` 语句是编写一连串 `if - else` 语句的简便方法。它运行第一个 `case` 值 值等于条件表达式的子句。

Go 的 `switch` 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只会运行选定的 `case`，而非之后所有的 `case`。 在效果上，Go 的做法相当于这些语言中为每个 `case` 后面自动添加了所需的 `break` 语句。在 Go 中，除非以 `fallthrough` 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 `switch` 的 `case` 无需为常量，且取值不限于整数。

# switch 的求值顺序
`switch` 的 `case` 语句从上到下顺次执行，直到匹配成功时停止。

例如，
![[Pasted image 20250115200817.png]]
在 `i==0` 时，`f` 不会被调用。）


# 无条件 switch
无条件的 `switch` 同 `switch true` 一样。

这种形式能将一长串 `if-then-else` 写得更加清晰。

# defer 推迟
defer 语句会将函数推迟到外层函数返回之后执行。

推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。


# defer 栈
推迟调用的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的调用会按照后进先出的顺序调用。

更多关于 defer 语句的信息，请阅读[此博文](http://blog.go-zh.org/defer-panic-and-recover)。

# 指针
Go 拥有指针。指针保存了值的内存地址。

类型 `*T` 是指向 `T` 类型值的指针，其零值为 `nil`。

var p *int

`&` 操作符会生成一个指向其操作数的指针。

i := 42
p = &i

`*` 操作符表示指针指向的底层值。


这也就是通常所说的「解引用」或「间接引用」。

与 C 不同，Go 没有指针运算。

# 结构体指针
结构体字段可通过结构体指针来访问。

如果我们有一个指向结构体的指针 `p` 那么可以通过 `(*p).X` 来访问其字段 `X`。 不过这么写太啰嗦了，所以语言也允许我们使用隐式解引用，直接写 `p.X` 就可以。

# 结构体字面量
使用 `Name:` 语法可以仅列出部分字段（字段名的顺序无关）。

特殊的前缀 `&` 返回一个指向结构体的指针。

# 数组
类型 `[n]T` 表示一个数组，它拥有 `n` 个类型为 `T` 的值。

表达式

var a [10]int

会将变量 `a` 声明为拥有 10 个整数的数组。

数组的长度是其类型的一部分，因此数组不能改变大小。 这看起来是个限制，不过没关系，Go 拥有更加方便的使用数组的方式。

# 切片
每个数组的大小都是固定的。而切片则为数组元素提供了动态大小的、灵活的视角。 在实践中，切片比数组更常用。

类型 `[]T` 表示一个元素类型为 `T` 的切片。.

切片通过两个下标来界定，一个下界和一个上界，二者以冒号分隔：

a[low : high]

它会选出一个半闭半开区间，包括第一个元素，但排除最后一个元素。

以下表达式创建了一个切片，它包含 `a` 中下标从 1 到 3 的元素：

a[1:4]

# 切片类似数组的引用
切片就像数组的引用 切片并不存储任何数据，它只是描述了底层数组中的一段。

更改切片的元素会修改其底层数组中对应的元素。

和它共享底层数组的切片都会观测到这些修改。

# 切片字面量
这行代码是 Go 语言中的一种**切片字面量**（slice literal），它定义了一个切片，并且为切片赋予了一些初始值。

具体来说：

```go
s := []int{2, 3, 5, 7, 11, 13}
```

### 各部分的含义：

1. **`s :=`**  
    这是 Go 语言的简短声明语法，用于声明一个变量并初始化它。`s` 是变量名，`: =` 表示声明并赋值，Go 会根据右侧的值自动推断出变量的类型。
    
2. **`[]int`**  
    这表示 `s` 的类型是一个切片（slice）。切片是 Go 中一种动态数组的类型，允许在运行时动态增长。`[]int` 表示该切片存储的是 `int` 类型的元素。
    
3. **`{2, 3, 5, 7, 11, 13}`**  
    这是切片的初始化值。它表示一个包含 6 个整数的切片，具体元素为 `2, 3, 5, 7, 11, 13`。
    

### 解释：

- `s := []int{2, 3, 5, 7, 11, 13}` 定义了一个整数类型的切片 `s`，并且将这个切片初始化为包含 6 个整数元素的切片。
- 在 Go 中，切片是一个轻量级的动态数组，它会根据需要动态扩展，可以通过索引访问元素。

### 内存结构：

- 切片 `s` 的内部结构包括三个部分：
    1. **指针**：指向切片中数据的起始位置。
    2. **长度**：切片中当前元素的个数（此处为 6）。
    3. **容量**：切片底层数组的总容量，通常会比切片的长度更大，以支持扩展。

### 示例：

```go
package main

import "fmt"

func main() {
    s := []int{2, 3, 5, 7, 11, 13}
    fmt.Println(s)  // 输出: [2 3 5 7 11 13]
    fmt.Println(len(s))  // 输出切片的长度: 6
    fmt.Println(cap(s))  // 输出切片的容量（根据实现情况，可能大于6）
}
```

### 结果：

- `fmt.Println(s)` 输出的是切片的内容，即 `[2 3 5 7 11 13]`。
- `len(s)` 返回切片的长度，即 `6`，表示切片中有 6 个元素。
- `cap(s)` 返回切片的容量，表示底层数组的大小，通常会大于或等于切片的长度，以便支持动态扩展。

### 总结：

`[]int{2, 3, 5, 7, 11, 13}` 是一个包含 6 个整数的切片字面量，其中的整数是预先定义的。切片是一种灵活的、动态的数组类型，能够根据需要扩展或收缩。


# 切片的默认行为
在进行切片时，你可以利用它的默认行为来忽略上下界。

切片下界的默认值为 0，上界则是该切片的长度。

对于数组
![[Pasted image 20250115203620.png]]

# 切片的长度与容量
切片拥有 **长度** 和 **容量**。

切片的长度就是它所包含的元素个数。

切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。

切片 `s` 的长度和容量可通过表达式 `len(s)` 和 `cap(s)` 来获取。

你可以通过重新切片来扩展一个切片，给它提供足够的容量。 试着修改示例程序中的切片操作，向外扩展它的长度，看看会发生什么。

# nil 切片
切片的零值是 `nil`。

nil 切片的长度和容量为 0 且没有底层数组。

# 用 make 创建切片
切片可以用内置函数 `make` 来创建，这也是你创建动态数组的方式。

`make` 函数会分配一个元素为零值的数组并返回一个引用了它的切片：
![[Pasted image 20250115204637.png]]

# 向切片追加元素
为切片追加新的元素是种常见的操作，为此 Go 提供了内置的 `append` 函数。内置函数的[文档](https://tour.go-zh.org/pkg/builtin/#append)对该函数有详细的介绍。
```go
func append(s []T, vs ...T) []T
```

`append` 的第一个参数 `s` 是一个元素类型为 `T` 的切片，其余类型为 `T` 的值将会追加到该切片的末尾。

`append` 的结果是一个包含原切片所有元素加上新添加元素的切片。

当 `s` 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。 返回的切片会指向这个新分配的数组。

（要了解关于切片的更多内容，请阅读文章 [Go 切片：用法和本质](https://tour.go-zh.org/blog/go-slices-usage-and-internals)。）

# range 遍历
`for` 循环的 `range` 形式可遍历切片或映射。

当使用 `for` 循环遍历切片时，每次迭代都会返回两个值。 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。

可以将下标或值赋予 `_` 来忽略它。

```go
for i, _ := range pow
for _, value := range pow
```

# map 映射
`map` 映射将键映射到值。

映射的零值为 `nil` 。`nil` 映射既没有键，也不能添加键。

`make` 函数会返回给定类型的映射，并将其初始化备用。

在你的代码中，`make(map[string]Vertex)` 是用于创建一个空的 `map` 类型（键为 `string`，值为 `Vertex`）的表达式。我们来详细解释 `make` 的作用：

### 1. `make` 的作用：

`make` 是 Go 语言内置的一个函数，专门用于初始化切片（slice）、映射（map）和管道（channel）。它的主要作用是 **为这些数据类型分配内存并初始化**，让你可以开始使用它们。

### 2. `make(map[string]Vertex)` 解释：

`make(map[string]Vertex)` 会创建一个类型为 `map[string]Vertex` 的映射，并返回一个初始化好的空映射。具体来说，它做了两件事：

- **为 `map` 分配内存**：映射需要存储键值对的数据结构，所以必须在使用之前进行内存分配。
- **初始化映射**：`make` 会确保返回的 `map` 是有效的空映射，而不是 `nil`。如果你直接使用 `var m map[string]Vertex` 声明一个 `map`，它默认是 `nil`，如果没有使用 `make` 初始化，调用它时会导致运行时错误。

### 3. 为什么需要 `make`：

如果没有 `make`，你的 `m` 映射变量将是 `nil`。在向 `nil` 映射中添加键值对时，会导致程序崩溃（`panic`）。`make` 保证了映射是有效的，可以安全地进行存储操作。

### 代码分析：

```go
package main

import "fmt"

type Vertex struct {
    Lat, Long float64
}

var m map[string]Vertex

func main() {
    // 使用 make 初始化 map
    m = make(map[string]Vertex)
    m["zzw"] = Vertex{112, 1} // 向 map 中添加元素
    fmt.Println(m["zzw"])      // 打印键 "zzw" 对应的值
}
```

- `m = make(map[string]Vertex)` 初始化了 `m` 映射，使得你可以往其中添加元素。
- `m["zzw"] = Vertex{112, 1}` 向 `m` 映射中添加了一个键为 `"zzw"`，值为 `Vertex{112, 1}` 的键值对。
- 最后，`fmt.Println(m["zzw"])` 打印出了该键对应的值。

### 总结：

`make(map[string]Vertex)` 确保了映射 `m` 被正确初始化为一个空的 `map`，使得你可以安全地存储和访问键值对。如果没有 `make`，`m` 会是 `nil`，不能直接赋值或访问。

# 修改映射
在映射 `m` 中插入或修改元素：
```go
m[key] = elem
```
获取元素：
```go
elem = m[key]
```
删除元素：
```go
delete(m, key)
```
通过双赋值检测某个键是否存在：
```go
elem, ok = m[key]
```
若 `key` 在 `m` 中，`ok` 为 `true` ；否则，`ok` 为 `false`。

若 `key` 不在映射中，则 `elem` 是该映射元素类型的零值。

**注**：若 `elem` 或 `ok` 还未声明，你可以使用短变量声明：

```go
elem, ok := m[key]
```

在 Go 中，`range` 关键字用于遍历数组、切片、映射（`map`）、通道（`channel`）等数据结构。它返回的值依赖于被遍历的类型。我们来详细介绍一下 `range` 在不同数据类型上返回的内容：

### 1. **遍历数组或切片（`[]T`）**：

- **返回：** `index, value`
    - `index` 是当前元素的索引。
    - `value` 是当前元素的值。

**示例：**

```go
arr := []string{"apple", "banana", "cherry"}
for index, value := range arr {
    fmt.Printf("Index: %d, Value: %s\n", index, value)
}
```

**输出：**

```
Index: 0, Value: apple
Index: 1, Value: banana
Index: 2, Value: cherry
```

**如果只需要值：**

```go
for _, value := range arr {
    fmt.Println(value)
}
```

**如果只需要索引：**

```go
for index := range arr {
    fmt.Println(index)
}
```

### 2. **遍历映射（`map`）**：

- **返回：** `key, value`
    - `key` 是当前元素的键。
    - `value` 是当前元素的值。

**示例：**

```go
m := map[string]int{"apple": 5, "banana": 3, "cherry": 7}
for key, value := range m {
    fmt.Printf("Key: %s, Value: %d\n", key, value)
}
```

**输出：**

```
Key: apple, Value: 5
Key: banana, Value: 3
Key: cherry, Value: 7
```

**如果只关心键：**

```go
for key := range m {
    fmt.Println(key)
}
```

**如果只关心值：**

```go
for _, value := range m {
    fmt.Println(value)
}
```

### 3. **遍历通道（`channel`）**：

- **返回：** `value`
    - 只有一个值，即通道中接收到的值。

**示例：**

```go
ch := make(chan string, 2)
ch <- "apple"
ch <- "banana"

close(ch)  // 关闭通道

for value := range ch {
    fmt.Println(value)
}
```

**输出：**

```
apple
banana
```

通道的 `range` 会在通道关闭并且所有数据都被读取完后停止遍历。

### 4. **遍历字符串（`string`）**：

- **返回：** `index, rune`（或 `index, byte`）
    - `index` 是当前字符的索引位置。
    - `rune` 是当前字符的 Unicode 值。

**示例：**

```go
str := "hello"
for index, runeVal := range str {
    fmt.Printf("Index: %d, Rune: %c\n", index, runeVal)
}
```

**输出：**

```
Index: 0, Rune: h
Index: 1, Rune: e
Index: 2, Rune: l
Index: 3, Rune: l
Index: 4, Rune: o
```

**如果只关心字符：**

```go
for _, runeVal := range str {
    fmt.Println(string(runeVal))
}
```

### 总结：

|数据类型|`range` 返回值|
|---|---|
|**数组/切片**|`index, value`|
|**映射（map）**|`key, value`|
|**通道（channel）**|`value`|
|**字符串（string）**|`index, rune` (或 byte)|

使用 `range` 时，你可以选择是否需要忽略其中一个返回值。通过使用 `_`（空白标识符），你可以忽略不需要的值。例如，如果你只关心 `map` 的键或值，可以使用 `_` 来忽略另一部分。

# 函数值
函数也是值。它们可以像其他值一样传递。

函数值可以用作函数的参数或返回值。

# 函数闭包
Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量值，换句话说，该函数被“绑定”到了这些变量。

例如，函数 `adder` 返回一个闭包。每个闭包都被绑定在其各自的 `sum` 变量上。


在 Go 中，**闭包**（Closure）是指一个函数可以访问其外部作用域（函数外部）的变量，哪怕这个外部作用域的函数已经返回。闭包让一个函数在其定义时“记住”并持续访问外部的变量，这些外部变量的状态随着函数的调用而发生变化。

### 代码解析

```go
package main

import "fmt"

// adder 返回一个闭包函数
func adder() func(int) int {
    sum := 0  // sum 是 adder 的外部变量
    return func(x int) int {
        sum += x  // 闭包函数使用了外部变量 sum
        return sum
    }
}

func main() {
    // pos 和 neg 都是闭包
    pos, neg := adder(), adder()

    for i := 0; i < 10; i++ {
        fmt.Println(
            pos(i),    // pos 闭包会增加 sum
            neg(-2*i), // neg 闭包会增加 sum
        )
    }
}
```

### 关键点：

1. **`adder` 函数：**
    
    - `adder` 是一个返回闭包的函数。
    - 在 `adder` 中，`sum` 变量是 **外部变量**，`sum` 是 `adder` 内部的局部变量，它会被 `adder` 返回的闭包所引用。
    - `return func(x int) int { ... }` 返回一个匿名函数（闭包），这个函数每次被调用时都能访问并修改外部的 `sum` 变量。
2. **`pos` 和 `neg`：**
    
    - `pos := adder()` 调用 `adder` 并得到一个闭包函数，闭包会“记住” `sum` 的初始值 0。
    - `neg := adder()` 也是调用 `adder` 返回一个新的闭包，每个 `adder` 调用都会返回一个独立的闭包，拥有自己的 `sum` 变量。
    - `pos(i)` 和 `neg(-2*i)` 都会改变各自闭包中的 `sum` 值。

### 闭包的工作原理：

- 每次调用 `adder()` 都会返回一个新的匿名函数，并且每个匿名函数都携带一个独立的 `sum` 变量。
- 当你调用 `pos(i)` 或 `neg(-2*i)` 时，闭包会访问并修改它各自的 `sum` 变量。这样，闭包能够“记住”每个独立调用中的 `sum` 状态，即使 `adder` 函数已经返回，`sum` 仍然在闭包中存在并被修改。

### 输出解释：

```text
0 0
1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90
```

- 对于 `pos(i)`，`sum` 从 0 开始，每次加上当前的 `i` 值。由于每次调用 `pos` 时使用的是相同的闭包，`sum` 累积增加。
- 对于 `neg(-2*i)`，`sum` 也是从 0 开始，每次加上 `-2*i`。因为每次调用 `neg` 使用的是独立的闭包，`sum` 在每个调用中独立累加。

### 闭包的特点：

1. **封闭外部变量**：闭包会“记住”它的外部变量，因此使得你可以在函数外部继续使用这些外部变量。
2. **延迟执行**：闭包可以在其外部函数已经执行完毕之后仍然保持对外部变量的访问权限。这是闭包的重要特性，尤其在需要延迟执行时非常有用。
3. **状态持久化**：闭包可以在多次调用中保持内部状态，这样可以在不借助外部存储（如全局变量）情况下存储状态。

### 总结：

- **闭包** 是一个函数值，它可以访问并修改其外部作用域中的变量。
- 在 Go 中，函数可以返回另一个函数，这个返回的函数可以访问它外部的变量，即使外部函数已经执行完毕。
- 通过使用闭包，我们可以实现一些有状态的计算或数据封装。

# 方法
Go 没有类。不过你可以为类型定义方法。

方法就是一类带特殊的 **接收者** 参数的函数。

方法接收者在它自己的参数列表内，位于 `func` 关键字和方法名之间。

在此例中，`Abs` 方法拥有一个名字为 `v`，类型为 `Vertex` 的接收者。

# 方法即函数
记住：方法只是个带接收者参数的函数。

现在这个 `Abs` 的写法就是个正常的函数，功能并没有什么变化。

你也可以为非结构体类型声明方法。

在此例中，我们看到了一个带 `Abs` 方法的数值类型 `MyFloat`。

你只能为在同一个包中定义的接收者类型声明方法，而不能为其它别的包中定义的类型 （包括 `int` 之类的内置类型）声明方法。

（译注：就是接收者的类型定义和方法声明必须在同一包内。）

# 指针类型的接收者
可以为指针类型的接收者声明方法
这意味着对于某类型 `T`，接收者的类型可以用 `*T` 的文法。 （此外，`T` 本身不能是指针，比如不能是 `*int`。）

例如，这里为 `*Vertex` 定义了 `Scale` 方法。

指针接收者的方法可以修改接收者指向的值（如这里的 `Scale` 所示）。 由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。

若使用值接收者，那么 `Scale` 方法会对原始 `Vertex` 值的副本进行操作。（对于函数的其它参数也是如此。）`Scale` 方法必须用指针接收者来更改 `main` 函数中声明的 `Vertex` 的值。

# 方法与指针重定向
比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：
```go
var v Vertex
ScaleFunc(v, 5)  // 编译错误！
ScaleFunc(&v, 5) // OK
```

而接收者为指针的的方法被调用时，接收者既能是值又能是指针：
```go
var v Vertex
v.Scale(5)  // OK
p := &v
p.Scale(10) // OK
```

对于语句 `v.Scale(5)` 来说，即便 `v` 是一个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 `Scale` 方法有一个指针接收者，为方便起见，Go 会将语句 `v.Scale(5)` 解释为 `(&v).Scale(5)`。

# 选择值或指针作为接收者
使用指针接收者的原因有二：

首先，方法能够修改其接收者指向的值。

其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样会更加高效。

在本例中，`Scale` 和 `Abs` 接收者的类型为 `*Vertex`，即便 `Abs` 并不需要修改其接收者。

通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。 （我们会在接下来几页中明白为什么。）

# 接口
**接口类型** 的定义为一组方法签名。

接口类型的变量可以持有任何实现了这些方法的值。

**注意:** 示例代码的第 22 行存在一个错误。由于 `Abs` 方法只为 `*Vertex` （指针类型）定义，因此 `Vertex`（值类型）并未实现 `Abser`。

# 接口值
接口也是值，可以像其他值一样传递。

接口值可以用作函数的参数或返回值。

在内部，接口值可以看做包含值和具体类型的元组：

接口值保存了一个具体底层类型的具体值。

接口值调用方法时会执行其底层类型的同名方法。

# 底层值为 nil 的接口值
即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。

在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 `M` 方法）。

**注意:** 保存了 nil 具体值的接口其自身并不为 nil。

# nil 接口值
nil 接口值既不保存值也不保存具体类型。

为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 **具体** 方法的类型。

# 空接口
指定了零个方法的接口值被称为 *空接口：*
```go
interface{}
```
空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）

空接口被用来处理未知类型的值。例如，`fmt.Print` 可接受类型为 `interface{}` 的任意数量的参数。

# 类型断言
**类型断言** 提供了访问接口值底层具体值的方式。
```go
t := i.(T)
```
该语句断言接口值 `i` 保存了具体类型 `T`，并将其底层类型为 `T` 的值赋予变量 `t`。

若 `i` 并未保存 `T` 类型的值，该语句就会触发一个 panic。

为了 **判断** 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。
```go
t, ok := i.(T)
```
若 `i` 保存了一个 `T`，那么 `t` 将会是其底层值，而 `ok` 为 `true`。

否则，`ok` 将为 `false` 而 `t` 将为 `T` 类型的零值，程序并不会产生 panic。

请注意这种语法和读取一个映射时的相同之处。

# 类型选择
**类型选择** 是一种按顺序从几个类型断言中选择分支的结构。

类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。

```go
switch v := i.(type) {
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 i 的类型相同
}
```
类型选择中的声明与类型断言 `i.(T)` 的语法相同，只是具体类型 `T` 被替换成了关键字 `type`。

此选择语句判断接口值 `i` 保存的值类型是 `T` 还是 `S`。在 `T` 或 `S` 的情况下，变量 `v` 会分别按 `T` 或 `S` 类型保存 `i` 拥有的值。在默认（即没有匹配）的情况下，变量 `v` 与 `i` 的接口类型和值相同。

# Stringer
[`fmt`](https://go-zh.org/pkg/fmt/) 包中定义的 [`Stringer`](https://go-zh.org/pkg/fmt/#Stringer) 是最普遍的接口之一。
```go
type Stringer interface {
    String() string
}
```
`Stringer` 是一个可以用字符串描述自己的类型。`fmt` 包（还有很多包）都通过此接口来打印值。


# Readers
在 Go 语言中，fmt.Printf 函数用于格式化输出。格式化动词 `%q` 和 `%v` 有不同的含义：

- `%v`：表示值的默认格式。当用于结构体时，它会打印出结构体的字段值。
- `%q`：表示带双引号的字符串字面值。对于字符串类型，它会在输出时添加双引号，并对特殊字符进行转义。

# 图像



