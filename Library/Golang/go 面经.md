**golang 中 make 和 new 的区别？（基本必问）**

共同点：给变量分配内存  
**不同点：**  
1）作用变量类型不同，new给string,int和数组分配内存，make给切片，map，channel分配内存；  
2）返回类型不一样，new返回指向变量的指针，make返回变量本身；  
3）new 分配的空间被清零。make 分配空间后，会进行初始化；  
1) 字节的面试官还说了另外一个区别，就是分配的位置，在堆上还是在栈上？这块我比较模糊，大家可以自己探究下，我搜索出来的答案是golang会弱化分配的位置的概念，因为编译的时候会自动内存逃逸处理，懂的大佬帮忙补充下：make、new内存分配是在堆上还是在栈上？

在 Go 中，`make` 和 `new` 都是用来分配内存的，但它们的用途和行为有显著不同。下面是它们的主要区别：

### 1. **`new`**：用于分配内存并初始化为零值

`new` 是一个内存分配函数，它分配一个类型的零值内存并返回指向该类型的指针。`new` 只负责分配内存，不会初始化值，只会将内存设置为类型的零值。

#### 使用场景：

- `new` 适用于需要分配内存但并不需要初始化数据的情况。

#### 例子：

```go
var ptr *int
ptr = new(int)  // 分配一个 int 类型的零值内存，即 0
fmt.Println(*ptr) // 输出 0
```

- 这里 `ptr` 是一个 `*int` 指针，指向一个 `int` 类型的零值内存（即 `0`）。

### 2. **`make`**：用于初始化内建数据类型（`slice`, `map`, `chan`）

`make` 用于为切片（`slice`）、映射（`map`）和通道（`chan`）分配和初始化内存。与 `new` 不同，`make` 返回的是已初始化的对象，而不是指向它们的指针。

#### 使用场景：

- `make` 用于初始化 Go 的三种内建数据类型（`slice`、`map` 和 `chan`）的实例。它不仅分配内存，还进行初始化，以确保它们可以正常使用。

#### 例子：

```go
// 使用 make 创建一个切片
slice := make([]int, 5)  // 创建一个长度为 5 的 int 类型切片
fmt.Println(slice)        // 输出: [0 0 0 0 0]

// 使用 make 创建一个 map
m := make(map[string]int)
m["age"] = 30
fmt.Println(m)  // 输出: map[age:30]

// 使用 make 创建一个 channel
ch := make(chan int)
go func() {
    ch <- 42
}()
fmt.Println(<-ch)  // 输出: 42
```

- 在这些例子中，`make` 创建并初始化了 `slice`、`map` 和 `chan`，使它们能够被直接使用。

### 总结：

- **`new`**：分配类型的零值内存，返回指向该类型的指针。
    - 适用于一般类型（如 `int`、`struct` 等）的内存分配。
    - 返回类型是指针。
- **`make`**：用于初始化内建类型（`slice`、`map`、`chan`）并返回这些类型的实例。
    - 适用于 `slice`、`map`、`chan` 的内存分配和初始化。
    - 返回的是初始化好的对象，而不是指针。

### 关键区别：

- `new` 返回的是指针（即 `*T` 类型），而 `make` 返回的是初始化好的对象本身（即 `[]T`、`map[T]T`、`chan T` 类型）。
- `new` 可以用于任何类型，而 `make` 仅限于内建的三种类型：切片、映射和通道。

所以，简而言之，`new` 用于普通类型的内存分配，`make` 用于内建类型的初始化和分配。

在 Go 中，`new` 和 `make` 分配内存的**位置**也是不同的。这与它们的内存管理机制和用途密切相关。

### 1. **`new` 分配内存的位置：**

`new` 分配的内存通常是分配在 **堆** 上。具体来说，`new` 会返回一个指向内存块的指针，这个内存块是从堆上分配的。Go 使用垃圾回收（GC）来管理这些堆内存的生命周期。

- **堆分配**：`new` 会分配一个类型的零值内存，并返回指向该内存的指针，这块内存会存储在堆上。
- **堆的原因**：当你使用 `new` 分配内存时，Go 认为你可能会在不同的函数或 goroutine 中使用这个内存，因此它将其放在堆上，便于跨函数或 goroutine 的共享。

#### 例子：

```go
var ptr *int
ptr = new(int)  // 使用 new 分配内存，返回指向 int 的指针
fmt.Println(ptr) // ptr 的地址
```

- 在这个例子中，`new(int)` 返回的是指向堆上分配的内存的指针。

### 2. **`make` 分配内存的位置：**

`make` 用于创建和初始化切片（`slice`）、映射（`map`）和通道（`chan`）。这些数据结构本身是引用类型，所以当你使用 `make` 时，它会在堆或栈上分配内存，具体取决于变量的作用域和 Go 的逃逸分析（escape analysis）机制。

- **切片（slice）**：切片本身是一个引用类型，它指向底层数组。底层数组的内存通常分配在 **堆** 上，特别是当切片的大小或生命周期不能确定时，Go 会把底层数组放在堆上。否则，它可能会分配在栈上。
    
- **映射（map）和通道（chan）**：它们是引用类型，`make` 会在堆上分配内存，因为这些数据结构通常具有动态大小，需要在堆上分配内存，以便 Go 的垃圾回收系统能够管理它们。
    

#### 例子：

```go
// 创建切片
slice := make([]int, 5)  // 底层数组分配在堆或栈上，取决于逃逸分析

// 创建映射
m := make(map[string]int)  // 分配内存在堆上

// 创建通道
ch := make(chan int)  // 通道的内存也分配在堆上
```

### 3. **堆与栈的区别**

- **栈（Stack）**：栈上的内存是局部的，生命周期仅限于函数调用的作用域。当函数返回时，栈上的内存会被自动释放。栈的内存分配速度较快，但它不能用于存储动态大小的数据。
    
- **堆（Heap）**：堆上的内存可以在多个函数或 goroutine 之间共享，且它的生命周期由垃圾回收器控制。堆内存分配较慢，但能够存储大小动态的数据。
    

### 4. **逃逸分析（Escape Analysis）**

Go 的编译器会执行逃逸分析来确定哪些变量需要分配到堆上。具体来说，逃逸分析决定一个变量是否**逃逸**到函数外（即是否需要长期存在）。如果一个变量的生命周期不在当前函数范围内，或者需要跨多个 goroutine 使用，那么它的内存就会分配到堆上。否则，它会分配到栈上。

例如，如果你把一个切片传递给其他函数或 goroutine，Go 会通过逃逸分析将它分配到堆上。

```go
func createSlice() []int {
    slice := make([]int, 10)
    return slice  // slice 会逃逸到堆上
}
```

在上面的例子中，`slice` 变量会逃逸到堆上，因为它在函数返回后仍然有效。

### 5. **总结**

- **`new`**：分配内存通常发生在 **堆** 上，并返回一个指向该内存的指针。它仅仅分配内存并将内存初始化为零值，适用于任何类型。
    
- **`make`**：主要用于初始化切片（`slice`）、映射（`map`）和通道（`chan`）等引用类型，它会在堆或栈上分配内存，具体取决于 Go 的逃逸分析。在大多数情况下，它会在堆上分配内存，特别是当数据结构的大小无法确定时。
    

# for range 的时候它的地址会发生变化么？
答：在 for a,b := range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。由于有这个特性，for 循环里面如果开协程，不要直接把 a 或者 b 的地址传给协程。解决办法：在每次循环时，创建一个临时变量。


# 解析 tag 是怎么实现的？反射原理是什么？


# select 底层数据结构和一些特性？
go 的 select 为 golang 提供了多路 IO 复用机制，和其他 IO 复用一样，用于检测是否有读写事件是否 ready。linux 的系统 IO 模型有 select，poll，epoll，go 的 select 和 linux 系统 select 非常相似。  

select 结构组成主要是由 case 语句和执行的函数组成 select 实现的多路复用是：每个线程或者进程都先到注册和接受的 channel（装置）注册，然后阻塞，然后只有一个线程在运输，当注册的线程和进程准备好数据后，装置会根据注册的信息得到相应的数据。  
**select 的特性**  
1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。  
2）select 仅支持管道，而且是单协程操作。  
3）每个 case 语句仅能处理一个管道，要么读要么写。  
4）多个 case 语句的执行顺序是随机的。  
5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。


# defer 底层数据结构和一些特性?
每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。  
**defer 的规则总结**：  
延迟函数的参数是 defer 语句出现的时候就已经确定了的。  
延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。  
延迟函数可能操作主函数的返回值。  
申请资源后立即使用 defer 关闭资源是个好习惯。


# 单引号，双引号，反引号的区别？
单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。  
双引号，才是字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。  
反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。


# 如何实现 set 
Go中是不提供Set类型的，Set是一个集合，其本质就是一个List，只是List里的元素不能重复。  
Go提供了map类型，但是我们知道，map类型的key是不能重复的，因此，我们可以利用这一点，来实现一个set。那value呢？value我们可以用一个常量来代替，比如一个空结构体，实际上空结构体不占任何内存，使用空结构体，能够帮我们节省内存空间，提高性能


# 从数组中取一个相同大小的 slice 有成本吗？
在Go语言中，从数组中取一个相同大小的slice（切片）实际上是一个非常低成本的操作。这是因为slice在Go中是一个引用类型，它内部包含了指向数组的指针、切片的长度以及切片的容量。当你从一个数组创建一个相同大小的slice时，你实际上只是创建了一个新的slice结构体，它包含了**指向原数组的指针**、**原数组的长度作为切片的长度**，以及**原数组的长度作为切片的容量**。

这个操作的成本主要在于内存的分配（为新的slice结构体分配内存），但这个成本是非常小的，因为它只是分配了一个很小的结构体，而不是复制数组的内容。数组的内容仍然是共享的，即新的slice和原数组指向相同的内存区域。

因此，从数组中取一个相同大小的slice是一个低成本的操作，它允许你高效地操作数组的部分或全部元素，而不需要复制这些元素。



# map 相关
## 什么类型可以作为 map 的 key
在Go语言中，map的key可以是任何可以**比较**的类型。这包括所有的基本类型，如**整数、浮点数、字符串和布尔值，以及结构体和数组**，只要它们没有被定义为包含不可比较的类型（如切片、映射或函数）。

注意，切片、映射和函数类型是不可比较的，因此不能作为map的key。如果你需要一个包含这些类型的key，你可以考虑使用一个指向这些类型的指针，或者将它们封装在一个可比较的结构体中，并确保结构体不包含任何不可比较的类型。

## map 循环是有序的还是无序的？
在Go语言中，map的循环（遍历）是无序的。这意味着当你遍历map时，每次遍历的顺序可能都不同。Go语言的map是基于哈希表的，因此元素的存储顺序是不确定的，并且可能会随着元素的添加、删除等操作而改变。

如果你需要按照特定的顺序处理map中的元素，你应该先将key提取到一个切片中，对切片进行排序，然后按照排序后的顺序遍历切片，并从map中取出对应的值。这样，你就可以按照特定的顺序处理map中的元素了。

## map 中删除一个 key，它的内存会释放么？
在Go语言中，从map中删除一个key时，其内存释放的行为并非直观且立即的，这涉及到Go语言的内存管理机制。具体来说，删除map中的key后，其内存释放情况如下：


## 对 map 进行并发访问
使用并发安全的 map （sync.Map)