# Go 并发字典
解决 GO 字典不是并发安全问题，构建了一个并发安全的字典实现，采用 4 层封装，使用无锁化方案消除读写操作之间的竞态关系，构建多个

散列段，将全局锁拆分为每个段的互斥锁，并使用负载均衡技术实现字典内部的负载均衡，大幅提升了性能。

与 go 原生自带的 sync.Map 内置并发安全字典相比，读操作时间快了 8倍，但内存开销增加

主要是通过空间换时间的操作来提升读取速度

其中有 4 层封装，从下之上为：封装键-元素对的 Pair 接口的实现，封装 Pair 的单链表的 Bucket 接口的实现、封装 Bucket切片的 Segment 接口的实现，以及封装 Segment 切片的 ConcurrentMap 接口的实现。

第 1 层封装的意义是检查键值和元素值的有效性，并先行计算键的散列值以备后用。同时，在需要对键-元素对的元素值或链接进行替换时实施原子操作。这比互斥锁要快的多。

第 2 层封装主要的功能是存储键散列值在同一范围内的键-元素对，并使用单链表和原子值消除读操作之间以及读操作与写操作之间的竞态条件。这一方案是无锁化的，大大提高了操作的性能。对于写操作的竞态条件只能用互斥锁来消除了。

第 3 层封装是为了让单个散列桶集合能够自动伸缩，并承担字典内部的负载均衡。在这一层上读写操作都需要加锁。对于读操作来讲，仅需要在依据键散列值定位散列桶的这一步上加锁。当成功地向散列段添加或删除一个key-value 对的时候，就会触发对其中所有 key-value 对的负载均衡。负载均衡的频率不能过低也不能过高，否则就会影响性能。

第 4 层封装，会根据使用者的需要初始化若干个散列段。散列段的数量会影响并发安全字典的，这一消除了重量级的全局锁，大幅提升了性能

# 网络爬虫框架
编写一个容易被定制和扩展的网络爬虫框架，而非满足一个特定爬取目的的网络爬虫，使这个程序成为一个可适用于不同应用场景的通用工具。

从功能需求上进行分析，网络爬虫框架有几个以下组件构成：
- 下载器，下载与给定网络地址的内容。其中，在下载请求的组装方面，网络爬虫框架为使用者尽量预留出定制接口。使用者可以使用这些接口自定义“请求”的组装方法
- 分析器，分析下载的内容，并从中筛选出可用的部分和需要访问的新网络地址。由使用者定义筛选的规则和策略
- “分析器”把筛选出的“条目”发送给“条目处理管道”。同时，它会把发现的新网络地址和其他一些信息组装成新的下载“请求”，支持用户自定义函数注册功能。结果是请求发送给“下载器”。
- 调度器模块，调度各个处理模块的运行，其中包括维护各个处理模块的实例、在不同的处理模块实例之间传递数据，以及监控所有这些被调度者的状态。

调度器是核心，除调度器之外的其他模块都可以是多实例的，甚至可以分布在多机上。

缓冲池和缓冲器的设计，缓冲器是缓冲池的底层支持，池是器的再封装。这些主要是为了扩展channel 类型的功能，channel 有两个会引发运行时恐慌的操作：向一个已关闭的通道发送值和关闭一个已关闭的通道。缓冲器接口类型就是为了解决这两个问题而设计，具体设置一个 Closed 方法，去检查缓冲器的关闭状态。
![[Pasted image 20250426170854.png]]
改进与提升：分布式网络爬虫

原本组件都必须与调度器同处于一个进程，组件 ID 中可以包含组件的网络地址，为每类组件编写客户端和服务端。