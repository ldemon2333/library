

![[Pasted image 20250426144014.png]]
# ✅ 三色标记（Tri-color marking）是什么？

它是一种**遍历对象图**、并确定哪些对象需要回收的策略。

**把所有对象分成三类：**

|颜色|含义|
|:--|:--|
|**白色**|尚未访问到，未来要被回收的对象|
|**灰色**|已经访问到，但它的子对象还没有全部检查|
|**黑色**|已访问且其所有子对象也都安全（不会被回收）|

---

# 🎯 过程概览（简化版）

1. **一开始：**  
    所有对象都是白色。
    
2. **找到根对象（Root Set，如全局变量、栈上的变量）**：  
    把这些对象染成灰色，放进一个“灰色队列”里。
    
3. **处理灰色对象：**
    
    - 从灰色队列取出一个对象。
        
    - 把它引用的所有白色子对象染成灰色（即，保护子对象不会被回收）。
        
    - 自己染成黑色（说明自己已经彻底处理完了）。
        
4. **当没有灰色对象时，扫描结束：**
    
    - 剩下的白色对象就是**不可达**的垃圾，统一回收。
        
    - 黑色对象是活的，继续存在。
        

---

# 📌 举个超简单例子：

假设堆上有这些对象和引用关系：

```
Root --> A --> B
           \
            --> C

D （没人引用它）
```

初始时：

- A、B、C、D 都是白色。
    

开始扫描：

- Root 指向 A → A染灰。
    
- 处理 A：
    
    - A 指向 B → B染灰。
        
    - A 指向 C → C染灰。
        
    - A染黑。
        
- 处理 B、C（一样的）：
    
    - 没有进一步引用，直接染黑。
        
- D 没人引用，保持白色。
    

扫描完：

- A、B、C 黑色（存活）
    
- D 白色（垃圾，回收）
    

---

# 🧠 为什么要三色？

- **灰色**是缓冲区：确保即使还没完全检查子对象，父对象不会被回收。
    
- **黑色对象不会指向白色对象**，否则就意味着GC漏掉了需要保留的对象（这个称为**三色不变式**）。
    
- 这样即使在程序运行中（mutator不断创建新引用），GC也可以正确、安全地进行。
    

---

# 🚀 在 Go 语言中，三色标记还有：

- **写屏障（Write Barrier）**：  
    在 Go 的并发 GC 中，程序运行和GC是并行的。  
    当程序修改指针（例如A突然多指向了D）时，写屏障负责记录这些变化，避免遗漏。
    
- **增量式、并发式收集**：  
    Go的GC不是“一下子停掉所有程序”，而是尽量边跑边清理，用了很多优化，三色标记是基础之一。
    

---

# 🔥 总结一句话：

> 三色标记就是“灰色推进、黑色确认、白色回收”，保证了并发和正确性！

太棒了！你已经掌握三色标记，继续深入 Go 的写屏障（**Write Barrier**）机制，GC 的核心你就快吃透了 😎

---

## 🔧 什么是“写屏障”？

**写屏障是一种用于追踪程序中内存引用变更的机制。**

在 Go 的并发 GC 中，程序（mutator）在运行过程中会不停地修改内存，例如：

```go
a.child = b  // 把 b 的引用赋值给 a
```

这会破坏我们前面说的“三色不变式”❗️

所以：**每次 mutator 修改指针时，都必须通知 GC —— 就是写屏障的作用！**

---

## 🎯 写屏障解决的问题？

GC 扫描过程中，对象不断被修改，例如：

- 黑色对象 A 指向了一个白色对象 D（未标记）
    
- 如果不记录，D 最终会被 GC 回收，产生**悬空引用（Dangling Pointer）**
    
- 这就违反了“三色不变式”
    

所以写屏障就像“快递单”📦，记录这些关键的引用变化，让 GC **补扫**回来。

---

## 📌 Go 的写屏障主要用了两种策略（关键！）

### 1. Dijkstra Barrier（删除屏障）

在 **赋值前** 添加写屏障：

```go
// 原始写操作：
x.field = y

// 有写屏障后的行为：
if x 是黑色 && y 是白色：
    将 y 染成灰色
x.field = y
```

**确保不会出现黑色指向白色！**

---

### 2. Yuasa Barrier（插入屏障）

在 **赋值后** 添加写屏障：

```go
x.field = y
if y 是白色：
    将 x 重新标成灰色（让 GC 再扫一次）
```

**确保对新的引用重新扫描**

---

## 🧠 Go 实际使用的是哪种？

Go 使用的是：**Hybrid Write Barrier** —— 混合了 Dijkstra 和 Yuasa 的优点。

Go 的做法是：

```go
func writePointer(dst *uintptr, src uintptr) {
    if GC 正在标记中：
        // 记录 "谁指向了谁"
        添加记录(dst)
    *dst = src
}
```

GC 在运行时会设置状态，决定写屏障是否开启。

---

## ⚠️ 注意事项：

- 写屏障只作用于“指针写入”，非指针字段（如 `int`、`float`）不会触发。
    
- Go GC 主要是并发标记 + STW（Stop The World）清扫。
    
- 写屏障是实现并发标记的核心，保证即使 mutator 修改了对象图，GC 也不会漏掉。
    

---

## 🔚 总结一句话：

> 写屏障就是：**记录指针变化，避免 GC 把还在用的对象错杀！**

# 什么是 GC
通常，垃圾回收器的执行过程被划分为两个半独立的组件：

- 赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。
- 回收器（Collector）：负责执行垃圾回收的代码。

## 根对象到底是什么？
根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：

1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

## 常见的 GC 实现方式有哪些？ Go 语言的 GC 使用的是什么？
所有的 GC 算法其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这两种形式的混合运用。

- 追踪式 GC
    
    从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。
    
- 引用计数式 GC
    
    每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC。

目前比较常见的 GC 实现方式包括：

- 追踪式，分为多种不同类型，例如：
    - 标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。
    - 标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。
    - 增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，达到近似实时、几乎无停顿的目的。
    - 增量整理：在增量式的基础上，增加对对象的整理过程。
    - 分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。
- 引用计数：根据对象自身的引用计数来回收，当引用计数归零时立即回收。

对于 Go 而言，Go 的 GC 目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不
对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。原因[1]在于：

1. 对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于 tcmalloc 的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。
2. 分代 GC 依赖分代假设，即 GC 将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。但 Go 的编译器会通过**逃逸分析**将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。并且 Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。

## 三色标记法是什么？
理解**三色标记法**的关键是理解对象的**三色抽象**以及**波面（wavefront）推进**这两个概念。三色抽象只是一种描述追踪式回收器的方法，在实践中并没有实际含义，它的重要作用在于从逻辑上严密推导标记清理这种垃圾回收方法的正确性。也就是说，当我们谈及三色标记法时，通常指标记清扫的垃圾回收。

从垃圾回收器的视角来看，三色抽象规定了三种不同类型的对象，并用不同的颜色相称：

- 白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
- 灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。
- 黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

这样三种不变性所定义的回收过程其实是一个**波面**不断前进的过程，这个波面同时也是黑色对象和白色对象的边界，灰色对象就是这个波面。

当垃圾回收开始时，只有白色对象。随着标记过程开始进行时，灰色对象开始出现（着色），这时候波面便开始扩大。当一个对象的所有子节点均完成扫描时，会被着色为黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象为可达对象，即存活；而白色对象为不可达对象，即死亡。这个过程可以视为以灰色对象为波面，将黑色对象和白色对象分离，使波面不断向前推进，直到所有可达的灰色对象都变为黑色对象为止的过程。如下图所示：
![[Pasted image 20250506122156.png]]

## STW 是什么意思？
`STW` 可以是 `Stop the World` 的缩写，也可以是 `Start the World` 的缩写。通常意义上指指代从 `Stop the World` 这一动作发生时到 `Start the World` 这一动作发生时这一段时间间隔，即万物静止。STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程。

在这个过程中整个用户代码被停止或者放缓执行， `STW` 越长，对用户代码造成的影响（例如延迟）就越大，早期 Go 对垃圾回收器的实现中 `STW` 长达几百毫秒，对时间敏感的实时通信等应用程序会造成巨大的影响。我们来看一个例子：
```go
package main

import (
	"runtime"
	"time"
)

func main() {
	go func() {
		for {
		}
	}()

	time.Sleep(time.Millisecond)
	runtime.GC()
	println("OK")
}
```
上面的这个程序在 Go 1.14 以前永远都不会输出 `OK`，其罪魁祸首是进入 STW 这一操作的执行无限制的被延长。

尽管 STW 如今已经优化到了半毫秒级别以下，但这个程序被卡死原因是由于需要进入 STW 导致的。原因在于，GC 在需要进入 STW 时，需要通知并让所有的用户态代码停止，但是 `for {}` 所在的 goroutine 永远都不会被中断，从而始终无法进入 STW 阶段。实际实践中也是如此，当程序的某个 goroutine 长时间得不到停止，强行拖慢进入 STW 的时机，这种情况下造成的影响（卡死）是非常可怕的。好在自 Go 1.14 之后，这类 goroutine 能够被异步地抢占，从而使得进入 STW 的时间不会超过抢占信号触发的周期，程序也不会因为仅仅等待一个 goroutine 的停止而停顿在进入 STW 之前的操作上。

## 什么是写屏障、混合写屏障，如何实现？
要讲清楚写屏障，就需要理解三色标记清除算法中的**强弱不变性**以及**赋值器的颜色**，理解他们需要一定的抽象思维。写屏障是一个在并发垃圾回收器中才会出现的概念，垃圾回收器的正确性体现在：**不应出现对象的丢失，也不应错误的回收还不需要回收的对象。**

可以证明，当以下两个条件同时满足时会破坏垃圾回收器的正确性：

- **条件 1**: 赋值器修改对象图，导致某一黑色对象引用白色对象；
- **条件 2**: 从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。

只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：

- 如果条件 1 被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；
- 如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。

我们不妨将三色不变性所定义的波面根据这两个条件进行削弱：

- 当满足原有的三色不变性定义（或上面的两个条件都不满足时）的情况称为**强三色不变性（strong tricolor invariant）**
- 当赋值器令黑色对象引用白色对象时（满足条件 1 时）的情况称为**弱三色不变性（weak tricolor invariant）**


