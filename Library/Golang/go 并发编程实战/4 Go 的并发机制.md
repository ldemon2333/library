不要用共享内存的方式来通信，以通信作为手段来共享内存。

使用 channel，用来在多个 goroutine 之间传递数据。

## 4.1.1 线程实现模型
M：machine，工作线程（内核线程）
P：processor，一个 P 代表执行一个 Go 代码片段所必需的资源（上下文环境）
G：goroutine

一个 G 的执行需要 P 和 M 的支持。一个 M 在与一个 P 关联之后，就形成了一个有效的 G 运行环境（内核线程+上下文环境）。每个 P 都会包含一个可运行的 G 的队列（runq）。该队列中的 G 会被依次传递给与本地 P 关联的 M，并获得运行时机。
![[Pasted image 20250312194514.png]]
可以看到，M 与 KSE 之间总是一对一的关系，一个 M 能且仅能代表一个内核线程。M 与 P 之间也总是一对一，而 P 与 G 是一对多关系。

### M
一个 M 代表了一个内核线程。在大多数情况下，创建一个 M，都是由于没有足够的 M 来关联 P 并运行其中可运行的 G。
![[Pasted image 20250312194641.png]]

字段 g0 表示一个特殊的 goroutine。这个 goroutine 是 Go 运行时系统在启动之初创建的，用于执行一些运行时任务。字段 mstartfn 就是编写 go 语句时携带的函数。字段 curg 会存放当前 M 正在运行的那个 G 的指针，字段 p 的值则会指向与当前 M 相关联的那个 P。字段 nextp 用于暂存与当前 M 有潜在关联的 P。把调度器将某个 P 赋给某个 M 的 nextp 字段的操作，称为对 M 和 P 的预联。运行时系统有时候会把刚刚重新启动的 M 和已与它预联的那个 P 关联在一起，这也是 nextp 字段的主要作用。字段 spining 是 bool 类型的，它用于表示这个 M 是否正在寻找可运行的 G。在寻找过程中，M 会处于自旋状态。Go 运行时系统可以把一个 M 和一个 G 锁定在一起。一旦锁定，这个 M 就只能运行这个 G，这个 G 也只能由该 M 运行。runtime 中的函数 LockOSThread 和 UnlockOSThread，也为我们提供了锁定和解锁的具体方法。M 字段 lockedg 表示的就是与当前 M 锁定的那个 G。

M 在创建之初，会被加入全局的 M 列表（runtime.allm）中。这时，它的起始函数和预联的 P 也会被设置。最后，运行时系统会为这个 M 专门创建一个新的内核线程并与之相关联。其中，起始函数仅当运行时系统要用此 M 执行系统监控或垃圾回收等任务的时候才会被设置。运行时系统在需要的时候，会通过它获取到所有的 M 的信息。同时，它也可以防止 M 被当作垃圾回收掉。

在新 M 被创建之后，Go 运行时系统会先对它进行一番初始化，其中包括对自身所持的栈空间以及信号处理方面的初始化。在这些初始化工作都完成之后，该 M 的起始函数会执行（如果存在的话）。注意，如果这个起始函数代表的是系统监控任务的话，那么该 M 会一直执行它，而不会继续后面的流程。否则，在起始函数执行完毕之后，当前 M 将会与那个预联的 P 完成关联，并准备执行其他任务。M 会依次在多出寻找可运行的 G 并运行之。这一过程也是调度的一部分。

运行时系统管辖的 M （runtime.allm 中的 M）有时候也会被停止，比如在运行时系统执行垃圾回收的过程中。运行时系统在停止 M 的时候，会把它放入调度器的空闲 M 列表（runtime.sched.midle）。这也很重要，因为在需要一个未被使用的 M 时，运行时系统会先尝试从该列表中获取。M 是否空闲，仅以它是否存在于调度器的空闲 M 列表中为依据。

### P
P 是 G 能够在 M 中运行的关键。Go 的运行时系统会适时地让 P 与不同的 M 建立或断开关联，以使 P 中的哪些可运行的 G 能够及时获得运行时机，这与 OS 内核在 CPU 之上实时的切换不同的进程或线程的情形类似。

P 的最大数量实际上是对程序中并发运行的 G 的规模的一种限制。P 的数量即为可运行 G 的队列的数量。一个 G 在被启用后，会先被追加到某个 P 的可运行 G 队列中，以等待运行时机。一个 P 只有与一个 M 关联在一起，才会使其可运行 G 队列中的 G 有机会运行。当 M 因系统调用而阻塞（是它运行的 G 进入了系统调用）的时候，运行时系统会把该 M 和与之关联的 P 分离开来。这时，如果这个 P 的可运行 G 队列中还有未被运行的 G，那么运行时系统就会找到一个空闲 M，或创建一个新的 M，并与该 P 关联以满足这些 G 的运行需要。

在确定 P 最大数量之后，运行时系统会根据这个数值重整全局的 P 列表（runtime.allp）。与全局 M 列表类似，该列表中包含了当前运行时系统创建的所有 P。运行时系统会把这些 P 中的可运行 G 全部取出，并放入调度器的可运行 G 队列中。这是调整全局 P 列表的一个重要前提。

P 本身是有状态的，
- Pidle。当前 P 未与任何 M 存在关联
- Prunning。当前 P 正在与某个 M 关联
- Psycall。当前 P 中运行的那个 G 正在进行系统调用。
- Pgcstop。表面运行时系统需要停止调度。例如，运行时系统在开始垃圾回收的某些步骤前，就会试图把全局列表中的所有 P 都置于此状态。
- Pdead。当前 P 已经不会再被使用。
![[Pasted image 20250317145417.png]]

非 Pdead 状态的 P 都会在运行时系统欲停止调度时被置于 Pgcstop 状态。不过，等到需要重启调度的时候（如垃圾回收后），它们并不会被恢复至原有状态，而会被统一地转换为 Pidle 状态。也就是说，它们会被放到同一起跑线上，并公平的接收再次调度。另一方面，非 Pgcstop 状态的 P 都可能因全局 P 列表的缩小而被认为是多余的，并被置于 Pdead 状态。

在 P 的结构中，可运行 G 队列和自由 G 列表是最重要的两个成员。

### G
Go 的编译器会把 go 语句编变成对内部函数 newproc 的调用，并把 go 函数及其参数都作为参数传递给这个函数。

运行时系统在接到这样一个调用之后，会先检查 go 函数及其参数的合法性，然后试图从本地 P 的自由 G 列表和调度器的自由 G 列表获取可用的 G，如果没有获取到，就新建一个 G。与 M 和 P 相同，运行时系统也持有一个 G 的全局列表（runtime.allgs）。新建的 G 会在第一时间被加入该列表。

![[Pasted image 20250317215828.png]]

![[Pasted image 20250317150406.png]]

### 核心元素的容器
![[Pasted image 20250317150450.png]]

与 G 相关的那 4 个非全局容器：

任何 G 都会存在于全局 G 列表中，而其余的 4 个容器则只会存放在当前作用域内的、具有某个状态的 G。注意，这里的两个可运行 G 列表中的 G 都拥有几乎平等的运行机会。我们无需关心哪些可运行的 G 会进入哪个队列。

## 4.1.2 调度器
其实，每个 M (即每个内核线程)在运行过程中都会按需执行一些调度任务。
### 基本结构
![[Pasted image 20250317220155.png]]
在这张表中的字段都与需要停止调度的任务有关。在 Go 运行时系统中，一些任务在执行前是需要暂停调度的，例如垃圾回收任务中的某些子任务，又如发起运行时恐慌（panic）的任务。暂且把这类任务称为串行运行时任务。

字段 gcwaiting、stopwait 和 stopnote 都是串行运行时任务执行前后的辅助协调手段；gcwaiting 字段在停止调度前，该值会被设置为 1；在恢复调度之前，该值会被设置为 0。这样做的作用是，一些调度任务在执行时只要发现 gcwaiting 的值为 1，就会把当前 P 的状态置为 Pgcstop，然后自减 stopwait 字段的值。如果发现自减后的值为 0，就说明所有 P 的状态都已为 Pgcstop。这时就可以利用 stopnote 字段，唤醒因等待调度停止而暂停的串行运行时任务了。

字段 sysmonwait 和 sysmonnote 与前面那一组字段的用途类似。只不过它们针对的是系统监测任务。在串行运行时任务执行之前，系统检测任务也需要暂停。sysmonwait 字段的作用就是表示是否已暂停，0 表示未暂停，1 表示已暂停。系统监测任务是持续执行的；更确切地说，它处在无尽的循环中。在每次迭代之初，系统监测程序都会先检查调度情况。一旦发现调度停止（gcwaiting 字段的值不为 0 或所有的 P 都已闲置），就会把 sysmonwait 字段的值设置为 1，并利用 sysmonnote 字段暂停自身。另一方面，在恢复调度之前，调度器若发现 sysmonwait 字段的值不为 0，就会把它置为 0，并利用 sysmonnote 字段恢复系统监测任务的执行。

上述 5 个调度器字段都是为了串行运行时任务而存在的。并且，运行时系统一定会保证操作它们时的并发安全。

### 一轮调度
引导程序会为 Go 程序的运行建立必要的环境。在引导程序完成一系列初始化工作之后，Go 程序的 main 函数才会真正执行。引导程序会在最后让调度器进行一轮调度，这样才能够让封装了 main 函数的 G 马上有机会运行。

![[Pasted image 20250318195954.png]]
一轮调度，由 Go 标准库代码包 runtime 中的 schedule 函数代表。调度器会先从一些比较容易找打可运行 G 的地方入手，即：全局的（或称调度器的）可运行 G 队列和本地 P 的可运行 G 队列。如果从这些地方找不到可运行的 G，调度器程序就会进入强力查找模式，如果经过一番强力查找还是无法找到任何可运行的 G，该子流程就会暂停，直到有可运行的 G 出现才会继续下去。也就是说，这个全力查找可运行 G 的子流程的结束，就意味着当前 M 抢到了一个可运行的 G。

在一轮调度的开始处，调度器会先判断当前 M 是否已被锁定。M 和 G 是可以成对地锁定在一起。已知，Go 的调度器会按照一定策略动态地关联 M、P 和 G，并以此高效地执行并发程序，其优势就在于无需用户程序的任何干预。然而，在极少数的情况下，用户程序不得已要对 Go 的运行时调度进行干预。

锁定 M 和 G 的操作可以说是为 CGO 准备的。CGO 代表了 Go 中的一种机制，是 Go 程序和 C 程序之间的一座桥梁，使它们的互相调用成为可能。

可以通过调用 runtime.LockOSThread 函数，把当前的 G 与当时运行它的那个 M 锁定在一起，也可以通过调用 runtime.UnlockOSThread 函数解除当前 G 与某个 M 的锁定。一个 M 只能与一个 G 锁定，反之亦然。所以，如果多次调用 runtime.LockOSThread 函数，那么仅有最后一次调用是有效的。

如果调度器在一轮调度之初发现当前 M 已与某个 G 锁定，就会立即停止调度并停止当前 M（或者说让它暂时阻塞）。一旦与它锁定的 G 处于可运行状态，它就会被唤醒并继续运行那个 G。停止当前 M 意味着相关的内核线程不能再去做其他事情了。此时，调度器也不会为当前 M 寻找可运行的 G。这相当于在浪费计算资源。相应的，当调度器为当前 M 找到了一个可运行的 G，但却发现该 G 已与某个 M 锁定，它就会唤醒那个与之锁定的 M 以运行该 G，并重新为当前 M 寻找可运行的 G。

Go 调度器并不是运行在某个专用内核线程中的程序，调度程序会运行在若干已存在的 M（或者说内核线程）之中。

### 全力查找可运行的 G
这个子流程会多次尝试从各处搜索可运行的 G，甚至还会从别的 P（非本地 P）那里偷取可运行的 G。它由 runtime.findrunnable 函数代表，该函数会返回一个处于 Grunnable 状态的 G。其中的搜索流程大致分为 2 个阶段和 10 个步骤，具体如下。

（1） 获取执行终结器的 G。
（2）从本地 P 的可运行 G 队列获取 G。
（3）从调度器的可运行 G 队列获取 G
（4）从网络 I/O 轮询器（或称 netpoller）处获取 G。如果 netpoller 已被初始化且已有过网络 I/O 操作，那么调度器会试着从 netpoller 那里获取一个 G 列表，并把作为表头的那个 G 当作结果返回，同时把其余的 G 都放入调度器的可运行 G 队列。
（5）从其他 P 的可运行 G 队列获取 G。
（6）获取执行 GC 标记任务的 G。
（7）
（8）
（9）
（10）

netpoller 是 Go 为了在 OS 提供的异步 I/O 基础组件之上，实现自己的阻塞式 I/O 而编写的一个子程序。

# 4.2 goroutine
go 函数并发执行，但谁先谁后并不确定。

虽然 go 函数是可以有结果声明的，但是它们返回的结果值会在其执行完成时被丢弃。

```
package main

import (
	"fmt"
	"runtime"
)
func main(){
	names := []string{"Eric", "Harry", "Robert", "Jim", "Mark"}
	for _, name := range names{
		go func(){
			fmt.Printf("Hello, %s!\n", name)
		}()
	}
	time.Sleep(time.Millisecond)
}
```

在这里并发执行的 5 个 go 函数中，name 的值都是“Mark”，因为它们都是在 for 语句执行完毕之后才执行的，而 name 在那时指代的值已经是 “Mark”了。

改进，在 go 函数中使用的 name 的值不会受到外部变量变化的影响，就既可以保证 go 函数的独立执行，又不用担心它们的正确性受到破坏。若这个设想被实现了，该 go 函数就可以称为“可重入函数”。

name 的变量的类型 string 是一个非引用类型。对于引用类型的值来说，复制的是指针。上述设想的实现代码为
```
package main

func main(){
	names := []string{"", "", "", ""}
	for _, name :=range namse{
		go func(who string){
			fmt.Printf("Hello, %s!\n", who)
		}(name)
	}
	time.Sleep()
}
```

上述方案最多只能保证 go 函数执行的正确性，却无法保证这些 go 函数总会先于 main 函数执行完毕，即使使用 time.Sleep 函数或 runtime.Gosched 函数也是如此。

## 4.2.2 主 goroutine 的运作
封装 main 函数的 goroutine 称为主 goroutine。主 goroutine 会由 runtime.m0 复制运行。

## 4.2.3 runtime 包与 goroutine
runtime.GOMAXPROCS 函数
通过调用 runtime.GOMAXPROCS 函数，用户程序可以在运行期间，设置常规运行时系统中的 P 的最大数量。但因为这样做会引起 “Stop the world"。

runtime.Goeixt
会立即使当前 goroutine 的运行终止，而其他 goroutine 并不会受此影响。runtime.Goexit 函数在终止当前 goroutine 之前，会先执行 goroutine 中所有还未执行的 defer 语句。该函数会把被终止的 goroutine 置于 Gdead 状态，并将其放入本地 P 的自由 G 列表，然后触发调度器的一轮调度流程。

runtime.Gosched 函数
暂停当前 goroutine 的运行。当前 goroutine 会被置为 Grunnable 状态，并放入调度器的可运行 G 队列；

# 4.3 channel
以通信为手段来共享内存，channel

通道类型是一个引用类型，所以一个通道类型的变量在被初始化之前，其值一定是 nil，这也是此类型的零值。

已知，引用类型的值都需要使用内建函数 make 来初始化

无缓冲通道。发送它的元素值应该被立刻取走，否则发送方的 goroutine 就会被暂停（或者说阻塞），直到有接收方接收这个元素值。
```
elem, ok := <- strChan
```
当接收操作因通道关闭而结束时，该 ok 值会为 false

试图从一个未被初始化的通道值（即值为 nil 的通道）那里接收元素值，会造成当前 goroutine 的永久阻塞！

Happens before
对于一个缓冲通道，有如下规则：
- 发送操作会使通道复制被发送的元素。若因通道的缓冲空间已满而无法立即复制，则阻塞进行发送操作的 goroutine。复制的目的地址有两种。当通道已空且有接收方在等待元素值时，它会是最早等待的那个接收方持有的内存地址，否则会是通道持有的缓冲中的内存地址。
- 接收操作会使通道给出一个已发给它的元素值的副本，若因通道的缓冲空间已空而无法立即给出，则阻塞进行接收操作的 goroutine。
- 对于同一个元素值来说，把它发送给某个通道的操作，一定会在从该通道接收它的操作完成之前完成。换句话说，在通道完全复制一个元素值之前，任何 goroutine 都不可能从它那里接收到这个元素值得副本。

struct{} 代表的是不包含任何字段的结构体类型，也可称为空结构体类型。在 Go 语言中，空结构体类型的变量是不占用内存空间的，并且所有该类型的变量都拥有相同的内存地址。用于传递“信号”的通道。

发送方向通道发送的值会被复制，接收方接收的总是该值的副本，而不是该值本身。经由通道传递的值至少会被复制一次，至多会被复制两次。例如，当向一个已空的通道发送值，且已有至少一个接收方因此等待时，该通道会绕过本身的缓冲队列，直接把这个值复制给最早等待的那个接收方。又例如，当从一个已满的通道接收值，且已有至少一个发送方因此等待时，该通道会把缓冲队列中最早进入的那个值复制给接收方，再把最早等待的发送方要发送的数据复制到那个值的原先位置上。通道的缓冲队列属于环形队列。涉及的那两个值在传递到接收方之前都会被复制两次。

因此，当接收方从通道接收到一个值类型的值时，对该值的修改不会影响到发送方持有的源值。但对于引用类型的值来说，这种修改会同时影响收发双方持有的值。

通道关闭之后，仍可以通知接收方进行接收。

### 长度与容量
内建函数 len 和 cap 也是可以作用在通道之上的，它们的作用分别是获取通道中当前的元素值数量（即长度）和通道可容纳元素值的最大数量（即容量）。可以通过容量来判断通道是否带有缓冲。若其容量为 0，那么它肯定就是一个非缓冲通道。

## 4.3.2 单向 channel
Go 不允许程序关闭接收通道，接收通道只能由发送发关闭。单向通道通常由双向通道转换而来。通道运行的数据传递方向是其类型的一部分，对于两个通道类型而言，数据传递方向的不同就意味着它们类型的不同。利用函数声明将双向通道转换为单向通道的做法，只能算是 Go 语言的一个语法糖。

## 4.3.3 for 语句与 channel
```
var ch chan int

for e := range ch{
	fmt.Printf(e)
}
```

当通道中没有任务元素值时，for 语句所在的 goroutine 也会陷入阻塞，阻塞的具体位置会在其中的 range 子语句处。

for 语句会不断地尝试从通道中接收元素值，直到该通道关闭。在通道关闭时，如果通道中已无元素值，那么这条 for 语句的执行就会立即结束。

## 4.3.4 select 语句
通道未被 make 初始化，向它们发送元素值的操作会被永久阻塞。

如果由多个 case 满足条件，那么运行时系统会通过一个伪随机的算法选中一个 case。另一方面，如果 select 语句中的所有 case 都不满足选择条件，并且没有 default case，那么当前 goroutine 就会一直被阻塞于此。
![[Pasted image 20250313153016.png]]


![[Pasted image 20250313152912.png]]
注意语句 break Loop，意为中断紧贴于该标签之下的那条语句的执行。这里 break for 循环。

## 4.3.5 非缓冲的 channel
与异步的方式传递元素值的缓冲通道不同，非缓冲通道只能同步地传递元素值。

与缓冲通道相比，针对非缓冲通道的 happens before 原则有两个特别之处，具体如下：
- 向此类通道发送元素值的操作会被阻塞，直到至少有一个针对该通道的接收操作进行为止。

只有针对非缓冲通道的发送发和接收方“握手”之后，元素值的传递才会进行。

由于非缓冲通道会以同步的方式传递元素值，在其上收发元素值得速度总是与慢的那一方持平。

## 4.3.6 time 与 channel
### 1. 定时器
使用定时器，可以实现对接收操作的超时设定
```
package main

func main(){
	intChan := make(chan int, 1)
	go func(){
		time.Sleep(time.Second)
		intChan <- 1
	}()
	select{
		case e := intChan:
			fmt.Printf("Received: %v\n", e)
		case <- time.NewTimer(time.Millisecond * 500).C:
			fmt.Println("Timeout!")
	}
}
```

可以用 time.After(time.Millisecond * 500) 替换之。与前者等价的。

### 2. 断续器
定时器需要依据初始化或重置时的时间来决定下一个绝对到期时间。然而，断续器一旦被初始化，所有的绝对到期时间就都已经确定了。


