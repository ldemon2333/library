# 5.1 锁的使用
互斥锁和读写锁

## 5.1.2 读写锁
读写锁即针对读写操作的互斥锁。可以分别针对读操作和写操作进行锁定和解锁操作。多个读操作之间不存在互斥关系。
```
func (*RWMutex) Lock()
func (*RWMutex) Unlock()

func (*RWMutex) RLock()
func (*RWMutex) RUnlock()
```

sync.RWMutex 类型还拥有一个指针方法——RLocker，该方法返回一个 sync.Locker 接口类型的值。sync.Locker 接口包含了两个方法：Lock 和 Unlock。针对该读写锁的读锁定操作和读解锁操作。

## 5.1.3 锁的完整示例


# 5.2 条件变量
函数声明：
```
func NewCond(l Locker) *Cond
```

条件变量总要与互斥量组合使用。这里唯一参数是 sync.Locker 类型的。具体参数可以是互斥锁，也可以是一个读写锁。

有 3 个方法：`Wait` , `Signal`, `Broadcast`。它们分别代表了等待通知、单发通知和广播通知的操作。

Wait 方法会自动地对与该条件变量关联的那个锁进行解锁，并且使它所在的 goroutine 阻塞。一旦接收到通知，该方法所在的 goroutine 就会被唤醒，并且该方法会立即尝试锁定锁，然后重新检查是否满足条件。


# 5.3 原子操作
如果想原子地把 uint32 类型的变量 ui32 的值增加 NN （NN 代表一个负整数），可以这样调用 
```
atomic.AddUint32(&ui32, ^uint32(-NN-1))
```

CAS 操作总是假设被操作值未曾改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换。CAS 做法趋于乐观。

CAS 操作的优势是：可以在不创建互斥量和不形成临界区的情况下，完成并发安全的值替换操作。大大减少同步对程序性能的损耗。劣势是：在被操作值被频繁变更的情况下，CAS 操作并不那么容易成功。使用 for 循环多次尝试
```
var value int32
func addValue(delte int32){
	for {
		v := value
		if atomic.CompareAndSwapInt32(&value, v, (v+delta)){
			break
		}
	}
}
```

这种做法与自旋锁行为相似。CAS 不会让 goroutine 阻塞，但是仍可能使流程的执行暂时停滞。

如果想并发安全地更新一些类型（前文所述的 6 个类型）的值，总是优先选择 CAS 操作。

int32, int64, uint32, uint64, uintptr, unsafe.Pointer


## 5.3.3 载入
原子读取某个值
```
func addValue(delta int32){
	for {
		v := atomic.LoadInt32(&value)
		if atomic.CompareAndSwapInt32(&value, v, (v+delta)){
			break
		}
	}
}
```

原子地读取变量 value 的值并把它赋给变量 v。

## 5.3.5 交换
与 CAS 操作不同，原子交换操作不会关心被操作值的旧值，而是直接设置新值。但它又比原子存储操作多做了一步：它会返回被操作值的旧值。

## 5.3.6 原子值
```
var atomicVal atomic.Value
```
该类型有两个公开的指针方法——Load 和 Store。

对于原子值实例的 Store 方法有两个限制。第一，作为参数传入该方法的值不能为 nil。第二，作为参数传入该方法的值必须与之前传入的值的类型相同。如果违反了任意一个限制，对该方法的调用都会引起一个运行时恐慌。

sync/atomic.Value 类型的变量一旦声明，其值就不应该被复制到它处。已知，作为源值赋给别的变量、作为参数值传入函数、作为结果值从函数返回、作为元素值通过通道传递等都会造成值的复制，所以这类变量之上不应该实施这些操作。

`atomic.Value` 是结构体类型（非指针类型），函数传参时发生值拷贝，在 `anotherStore` 中操作的只是原始值的副本

由于对原子值的读写操作必是原子的，同时又不受操作值类型的限制，因此它比原子函数的适用场景大很多。可以实现无锁化编程。

在修改原子值实例存储的值时，一定不要在得到旧值之后直接在上面修改。例如：
```
oldArray := array.val.Load().([]int)
oldArray[index] = elem
```
因为这样就相当于绕过了原子值提供的并发安全保护！切片类型属于引用类型，所以对它的值的复制并不会复制其底层的数组。在多个被并发调用的函数中读取或修改同一个切片值，必定会产生竞态条件。如果把存储值的类型由切片改为数组，这里就没有问题。不过，无论在原子值中存储什么类型的值，只要新值需要根据旧值计算得出，那么在有并发写操作的时候就可能出现问题。比如：
```
newArray := make([]int, array.length)
copy(newArray, array.val.Load().([]int))
newArray[index] = elem + newArray[index]
array.val.Store(newArray)
```

累加操作，导致的并发问题。并发且重复的操作只相当于累加了一次。

## 5.3.7 应用于实际
在 32 位计算架构的计算机上写入一个 64 位的整数，这也会存在并发安全方面的隐患。


# 5.4 只会执行一次
sync.Once 类型的典型应用场景就是执行仅需执行一次的任务。这样的任务并不都适合在 init 函数中执行。例如，数据库连接池的建立、全局变量的延迟初始化。

# 5.5 WaitGroup
sync.WaitGroup 类型的值是并发安全的，也是开箱即用的。有 3 个类型指针方法，即：Add、Done 和 Wait

通道的实现中拥有转为并发安全地传递数据而编写的数据结构和算法。不应该把通道当作互斥锁或信号量来使用。

计数周期

# 5.6 临时对象池
sync.Pool 类型值看作存放临时值的容器。此类容器是自动伸缩的、高效的，同时也是并发安全的。sync.Pool 类型的值称为“临时对象池”，而把存于其中的值称为“对象值”。

对象值生成函数

sync.Pool 类型有两个公开的指针方法：Get 和 Put。

第一个特性，临时对象池可以把由其中的对象值产生的存储压力进行分摊。更进一步说，它会专门为每一个与操作它的 goroutine 向关联的 P 建立本地池。在临时对象池的 Get 方法被调用时，它一般会先尝试从与本地 P 对应的那个本地私有池和本地共享池中获取一个对象值。如果获取失败，它就会试图从其他 P 的本地共享池中偷一个对象值并直接返回给调用方。如果依然未果，它就只能把希望寄托于当前临时对象池的对象值生成函数了。注意，这个对象值生成函数产生的对象值永远不会被放置到池中，而是会被直接返回给调用方。另一方面，临时对象池的 Put 方法会把它的参数值存放到本地 P 的本地池中。每个相关 P 的本地共享池中的所有对象值，都是在当前临时对象池的范围内共享的。也就是说，它们随时可能会被偷走。

第二个特性是对垃圾回收友好。垃圾回收的执行一般会使临时对象池中的对象值全部移除。也就是说，即使我们永远不会显示地从临时对象池取走某个对象值，该对象值也不会永远待在临时对象池中，它的生命周期取决于垃圾回收任务下一次的执行时间。

临时对象池的实例也不应该被复制，否则 go vet 命令报错。

