类型断言
```
v1.(I1)
```

一般这样做：先转换为接口值
```
interface{}(v1).(I1)
```

如果类型断言的结果为否，就意味着该类型断言是失败的。失败的类型断言会引发一个运行时恐慌（或称运行时异常），解决方法是：
```
var i1, ok := interface{}(v1).(I1)
```
如果成功，i1 就会是经过类型转换后的 I1 类型的值，否则它将会是 I1 类型的零值（或称默认值）。

string：字符串类型，一个字符串类型表示了一个字符串值的集合。字符串类型的值是不可变的，即一旦创建，其内容就不可改变。
1
数组长度不可变

切片值相当于对某个底层数组的引用。其内部结构包含了 3 个元素：指向底层数组中某个元素的指针、切片的长度以及切片的容量。

切片值的容量意味着，在不更换底层数组的前提下，它的长度的最大值。

```
ips = append(ips, "111")
```

赋值操作会把这个新的切片值再赋给 ips。注意，新，旧切片值可能指向不同的底层数组。若新切片值的底层数组的长度不足以完成元素追加操作，它将会被更长的底层数组替换，以容纳更多的元素。

值方法和指针方法遵循了如下规则：
- 接收者变量代表的值实际上是源值的一个赋值品。




# 短变量声明
在函数中，短赋值语句 `:=` 可在隐式确定类型的 `var` 声明中使用。

函数外的每个语句都 **必须** 以关键字开始（`var`、`func` 等），因此 `:=` 结构不能在函数外使用。

# 类型转换
表达式 `T(v)` 将值 `v` 转换为类型 `T`。

一些数值类型的转换：
![[Pasted image 20250115192644.png]]

或者，更加简短的形式：
![[Pasted image 20250115192656.png]]
与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换。试着移除例子中的 `float64` 或 `uint` 的类型转换，看看会发生什么。




与 C 不同，Go 没有指针运算。

# 结构体指针
结构体字段可通过结构体指针来访问。

如果我们有一个指向结构体的指针 `p` 那么可以通过 `(*p).X` 来访问其字段 `X`。 不过这么写太啰嗦了，所以语言也允许我们使用隐式解引用，直接写 `p.X` 就可以。




# map 映射
`map` 映射将键映射到值。

映射的零值为 `nil` 。`nil` 映射既没有键，也不能添加键。

`make` 函数会返回给定类型的映射，并将其初始化备用。

在你的代码中，`make(map[string]Vertex)` 是用于创建一个空的 `map` 类型（键为 `string`，值为 `Vertex`）的表达式。我们来详细解释 `make` 的作用：

### 1. `make` 的作用：分配内存

`make` 是 Go 语言内置的一个函数，专门用于初始化切片（slice）、映射（map）和管道（channel）。它的主要作用是**为这些数据类型分配内存并初始化**，让你可以开始使用它们。

### 2. `make(map[string]Vertex)` 解释：

`make(map[string]Vertex)` 会创建一个类型为 `map[string]Vertex` 的映射，并返回一个初始化好的空映射。具体来说，它做了两件事：

- **为 `map` 分配内存**：映射需要存储键值对的数据结构，所以必须在使用之前进行内存分配。
- **初始化映射**：`make` 会确保返回的 `map` 是有效的空映射，而不是 `nil`。如果你直接使用 `var m map[string]Vertex` 声明一个 `map`，它默认是 `nil`，如果没有使用 `make` 初始化，调用它时会导致运行时错误。

### 3. 为什么需要 `make`：

如果没有 `make`，你的 `m` 映射变量将是 `nil`。在向 `nil` 映射中添加键值对时，会导致程序崩溃（`panic`）。`make` 保证了映射是有效的，可以安全地进行存储操作。


# 修改映射
在映射 `m` 中插入或修改元素：
```go
m[key] = elem
```
获取元素：
```go
elem = m[key]
```
删除元素：
```go
delete(m, key)
```
通过双赋值检测某个键是否存在：
```go
elem, ok = m[key]
```
若 `key` 在 `m` 中，`ok` 为 `true` ；否则，`ok` 为 `false`。

若 `key` 不在映射中，则 `elem` 是该映射元素类型的零值。

**注**：若 `elem` 或 `ok` 还未声明，你可以使用短变量声明：

```go
elem, ok := m[key]
```

在 Go 中，`range` 关键字用于遍历数组、切片、映射（`map`）、通道（`channel`）等数据结构。它返回的值依赖于被遍历的类型。我们来详细介绍一下 `range` 在不同数据类型上返回的内容：

### 1. **遍历数组或切片（`[]T`）**：

- **返回：** `index, value`
    - `index` 是当前元素的索引。
    - `value` 是当前元素的值。

**示例：**

```go
arr := []string{"apple", "banana", "cherry"}
for index, value := range arr {
    fmt.Printf("Index: %d, Value: %s\n", index, value)
}
```

**输出：**

```
Index: 0, Value: apple
Index: 1, Value: banana
Index: 2, Value: cherry
```

**如果只需要值：**

```go
for _, value := range arr {
    fmt.Println(value)
}
```

**如果只需要索引：**

```go
for index := range arr {
    fmt.Println(index)
}
```

### 2. **遍历映射（`map`）**：

- **返回：** `key, value`
    - `key` 是当前元素的键。
    - `value` 是当前元素的值。

**示例：**

```go
m := map[string]int{"apple": 5, "banana": 3, "cherry": 7}
for key, value := range m {
    fmt.Printf("Key: %s, Value: %d\n", key, value)
}
```

**输出：**

```
Key: apple, Value: 5
Key: banana, Value: 3
Key: cherry, Value: 7
```

**如果只关心键：**

```go
for key := range m {
    fmt.Println(key)
}
```

**如果只关心值：**

```go
for _, value := range m {
    fmt.Println(value)
}
```

### 3. **遍历通道（`channel`）**：

- **返回：** `value`
    - 只有一个值，即通道中接收到的值。

**示例：**

```go
ch := make(chan string, 2)
ch <- "apple"
ch <- "banana"

close(ch)  // 关闭通道

for value := range ch {
    fmt.Println(value)
}
```

**输出：**

```
apple
banana
```

通道的 `range` 会在通道关闭并且所有数据都被读取完后停止遍历。

### 4. **遍历字符串（`string`）**：

- **返回：** `index, rune`（或 `index, byte`）
    - `index` 是当前字符的索引位置。
    - `rune` 是当前字符的 Unicode 值。

**示例：**

```go
str := "hello"
for index, runeVal := range str {
    fmt.Printf("Index: %d, Rune: %c\n", index, runeVal)
}
```

**输出：**

```
Index: 0, Rune: h
Index: 1, Rune: e
Index: 2, Rune: l
Index: 3, Rune: l
Index: 4, Rune: o
```

**如果只关心字符：**

```go
for _, runeVal := range str {
    fmt.Println(string(runeVal))
}
```

### 总结：

|数据类型|`range` 返回值|
|---|---|
|**数组/切片**|`index, value`|
|**映射（map）**|`key, value`|
|**通道（channel）**|`value`|
|**字符串（string）**|`index, rune` (或 byte)|

使用 `range` 时，你可以选择是否需要忽略其中一个返回值。通过使用 `_`（空白标识符），你可以忽略不需要的值。例如，如果你只关心 `map` 的键或值，可以使用 `_` 来忽略另一部分。

# 函数值
函数也是值。它们可以像其他值一样传递。

函数值可以用作函数的参数或返回值。

# 函数闭包
Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量值，换句话说，该函数被“绑定”到了这些变量。

例如，函数 `adder` 返回一个闭包。每个闭包都被绑定在其各自的 `sum` 变量上。


在 Go 中，**闭包**（Closure）是指一个函数可以访问其外部作用域（函数外部）的变量，哪怕这个外部作用域的函数已经返回。闭包让一个函数在其定义时“记住”并持续访问外部的变量，这些外部变量的状态随着函数的调用而发生变化。

### 代码解析

```go
package main

import "fmt"

// adder 返回一个闭包函数
func adder() func(int) int {
    sum := 0  // sum 是 adder 的外部变量
    return func(x int) int {
        sum += x  // 闭包函数使用了外部变量 sum
        return sum
    }
}

func main() {
    // pos 和 neg 都是闭包
    pos, neg := adder(), adder()

    for i := 0; i < 10; i++ {
        fmt.Println(
            pos(i),    // pos 闭包会增加 sum
            neg(-2*i), // neg 闭包会增加 sum
        )
    }
}
```

### 关键点：

1. **`adder` 函数：**
    
    - `adder` 是一个返回闭包的函数。
    - 在 `adder` 中，`sum` 变量是 **外部变量**，`sum` 是 `adder` 内部的局部变量，它会被 `adder` 返回的闭包所引用。
    - `return func(x int) int { ... }` 返回一个匿名函数（闭包），这个函数每次被调用时都能访问并修改外部的 `sum` 变量。
2. **`pos` 和 `neg`：**
    
    - `pos := adder()` 调用 `adder` 并得到一个闭包函数，闭包会“记住” `sum` 的初始值 0。
    - `neg := adder()` 也是调用 `adder` 返回一个新的闭包，每个 `adder` 调用都会返回一个独立的闭包，拥有自己的 `sum` 变量。
    - `pos(i)` 和 `neg(-2*i)` 都会改变各自闭包中的 `sum` 值。

### 闭包的工作原理：

- 每次调用 `adder()` 都会返回一个新的匿名函数，并且每个匿名函数都携带一个独立的 `sum` 变量。
- 当你调用 `pos(i)` 或 `neg(-2*i)` 时，闭包会访问并修改它各自的 `sum` 变量。这样，闭包能够“记住”每个独立调用中的 `sum` 状态，即使 `adder` 函数已经返回，`sum` 仍然在闭包中存在并被修改。

### 输出解释：

```text
0 0
1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90
```

- 对于 `pos(i)`，`sum` 从 0 开始，每次加上当前的 `i` 值。由于每次调用 `pos` 时使用的是相同的闭包，`sum` 累积增加。
- 对于 `neg(-2*i)`，`sum` 也是从 0 开始，每次加上 `-2*i`。因为每次调用 `neg` 使用的是独立的闭包，`sum` 在每个调用中独立累加。

### 闭包的特点：

1. **封闭外部变量**：闭包会“记住”它的外部变量，因此使得你可以在函数外部继续使用这些外部变量。
2. **延迟执行**：闭包可以在其外部函数已经执行完毕之后仍然保持对外部变量的访问权限。这是闭包的重要特性，尤其在需要延迟执行时非常有用。
3. **状态持久化**：闭包可以在多次调用中保持内部状态，这样可以在不借助外部存储（如全局变量）情况下存储状态。

### 总结：

- **闭包** 是一个函数值，它可以访问并修改其外部作用域中的变量。
- 在 Go 中，函数可以返回另一个函数，这个返回的函数可以访问它外部的变量，即使外部函数已经执行完毕。
- 通过使用闭包，我们可以实现一些有状态的计算或数据封装。




# 方法与指针重定向
比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：
```go
var v Vertex
ScaleFunc(v, 5)  // 编译错误！
ScaleFunc(&v, 5) // OK
```

而接收者为指针的的方法被调用时，接收者既能是值又能是指针：
```go
var v Vertex
v.Scale(5)  // OK
p := &v
p.Scale(10) // OK
```

对于语句 `v.Scale(5)` 来说，即便 `v` 是一个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 `Scale` 方法有一个指针接收者，为方便起见，Go 会将语句 `v.Scale(5)` 解释为 `(&v).Scale(5)`。

# 选择值或指针作为接收者
使用指针接收者的原因有二：

首先，方法能够修改其接收者指向的值。

其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样会更加高效。

在本例中，`Scale` 和 `Abs` 接收者的类型为 `*Vertex`，即便 `Abs` 并不需要修改其接收者。

通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。 （我们会在接下来几页中明白为什么。）






# 空接口
指定了零个方法的接口值被称为 *空接口：*
```go
interface{}
```
空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）

空接口被用来处理未知类型的值。例如，`fmt.Print` 可接受类型为 `interface{}` 的任意数量的参数。

# 类型断言
**类型断言** 提供了访问接口值底层具体值的方式。
```go
t := i.(T)
```
该语句断言接口值 `i` 保存了具体类型 `T`，并将其底层类型为 `T` 的值赋予变量 `t`。

若 `i` 并未保存 `T` 类型的值，该语句就会触发一个 panic。

为了 **判断** 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。
```go
t, ok := i.(T)
```
若 `i` 保存了一个 `T`，那么 `t` 将会是其底层值，而 `ok` 为 `true`。

否则，`ok` 将为 `false` 而 `t` 将为 `T` 类型的零值，程序并不会产生 panic。

请注意这种语法和读取一个映射时的相同之处。

# 类型选择
**类型选择** 是一种按顺序从几个类型断言中选择分支的结构。

类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。

```go
switch v := i.(type) {
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 i 的类型相同
}
```
类型选择中的声明与类型断言 `i.(T)` 的语法相同，只是具体类型 `T` 被替换成了关键字 `type`。

此选择语句判断接口值 `i` 保存的值类型是 `T` 还是 `S`。在 `T` 或 `S` 的情况下，变量 `v` 会分别按 `T` 或 `S` 类型保存 `i` 拥有的值。在默认（即没有匹配）的情况下，变量 `v` 与 `i` 的接口类型和值相同。





