在开发完成一个可运行的软件并且通过基本的功能测试之后，得到这个软件的性能数值。
- 这个软件到底能跑多快？
- 在高负载的情况下，该软件是否还能保证正确性。载荷数量与软件正确性之间的关系是怎么样的？
- 在保证一定正确性的条件下，该软件的可伸缩性是怎样的？
- 在软件可以正常工作的情况下，负载与系统资源使用率（包括 CPU、内存和各种 I/O 资源等）之间的关系是怎样的？

载荷发生器作为软件性能评测的辅助工具，它可以向被测软件发送指定量的载荷，并记录下被测软件处理载荷的结果。

# 参数和结果
## 重要的参数
首先，最重要的一点在于一个软件在给定运行环境下最多能够被多少个用户同时使用。QPS（Query Per Second）和 TPS（Transactions Per Second）前者针对的是对服务器上数据的读取操作，后者针对的是对服务器上数据的写入或修改操作。

其次，可靠性明确设定持续发送载荷的时间（负载持续时间）

第三个是载荷的处理超时时间（处理超时时间），即：从向软件发出的请求到接收到软件返回的响应的最大耗时。

我们在初始化载荷发生器的时候就应该给定上述 3 个参数，即每秒载荷量、负载持续时间和处理超时时间。载荷发生器根据这些参数自行计算出载荷发生以及发送的频率，并控制好并发量。

## 输出的结果
载荷发生器的输出有助于统计、分析和汇总出软件在承受给定负载的情况下所表现出的各个性能数值，以及像软件可以承受的最大载荷量，以及可以持续承受一定载荷量的最长时间这样的极限值。据此，我们应该在针对某一个载荷的结果中至少包含 3 块内容，即：请求和响应的内容、响应的状态以及请求处理耗时。

对于每一个载荷所产生的结果来说，都至少包含上述 3 块内容。那么，载荷发生器的输出就是按照响应的到达顺序排列的一个结果列表。计算出软件每秒处理载荷的数量。每秒载荷处理量一定小于或等于预先设定的每秒载荷量）。因为软件在处理某些载荷的时候可能会出错、失败或超时。

# 基本结构
首先确定载荷发生器的基本结构，在这个结构体声明中，肯定包含前面的 3 个参数：
![[Pasted image 20250314124817.png]]

负载发生器的输出是一个结果列表。负载发生器需要并发地发送载荷，因此也并发地输出结果。已知，数组和切片都不是并发安全的。Go 原生的数据类型中只有通道是并发安全的，它是收纳结果的绝佳容器。因此，将一个通道类型字段也加入载荷发生器的类型声明中：
![[Pasted image 20250314124920.png]]

![[Pasted image 20250314124951.png]]

![[Pasted image 20250314125101.png]]
使用它的指针类型作为通道的元素类型，可以减少元素值复制带来的开销。

根据响应超时时间和每秒载荷发送量，可以估算出所需的载荷发送的大致频率（载荷并发量），这个并发量也放在载荷发生器的结构内部，该字段声明如下：
```
concurrency uint32 // 载荷并发量
```
一旦确定了并发量，就有了控制载荷发生器使用系统资源的依据。怎样合理地控制程序所启用的 goroutine 的数量呢？过少的 goroutine 数量会使程序的并发程度不够，从而导致程序不能充分地利用系统资源；而过多的 goroutine 数量则可能会使程序的性能不升反降，会造成额外的负担。

这里可以用一个 goroutine 票池对此作出限定。此票池中票的数量就由 concurrency 字段的值决定。
![[Pasted image 20250314125529.png]]
context 包更加好用。同时向多个 goroutine 通知载荷发生器需要停止。

载荷发生器中应有这样的两个字段：
```
ctx context.Context //上下文
cancelFunc context.CancelFunc //取消函数
```
至此，又向载荷发生器的结构中加入了 4 个起控制作用的字段。再加入状态字段，要用并发安全的方式操作。 Go 标准库中提供的原子操作方法支持的最短数类型为 int32 和 uint32。
![[Pasted image 20250314125855.png]]
在添加这个字段之前，应该搞清楚载荷发生器需要提供哪些扩展支持。首先，载荷发生器的核心功能，肯定是控制和协调载荷的生成和发送、响应的接收和验证，以及最终结果的递交等一系列操作。所以，编写这样一个接口类型来体现可组件化的功能：
![[Pasted image 20250314130127.png]]

![[Pasted image 20250314130957.png]]


# 初始化
在 Go 中，一般会使用一类函数来创建和初始化比较复杂的结构体。这里函数的名称通常会以“New”作为前缀，并后跟相关的名词
```
func NewMyGenerator() *myGenerator
```
![[Pasted image 20250314131230.png]]
只要实现类要实现的接口中声明的方法——对应的 3 个方法。


concurrency 字段的值代表相关调用过程的并发执行数量。
$$
并发量 = 单个载荷的响应超时时间/载荷的发送间隔时间
$$
$$
concurrency = timeoutNS /(1e9/lps)+1
$$
含义是：在响应超时时间代表的某一个时间周期内的并发量的最大值。

性能测试软件要做的就是，先通过若干个预设的限定值模拟出一定程度的负载，然后再以此来测试并得到被测试软件实际能承受的最大负载。

计算并发量的最大意义是：为约束并发运行的 goroutine 的数量提供依据。依次数值确定载荷发生器的 tickets 字段所代表的那个 goroutine 票池的容量。

goroutine 票池看成一个 POSIX 标准中描述的多值信号量。一个 POSIX 多值信号量的值代表了可用资源的数量。线程池的概念。

# 启动和停止
调用载荷发生器的 Start 方法就可以启动它了。然后，载荷发生器会按照给定的参数向被测软件发送一定量的载荷。在触达了指定的负载持续时间之后，载荷发生器会自动停止载荷发送操作。在从启动到停止的这个时间段内，载荷发生器还会将被测软件对各个载荷的响应，以及载荷发送操作的最终结果收集起来，并发送提供的调用结果通道。

## 启动的准备
载荷发生器的 lps 字段值指明了它每秒向被测软件发送载荷的数量。可以得到发送间隔时间，表达式为 1e9 / lps。需要使用缓冲通道和断续器。
![[Pasted image 20250314171452.png]]
在真正使用节流阀之前，还有另外一个准备工作要做，即让载荷发生器能够在运行一段时间之后自己停下来。这里利用 context 包
```
gen.ctx, gen.cancelFunc = context.WithTimeout(context.Background(), gen.durationNS)
```

## 控制流程
```
func (gen *myGenerator) genLoad(throttle <- chan time.Time){
	for{
		select{
		case <- gen.ctx.Done():
			gen.prepareToStop(gen.ctx.Err())
				return 
		default:
		}
		gen.asyncCall()
		if gen.lps>0{
			select{
			case <- throttle:
			case <- gen.ctx.Done():
				gen.prepareToStop(gen.ctx.Err())
				return
			}
		}
	}
}
```
如果在等待节流阀到期通知的过程中接收到了上下文的“信号”，就需要立即为停止载荷发生器做准备。gen.ctx 字段的 Done 方法会返回一个接收通道，该通道会在上下文超时或取消时关闭，针对它的接收操作就会立即返回。这就是所说的上下文的“信号”。为什么在循环的开始处也有一个。由于 select 语句在多个满足条件的 case 之间做伪随机选择时的不确定性，当节流阀的到期通知和上下文的“信号”同时到达时，以使载荷发生器总能及时地停止。

## 异步调用


## 总结
对于载荷发生器、调用器以及 goroutine 票池，都使用了接口类型定义其行为，而后才是编写实现。通常情况下，暴露于包外的附带方法的类型都是接口类型，而不是作为实现的具体类型。此外，当你需要把某个函数暴露在包外，就要考虑它的参数列表在可预见的未来是否有变化的可能。如果是，就把参数列表封装成一个结构体类型，就像 ParamSet 类型那样。

channel 最大的使用场景是作为 goroutine 之间的数据传输通道。

# 调用器和功能测试
基于 TCP 协议的通信是使用字节流来传递上层给予的消息的。他会根据具体情况为消息分段，但却无法感知消息的分界。因此，需要显示地为请求数据添加结束符。