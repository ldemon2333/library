# 6.2 功能需求和分析
（1）“下载器”。在下载“请求”的组装方面，
（2）“分析器”分析下载到的内容，并从中筛选出可用的部分（“条目）和需要访问的新网络地址。
（3）“分析器“把筛选出的”条目“发送给”条目处理管道“。

![[Pasted image 20250317110758.png]]

作为一个框架，该程序在每个处理模块中给予使用者尽量多的定制方法，而不去涉及各个处理步骤的实现细节。另外，框架更多地考虑使用者自定义的处理步骤在执行期间可能发生的各种情况和问题，并注意对这些问题的处理方式，这样才能在易于扩展的同时保证框架的稳定性。

# 6.3 总体设计
一个 4 个模块
- 下载器：接收请求类型的数据，并依据该请求获得 HTTP 请求；将 HTTP 请求发送至与指定的网络地址对应的远程服务器；在 HTTP 请求发送完毕之后，立即等待相应的 HTTP 响应的到来；在收到 HTTP 响应之后，将其封装成响应并作为输出返回给下载器的调用方。其中，HTTP 客户端程序可以由网络爬虫框架的使用方自行定义。另外，若在该子流程执行期间发生了错误，应该立即以适当的方式告知使用方。
- 分析器：接收响应类型的数据，并依据该响应获得 HTTP 响应；对该 HTTP 响应的内容进行检查，并根据给定的规则进行分析、筛选以及生成新的请求或条目；将生成的请求或条目作为输出返回给分析器的调用方。
- 条目处理管道：框架不关心这些条目怎样被处理和持久化，它仅仅负责控制整体的处理流程。
- 调度器：调度各个处理模块的运行。

框架是以调度器为核心。
![[Pasted image 20250317111927.png]]

# 6.4 详细设计
## 6.4.1 基本数据结构
计算每个下载的网络内容的深度。请求结构体
```
type Request struct{
	httpReq *http.Request
	depth uint32
}
```

希望这个类型的值是不可变的。也就是说，在该类型的一个值创建和初始化之后，当前代码包之外的任何代码都不能更改它的任何字段值。对于这样的需求，一般会通过以下 3 个步骤来实现。
（1）把该类型的所有字段的访问权限设置为包级私有。


一个请求的深度值等于对它的父请求的深度值递增一次后的结果

面向接口编程


缓冲池和缓冲器的诞生是为了扩展通道类型的功能。

![[Pasted image 20250318202936.png]]

调度器在状态转换方面需要有一套规则，具体如下：
- 当调度器处于“正在”状态时，不能由外部触发状态的变化。也就是说，这时调度器不能被初始化、启动或停止。
- 处于未初始化状态时，调度器不能被启动或停止。

![[Pasted image 20250318203031.png]]

### 缓冲池和缓冲器
缓冲池和缓冲器是一对程序实体。缓冲器是缓冲池的底层支持。

对于通道类型，强调过两个会引发运行时恐慌的操作：向一个已关闭的通道发送值和关闭一个已关闭的通道。实际上，缓冲器接口及其实现就是为了解决这两个问题而存在。

### 多重读取器
io.Reader 接口（bytes.Reader、bufio.Reader 等），就肯定会知道通过这类读取器只能读取这一遍它们持有的底层数据。当读完底层数据时，它们的 Read 方法总会把 io.EOF 变量的值作为错误值返回。

一个分析器实例可以持有多个响应解析函数。由于 Body 字段值的上述特性，如果一个函数通过它读取了 HTTP 响应体，那么之后的函数就再也读不到这个 HTTP 响应体了。

设计一个可以多次提供基于同一底层数据的 io.ReadCloser 类型值的类型。把这个类型命名为 MultipleReader，意为多重读取器。
![[Pasted image 20250318204259.png]]

# 6.5 工具的实现
缓冲池这一层的核心功能恰恰就是动态伸缩。
## 6.5.1 缓冲器
![[Pasted image 20250318204536.png]]

缓冲器的实现就是对通道类型的简单封装，只不过增加了两个字段用于解决前面的两个 panic 问题。closingLock 字段代表了读写锁。解决在程序中并发地进行向通道发送值和关闭该通道操作问题而产生地竞态条件。

对于 Put 方法，应该使用读锁，因为 “向通道发送值”的操作会受到 “关闭通道”操作的影响。同时有多个读者需要向通道发送值。利用写锁的保护下关闭通道。如果不关闭通道，根本无需在进行发送操作时使用锁。

对于 Close 方法。在关闭通道之前，先要避免重复操作。因为重复关闭一个通道也会引发运行时恐慌。避免措施就是先检查 closed 字段的值。必须使用原子操作。这里使用 CAS 完成状态的转换。
![[Pasted image 20250318210625.png]]

## 6.5.2 缓冲池
bufCh 字段的类型是 chan Buffer。这与缓冲器中同样是通道类型的 ch 字段联合起来看，就是一个双层通道的设计。在放入或获取数据时，先从 bufCh 拿到一个缓冲器，再向该缓冲器放入数据或从该缓冲器获取数据，然后再把它发送回 bufCh。这样的设计有如下几点好处。

- bufCh 中的每个缓冲器一次只会被一个 goroutine 中的程序（并发程序）拿到。并且，在放回 bufCh 之前，它对其他并发程序都是不可见的。一个缓冲器每次只会被并发程序放入或取走一个数据。
- bufCh 是 FIFO。池中缓冲器的操作频率可以降到最低，这也有利于池中数据的均匀分布。
- 在从 bufCh 拿到缓冲器后，可以判断是否需要缩减缓冲器的数量。如果需要并且该缓冲器已空，就可以直接把它关掉，并且不还给 bufCh。另一方面，如果在放入数据时发现所有缓冲器都已满并且在一段时间内都没有空位，就可以新建一个缓冲器并放入 bufCh。总之，这让缓冲池自动伸缩功能的实现变得简单了。
- 最重要的是，bufCh 本身就提供了对并发安全的保障。

基于标准库的 container 包中的 List 或 Ring 类型也可以编写出并发安全的缓冲器队列。

怎样并发地向 bufCh 放入新的缓冲器，同时避免池中的缓冲器数量超过最大值。

Put 方法两个功能。第一个功能显然是向缓冲池放入数据。第二个功能是，在发现所有的缓冲器都已满一段时间后，新建一个缓冲器并将其放入缓冲池。如果当前缓冲池持有的缓冲器已达最大数量，就不能这么做。所有，首先需要建立一个发现和触发追加缓冲器操作的机制。规定当对池中所有缓冲器的操作的失败次数都达到 5 次时，就追加一个缓冲器入池。
![[Pasted image 20250318213146.png]]


![[Pasted image 20250318213540.png]]

这里使用双检锁。如果第一次条件判断通过，就会立即再做一次条件判断。不过在这之前，先锁定 rwlock 的写锁。这有两个作用：第一，防止向已关闭的缓冲池追加缓冲器。第二，防止缓冲器的数量超过最大值。确保读者已做完，防止缓冲器的数量超过最大值。

对于 Get 方法，若在遍历所有缓冲器 10 次之后仍无法获取到数据，Get 方法就会从缓冲池中去掉一个空的缓冲器。

向一个通道发送一个值，要考虑这个通道是否已关闭，否则会 panic。


# 6.5 多重读取器实现
标准库 io 中有一些非常实用的函数。这里用到的是 ReadAll 函数的功能是，通过作为参数的读取器读取所有底层数据，并忽略 io.EOF 错误。

多重读取器的 Reader 方法总是返回一个新的可关闭读取器。因此，可以利用它多次读取底层数据，并可以用该方法的结果值替代原先的 HTTP 响应的 Body 字段值很多次。

# 6.6 组件的实现
## 6.6.1 内部基础接口
Module 接口中声明的更多是获取内部状态的方法，比如：获取组件 ID、组件地址、各种计数值，等待。而在 ModuleInternal 接口中，添加的方法都是改变内部状态的方法。这个接口及其实现类型只是为了方便自行编写组件的人而准备的。


## 6.6.2 组件注册器
Get 方法的实现包含负载均衡的策略，并返回最“空闲”的那个组件实例：
![[Pasted image 20250319113700.png]]

该方法先调用注册器的 GetAllByType 方法以获得指定类型的组件实例的集合，然后在遍历它们时计算其评分，并找到评分最低者，最后返回。

## 6.6.3 下载器
![[Pasted image 20250319123438.png]]
匿名地嵌入了一个 stub.ModuleInternal 类型的字段，匿名字段。如此一来，myDownloader 类型的方法集合中就包含了 stub.ModuleInternal 类型的所有方法。因为，\*myDownloader 类型已经实现了 Module 接口。

另一个 http.Client 类型的字段用于对目标服务器发送 HTTP 请求并接收响应。http.Client 类型是做 HTTP 客户端程序的必选。

## 6.6.4 分析器
![[Pasted image 20250319132954.png]]
这里先依据 HTTP 响应的 Body 字段初始化一个多重读取器，然后在每次调用解析函数之前先从多重读取器那里获取一个新的读取器并对 HTTP 响应的 Body 字段重新赋值，这样就解决了 Body 字段值的底层数据只能读取一遍的问题。每个解析函数都可以顺利读出 HTTP 响应体。

## 6.6.5 条目处理管道
条目处理管道需要让条目依次经过那几个处理函数的加工。相比之下，分析器中的解析函数对 HTTP 响应的解析是相互独立的。

# 6.7 调度器的实现

## Init
综上所述，Init 方法做了 4 件事：检查调度器状态、检查参数、初始化内部字段以及注册组件实例。一旦这 4 件事都做完，调度器就为启动做好了准备。

## 启动
Start 方法首先要做的是防止启动过程中发生运行时恐慌。其次，它还需要检查调度器的状态和使用方提供的参数值，并把首次请求的主域名添加到可接收的主域名的字典。

### 1. 处理请求
处理请求需要下载器和请求缓冲池。

![[Pasted image 20250319141508.png]]
缓冲池的 Put 方法是阻塞的。所以，上面那条 go 语句的作用就是，当出现大量错误时，开一个协程去阻塞等待 put，同时保证爬取流程继续运行。

调度器的 download 方法只负责不断地获得请求，而 downloadOne 方法则负责获得一个下载器，并让它处理某个请求。

在编写程序的时候，可以让实现类似功能的代码呈现近似甚至一致的总体流程和基本结构。


### 分析器
分析器的 Analyze 方法在处理某个响应之后会返回两个结果值：数据列表和错误列表。其中，数据列表中的每个元素既可能是新请求也可能是新条目。
![[Pasted image 20250319142617.png]]

另一个节省资源的措施是，绝不处理重复的请求。重复的请求是靠调度器的 urlMap 字段值来过滤的。

sendReq 函数是数据在流转过程中要经历的第一道关卡

# 6.8 图片爬虫实现
分析器处理数据的速度肯定是最快的。其次是条目处理管道和下载器。

