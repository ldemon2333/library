# 3.2 多进程编程
在 Linux OS 中的 IPC 方法。从处理机制的角度看，可以分为：
- 基于通信的 IPC
- 基于信号的 IPC
- 基于同步的 IPC（信号量）

基于通信的 IPC 方法又分为以数据传送为手段的 IPC 方法和以共享内存为手段的 IPC，前者包括了管道（pipe）和消息队列。管道可以用来传送字节流，消息队列可以用来传送结构化的消息对象。以共享内存为手段的 IPC 方法主要以共享内存区为代表。它是最快的一种 IPC 方法。基于信号的 IPC 方法是唯一的一种异步 IPC 方法。

Go 支持的 IPC 方法有管道、信号和 socket。

## 3.2.3 管道
命名管道默认是阻塞式的。只有对这个命名管道的读操作和写操作都已经准备就绪之后，数据才开始流转。

管道是单向的，读端只能读，写端只能写。匿名管道会在管道缓冲区被写满之后使写数据的进程阻塞，以及命名管道会在其中一端未就绪前阻塞另一端的进程，需要并发执行分别操作两端。

命名管道可以被多路复用。所以，当有多个输入端同时写入数据的时候，要考虑操作原子性的问题。基于内存的有原子性操作保证的管道（内存管道）。
```
reader, writer := io.Pipe()
```

内存管道并不是基于文件系统的，并没有作为中介的缓冲区。

## 3.2.4 信号
IPC 中唯一一种异步的通信方法，它的本质是用软件来模拟硬件的中断机制。

再看 os/signal 代码包中的 Notify 和 Stop 函数。它们都是以 signal 接收通道为唯一标识来对相应的信号集合进行处理的。在 signal 处理程序的内部，存在一个包级私有的字典（信号集合字典），这个字典用于存放以 signal 接收通道为键并以信号集合的变体为元素的键值对。当我们调用 signal.Notify 函数时，signal 处理程序就会在信号集合字典中查找相应的键值对。如果键值对不存在，就会向信号集合字典添加一个，否则就更新该键值对中的信号集合变体。前者相当于向 signal 处理程序注册一个信号接收的申请，而后者则相当于更新该申请。当调用 signal.Stop 函数时，signal 处理程序会删除信号集合字典中。

在 Go 语言中，无缓冲通道（unbuffered channel）的发送操作会阻塞直到有对应的接收操作。在这段代码中：

```go
controlChan := make(chan bool)
controlChan <- true
```

程序在主 goroutine 中就试图向 `controlChan` 发送 `true`，但是此时还没有启动任何 goroutine 来从 `controlChan` 接收数据，从而导致发送操作一直阻塞，最终引发死锁。

解决方案可以是：

- 使用带缓冲的通道，例如：`controlChan := make(chan bool, 1)`，这样可以先存储数据再由其他 goroutine 读取。
- 或者把发送操作放到启动接收的 goroutine 后执行。

这样可以避免因为发送操作找不到接收者而产生的阻塞问题。

## 3.2.5 socket
可以通过网络连接让多个进程建立通信并相互传递数据。

每个 socket 都必将存在于一个通信域当中，而通信域决定了该 socket 的地址格式和通信范围。
![[Pasted image 20250312152736.png]]

AF 是 address family 的缩写，意为地址族。
![[Pasted image 20250312152859.png]]

面向无连接的 socket 则完全不同，这类 socket 在通信时无需建立连接。数据流是单向的，我们不能使用同一个面向无连接的 socket 实例既发送数据又接收数据。

数据传输的有序性和可靠性与 socket 是否面向连接有很大的关系。

Go 的 socket 编程 API 程序在底层获取的是一个非阻塞式的 socket 实例，这意味着在该实例之上的数据读取操作也都是非阻塞式的。在应用程序试图通过系统调用 read 从 socket 的接收缓冲区中读取数据时，即使接收缓冲区中没有任何数据， OS 内核也不会使系统调用 read 进入阻塞状态，而是直接返回一个错误码为 EAGAIN 的错误。但是，应用程序并不应该视此为一个真正的错误，而是应该忽略它，然后稍等片刻再去尝试读取。如果在读取数据的时候接收缓冲区有数据，那么系统调用 read 就会携带这些数据立即返回。即使当时的接收缓冲区中只包含了一个字节的数据，也会是这样。这一特性称为部分读（partial read）。另一方面，在应用程序试图向 socket 的发送缓冲区中写入一段数据时。

Go 的 socket 编程 API 程序为我们屏蔽了相关系统调用的 EAGAIN 错误，这使得有些 socket 编程 API 调用起来像是阻塞式的。屏蔽了部分写的特性，但未屏蔽部分读的特性。部分读需要我们在程序中做一些额外的处理。

net.Conn 类型，它是一个接口类型，在它的方法集合中包含了 8 个方法。
- Read
Read 方法用于从 socket 的接收缓冲区中读取数据，下面是该方法的声明：
```
Read(b []byte)(n int, err error)
```
该方法接受一个 []byte 类型的参数，该参数的值相当于一个用来存放从连接上接收到的数据的容器，它的长度完全由应用程序决定。Read 方法会把它当成空的容器并试图填满，该容器中相应上的原元素值将会被替换。
```
b := make([]byte, 10)
n, err := conn.Read(b)
content := string(b[:n])
```

err 是 io.EOF 则意味着在此 TCP 连接之上再无可读取的数据。也就是说，该 TCP 连接已经无用。


# 3.3 多线程编程
必须要使用临界区重叠的多个互斥量，有两种通用的解决方法。“试锁定-回退”；“固定顺序锁定”

同步方法：互斥量和条件变量，互斥量可以实现对临界区的保护，并会阻止竞态条件的发生。条件变量作为补充手段，可以让多方协作更有效。

条件变量：并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。

生产者和消费者问题，添加操作和获取操作能够在条件不满足时自行阻塞，并且一旦条件满足就能立即进行操作重试。可以使用条件变量解决这类问题。条件变量必须要与某个互斥量进行绑定。条件变量提供的操作有如下 3 种：
- 等待通知（wait）：阻塞当前线程，直至收到该条件变量发来的通知
- 单发通知（signal）：让该条件变量向至少一个正在等待它通知的线程发送通知，以表示某个共享数据的状态已经改变。
- 广播通知（broadcast）

等待通知会先解锁与该条件变量绑定在一起的那个互斥量，然后再使当前线程阻塞。两个细节：
- 只有在当前的共享数据状态不满足条件时，才执行等待通知操作，而检查共享数据的状态也需要受到互斥量的保护。
- 等待通知操作所包含的解锁互斥量和阻塞当前线程的步骤共同形成了一个原子操作。
![[Pasted image 20250312172629.png]]

## 3.3.4 线程安全性
如果一个代码块，它可以被多个线程并发执行，且总能够产生预取的结果，就是线程安全的。让函数具有线程安全性的最有效方式就是使其可重入。任何内含了操作共享数据的代码的函数都视为不可重入的函数。

使用互斥量保护好共享数据操作代码。