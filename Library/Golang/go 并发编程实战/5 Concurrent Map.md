Go 提供的字典类型并不是并发安全的。先要确定并发安全的字典类型的行为。定义一个接口。
![[Pasted image 20250316112330.png]]

下面编写该接口实现的类型。
![[Pasted image 20250316113828.png]]

一个 Segment 类型值代表一个散列段。使用分段锁。

散列桶

4 层封装，从上至下为：封装键-元素对的 Pair 接口的实现、封装 Pair 的单链表的 Bucket 接口的实现、封装 Bucket 切片的 Segment 接口的实现，以及封装 Segment 切片的 ConcurrentMap 接口的实现。

第 1 层封装的意义是检查键值和元素值的有效性，并先行计算键的散列值以备后用。同时，在需要对键-元素对的元素值（element）或链接（next）进行替换时实施原子操作。这比使用互斥锁要快的多。

第 2 层封装主要的功能是存储键散列值在同一范围内的键-元素对，并使用单链表和原子值消除读操作之间以及读操作与写操作的竞态条件。这一方案是无锁化的，大大提高了操作的性能。不过，写操作之间的竞态条件只能使用互斥锁来消除了，因为它们都可能建立新的单链表并替换旧表。

第 3 层封装是为了让单个散列桶集合能够自动伸缩，并承担字典内部的负载均衡。正因此，这一层上的读写操作都需要加锁。对于读操作，仅需要在依据键散列值定位散列桶的这一步上锁。当成功地向散列表添加或删除一个键值对的时候，就会触发对其中所有键值对的负载均衡。

第 4 层封装，根据使用者的需要初始化若干个散列段。散列段的数量会影响并发安全字典在当前应用场景下的整体性能。本层完全把对并发安全的保证和键值对的负载均衡下放到了第 3 层，而只负责根据键散列值找到对应的散列段并下达了操作指令。这样就可以分摊同步方法的使用以及负载均衡的执行带来的开销，消除了重量级的全局锁，大幅提升性能。