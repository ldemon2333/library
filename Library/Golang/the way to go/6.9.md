一个返回值为另一个函数的函数可以被称之为工厂函数，这在您需要创建一系列相似的函数的时候非常有用：书写一个工厂函数而不是针对每种情况都书写一个函数。下面的函数演示了如何动态返回追加后缀的函数：

可以返回其它函数的函数和接受其它函数作为参数的函数均被称之为高阶函数，是函数式语言的特点。我们已经在[第 6.7 节](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f676f5374756479222c22637764223a225c5c5c5c77736c2e6c6f63616c686f73745c5c5562756e74752d32302e30345c5c726f6f745c5c676f5c5c7372635c5c6769746875622e636f6d5c5c72756e63227d.vscode-resource.vscode-cdn.net/root/the-way-to-go/eBook/06.7.md)中得知函数也是一种值，因此很显然 Go 语言具有一些函数式语言的特性。闭包在 Go 语言中非常常见，常用于 goroutine 和管道操作（详见第 [14.8](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f676f5374756479222c22637764223a225c5c5c5c77736c2e6c6f63616c686f73745c5c5562756e74752d32302e30345c5c726f6f745c5c676f5c5c7372635c5c6769746875622e636f6d5c5c72756e63227d.vscode-resource.vscode-cdn.net/root/the-way-to-go/eBook/14.8.md)-[14.9](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f676f5374756479222c22637764223a225c5c5c5c77736c2e6c6f63616c686f73745c5c5562756e74752d32302e30345c5c726f6f745c5c676f5c5c7372635c5c6769746875622e636f6d5c5c72756e63227d.vscode-resource.vscode-cdn.net/root/the-way-to-go/eBook/14.9.md) 节）。在[第 11.14 节](https://vscode-remote+attached-002dcontainer-002b7b22636f6e7461696e65724e616d65223a222f676f5374756479222c22637764223a225c5c5c5c77736c2e6c6f63616c686f73745c5c5562756e74752d32302e30345c5c726f6f745c5c676f5c5c7372635c5c6769746875622e636f6d5c5c72756e63227d.vscode-resource.vscode-cdn.net/root/the-way-to-go/eBook/11.14.md)的程序中，我们将会看到 Go 语言中的函数在处理混合对象时的强大能力。

有时候，能够知道一个计算执行消耗的时间是非常有意义的，尤其是在对比和基准测试中。最简单的一个办法就是在计算开始之前设置一个起始时间，再记录计算结束时的结束时间，最后计算它们的差值，就是这个计算所消耗的时间。想要实现这样的做法，可以使用 `time` 包中的 `Now()` 和 `Sub()` 函数：

Go 语言中的数组是一种 **值类型**（不像 C/C++ 中是指向首元素的指针），所以可以通过 `new()` 来创建： `var arr1 = new([5]int)`。

那么这种方式和 `var arr2 [5]int` 的区别是什么呢？`arr1` 的类型是 `*[5]int`，而 `arr2` 的类型是 `[5]int`。

这样的结果就是当把一个数组赋值给另一个时，需要再做一次数组内存的拷贝操作。例如：

```go
arr2 := *arr1
arr2[2] = 100
```

这样两个数组就有了不同的值，在赋值后修改 `arr2` 不会对 `arr1` 生效。

所以在函数中数组作为参数传入时，如 `func1(arr2)`，会产生一次数组拷贝，`func1()` 方法不会修改原始的数组 `arr2`。

如果你想修改原数组，那么 `arr2` 必须通过 `&` 操作符以引用方式传过来，例如 `func1(&arr2)`，下面是一个例子：

在 Go 语言中，`fmt.Printf` 用于格式化输出。下面是一些 **常用的打印格式**，按数据类型分类：

---

## **1. 通用占位符**

|占位符|说明|示例|
|---|---|---|
|`%v`|按变量默认格式打印|`fmt.Printf("%v", 123)` → `123`|
|`%+v`|结构体字段名+值|`fmt.Printf("%+v", p)` → `{X:10 Y:20}`|
|`%#v`|Go 语法表示|`fmt.Printf("%#v", p)` → `main.Point{X:10, Y:20}`|
|`%T`|变量类型|`fmt.Printf("%T", 123)` → `int`|
|`%%`|字面 `%`|`fmt.Printf("100%%")` → `100%`|

---

## **2. 整数格式**

|占位符|说明|示例|
|---|---|---|
|`%b`|二进制|`fmt.Printf("%b", 5)` → `101`|
|`%c`|Unicode 字符|`fmt.Printf("%c", 65)` → `A`|
|`%d`|十进制|`fmt.Printf("%d", 255)` → `255`|
|`%o`|八进制|`fmt.Printf("%o", 255)` → `377`|
|`%x`|十六进制（小写）|`fmt.Printf("%x", 255)` → `ff`|
|`%X`|十六进制（大写）|`fmt.Printf("%X", 255)` → `FF`|
|`%U`|Unicode 码点|`fmt.Printf("%U", '你')` → `U+4F60`|

---

## **3. 浮点数格式**

|占位符|说明|示例|
|---|---|---|
|`%f`|小数点格式（默认6位小数）|`fmt.Printf("%f", 3.1415926)` → `3.141593`|
|`%.nf`|限制小数点后 `n` 位|`fmt.Printf("%.2f", 3.1415926)` → `3.14`|
|`%e`|科学计数法（小写）|`fmt.Printf("%e", 123456.0)` → `1.234560e+05`|
|`%E`|科学计数法（大写）|`fmt.Printf("%E", 123456.0)` → `1.234560E+05`|
|`%g`|自动选择 `%e` 或 `%f`|`fmt.Printf("%g", 123456.0)` → `123456`|
|`%G`|自动选择 `%E` 或 `%f`|`fmt.Printf("%G", 123456.0)` → `123456`|

---

## **4. 字符串和指针**

|占位符|说明|示例|
|---|---|---|
|`%s`|普通字符串|`fmt.Printf("%s", "hello")` → `hello`|
|`%q`|带引号字符串|`fmt.Printf("%q", "hello")` → `"hello"`|
|`%x`|字符串的十六进制表示|`fmt.Printf("%x", "hello")` → `68656c6c6f`|
|`%p`|指针地址|`fmt.Printf("%p", &a)` → `0xc000010230`|

---

## **5. 布尔值**

|占位符|说明|示例|
|---|---|---|
|`%t`|`true` 或 `false`|`fmt.Printf("%t", true)` → `true`|

---

## **6. 结构化输出**

### **打印结构体**

```go
package main

import "fmt"

type Point struct {
	X, Y int
}

func main() {
	p := Point{X: 10, Y: 20}
	fmt.Printf("%v\n", p)  // {10 20}
	fmt.Printf("%+v\n", p) // {X:10 Y:20}
	fmt.Printf("%#v\n", p) // main.Point{X:10, Y:20}
	fmt.Printf("%T\n", p)  // main.Point
}
```

---

## **7. 格式化宽度**

|格式|说明|示例|
|---|---|---|
|`%5d`|宽度 5，右对齐|`fmt.Printf("%5d", 42)` → `" 42"`|
|`%-5d`|宽度 5，左对齐|`fmt.Printf("%-5d", 42)` → `"42 "`|
|`%05d`|宽度 5，左侧补零|`fmt.Printf("%05d", 42)` → `"00042"`|
|`%10s`|宽度 10，右对齐|`fmt.Printf("%10s", "hi")` → `" hi"`|
|`%-10s`|宽度 10，左对齐|`fmt.Printf("%-10s", "hi")` → `"hi "`|

---

## **8. 组合格式**

```go
package main

import "fmt"

func main() {
	name := "Alice"
	age := 25
	fmt.Printf("姓名: %s, 年龄: %d\n", name, age)
}
```

**输出：**

```text
姓名: Alice, 年龄: 25
```

---

### **总结**

- **通用格式**：`%v`、`%T`
- **整数**：`%d`、`%b`、`%o`、`%x`
- **浮点数**：`%f`、`%e`、`%.2f`
- **字符串**：`%s`、`%q`、`%x`
- **布尔值**：`%t`
- **指针**：`%p`
- **格式化宽度**：`%5d`、`%-5d`、`%05d`

你可以结合这些占位符，灵活控制 `fmt.Printf()` 的输出格式。🎯

在 Go 语言中，**切片（slice）** 和 **数组（array）** 是两种常见的数据结构，它们的主要区别如下：

---

## **1. 切片 vs. 数组的主要区别**

|特性|**数组（Array）**|**切片（Slice）**|
|---|---|---|
|**长度**|长度固定，定义后不能改变|长度可变，可动态增长|
|**存储位置**|存储在 **栈**（小数组）或 **堆**（大数组）|存储在 **堆**，是对底层数组的引用|
|**定义方式**|`[N]T{}`（固定大小）|`[]T{}`（不指定大小）|
|**占用内存**|直接存储数据|仅存储 **引用**（指向底层数组）|
|**是否可以扩展**|不能扩展|可以通过 `append()` 扩展|
|**函数传递**|传值（复制整个数组）|传引用（修改切片会影响底层数组）|

---

## **2. 数组（Array）**

### **定义数组**

数组的长度是 **固定的**，一旦定义就不能改变：

```go
var arr [5]int // 声明一个长度为 5 的整型数组
fmt.Println(arr) // [0 0 0 0 0]
```

### **数组的初始化**

```go
arr := [3]int{1, 2, 3}   // 显式初始化
arr2 := [...]int{4, 5, 6} // 省略长度，由编译器推导
fmt.Println(arr, arr2)    // [1 2 3] [4 5 6]
```

### **数组是值类型**

数组在赋值或传参时，会复制整个数组：

```go
func modifyArray(a [3]int) {
    a[0] = 100 // 仅修改函数内部的副本
}

func main() {
    arr := [3]int{1, 2, 3}
    modifyArray(arr)
    fmt.Println(arr) // [1 2 3]，原数组未变
}
```

---

## **3. 切片（Slice）**

切片是一个 **对数组的动态视图**，本质上是 **一个结构体，包含指向底层数组的指针、长度和容量**。

### **切片的定义**

```go
var s []int // 定义一个空切片（长度为 0）
```

### **使用 `make` 创建切片**

```go
s := make([]int, 3, 5) // 创建一个长度 3，容量 5 的切片
fmt.Println(s, len(s), cap(s)) // [0 0 0] 3 5
```

### **从数组创建切片**

```go
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:4] // [起始索引:结束索引]，不包含结束索引
fmt.Println(s) // [2 3 4]
```

### **切片是引用类型**

```go
func modifySlice(s []int) {
    s[0] = 100 // 修改的是底层数组
}

func main() {
    s := []int{1, 2, 3}
    modifySlice(s)
    fmt.Println(s) // [100 2 3]，原切片被修改
}
```

### **切片的扩展**

```go
s := []int{1, 2, 3}
s = append(s, 4, 5) // 追加元素
fmt.Println(s) // [1 2 3 4 5]
```

如果切片容量不足，`append()` 会创建 **新的底层数组**，不会修改原来的底层数组。

---

## **4. 切片 vs. 数组的使用场景**

|场景|适合使用 **数组**|适合使用 **切片**|
|---|---|---|
|**数据大小固定**|适合|不适合|
|**动态增长**|不适合|适合|
|**传递参数**|复制整个数组（效率低）|仅传引用（高效）|
|**性能优化**|小数组存栈（快）|底层数据可能存堆（需额外内存管理）|

---

## **5. 关键区别总结**

|特性|**数组**|**切片**|
|---|---|---|
|长度|固定|可变|
|传递方式|值传递（复制整个数组）|引用传递（指向底层数组）|
|是否可以扩展|❌ 不可扩展|✅ 可用 `append()` 扩展|
|底层存储|直接存储数据|存储对底层数组的引用|
|适合场景|数据量固定|数据量不确定，动态扩展|

---

## **6. 代码示例对比**

```go
package main

import "fmt"

func main() {
    // 数组（固定大小）
    arr := [3]int{1, 2, 3}
    fmt.Println("数组:", arr)

    // 切片（动态大小）
    slice := []int{1, 2, 3}
    slice = append(slice, 4, 5)
    fmt.Println("切片:", slice)
}
```

### **输出**

```text
数组: [1 2 3]
切片: [1 2 3 4 5]
```

---

## **7. 什么时候用数组，什么时候用切片？**

- **用数组**：
    
    - 数据大小固定
    - 需要更高的性能（小数组存栈）
    - 结构清晰（如矩阵运算）
- **用切片**：
    
    - 需要灵活调整长度
    - 需要高效传递数据
    - 需要动态添加元素

一般情况下，**大多数场景都用切片**，因为切片更灵活、更易用。

---
