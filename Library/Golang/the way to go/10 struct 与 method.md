结构体是值类型，可以通过 new 函数来创建

在 Go 语言中，值类型（Value Type） 和 引用类型（Reference Type）的区别主要体现在**内存分配**和**赋值方式**上。

---

## 1. **值类型（Value Type）**

值类型的数据在赋值和传递时会**拷贝整个值**，而不会共享同一块内存。常见的值类型包括：

- **基础类型**：`int`、`float`、`bool`、`string`
- **结构体（struct）**
- **数组（array）**

### **示例**

```go
package main
import "fmt"

func main() {
    a := 10
    b := a  // 赋值后，b 是 a 的副本
    b = 20
    fmt.Println(a) // 输出: 10（a 没有改变）
}
```

这里 `b := a` 只是**拷贝**了 `a` 的值，修改 `b` 并不会影响 `a`。

---

## 2. **引用类型（Reference Type）**

引用类型的数据在赋值和传递时**拷贝的是内存地址（指针）**，多个变量共享同一块内存，修改其中一个变量会影响另一个变量。常见的引用类型包括：

- **切片（slice）**
- **映射（map）**
- **通道（channel）**
- **接口（interface）**
- **指针（pointer）**
- **函数（function）**

### **示例**

```go
package main
import "fmt"

func main() {
    a := []int{1, 2, 3}
    b := a  // 赋值后，b 和 a 指向同一块底层数组
    b[0] = 100
    fmt.Println(a) // 输出: [100 2 3]（a 也被修改）
}
```

这里 `b := a` 并没有拷贝整个 `a`，而是复制了 `a` 的**引用**，所以修改 `b[0]` 也会影响 `a[0]`。

---

## 3. **值类型与引用类型的区别**

| 特性       | 值类型                               | 引用类型                                 |
| -------- | --------------------------------- | ------------------------------------ |
| **赋值方式** | 复制值                               | 复制引用（指针）                             |
| **函数传参** | 传递副本，不影响原值                        | 传递地址，修改影响原值                          |
| **存储位置** | 栈（stack）或堆（heap）                  | 堆（heap）                              |
| **示例类型** | `int`, `float`, `struct`, `array` | `slice`, `map`, `pointer`, `channel` |

---

## 4. **函数参数传递**

**值类型参数（不会影响原变量）：**

```go
func modify(x int) {
    x = 100
}

func main() {
    a := 10
    modify(a)
    fmt.Println(a) // 输出: 10（a 未修改）
}
```

**引用类型参数（会影响原变量）：**

```go
func modify(slice []int) {
    slice[0] = 100
}

func main() {
    a := []int{1, 2, 3}
    modify(a)
    fmt.Println(a) // 输出: [100 2 3]（a 被修改）
}
```

如果想在函数内修改**值类型**的变量，可以使用**指针**：

```go
func modify(x *int) {
    *x = 100
}

func main() {
    a := 10
    modify(&a)  // 传递 a 的地址
    fmt.Println(a) // 输出: 100
}
```

在 Go 语言中，数组（`array`）是**值类型**，这意味着当数组被赋值或传递给函数时，**整个数组都会被拷贝**，而不会共享同一块内存。

---

## **示例：数组作为值类型传递**

```go
package main
import "fmt"

func modifyArray(arr [3]int) {
    arr[0] = 100  // 修改数组的第一个元素
}

func main() {
    a := [3]int{1, 2, 3}
    modifyArray(a) // 传递数组的副本
    fmt.Println(a) // 输出: [1 2 3]（原数组未修改）
}
```

### **解析**

- `a` 作为参数传递给 `modifyArray` 函数时，会创建 `a` 的**副本**，函数内部的修改不会影响 `main` 里的 `a`。
- 这与切片（slice）不同，切片是**引用类型**，在函数内部修改会影响原切片。

---

## **如何让数组作为引用传递**

如果想要在函数中修改数组，可以使用**指针**：

```go
package main
import "fmt"

func modifyArray(arr *[3]int) {
    arr[0] = 100  // 通过指针修改原数组
}

func main() {
    a := [3]int{1, 2, 3}
    modifyArray(&a) // 传递数组指针
    fmt.Println(a)  // 输出: [100 2 3]（原数组被修改）
}
```

### **解析**

- 这里 `arr *[3]int` 表示**指向数组的指针**，而 `&a` 传递的是 `a` 的地址。
- 在 `modifyArray` 函数内部，修改 `arr[0]` 就会直接影响 `a`。

---

## **与切片的对比**

数组是**值类型**，但**切片是引用类型**：

```go
package main
import "fmt"

func modifySlice(s []int) {
    s[0] = 100  // 直接修改底层数组
}

func main() {
    a := []int{1, 2, 3} // 切片
    modifySlice(a)      // 传递引用
    fmt.Println(a)      // 输出: [100 2 3]（原切片被修改）
}
```

### **区别**

|特性|数组（Array）|切片（Slice）|
|---|---|---|
|**类型**|值类型|引用类型|
|**赋值方式**|复制整个数组|复制底层数组的引用|
|**传递函数时**|复制整个数组|共享同一底层数组|
|**修改影响**|不影响原数组|影响原切片|

---

### **总结**

- **数组（array）是值类型**，传递时会拷贝整个数组。
- **切片（slice）是引用类型**，传递时不会拷贝底层数据，而是共享同一块内存。
- **如果要在函数内部修改数组，可使用指针 `*[N]int` 传递**。




# 10.5 匿名字段和内嵌结构体

`nil` 是其他编程语言的 `null`。错误可以是 `nil`，因为返回类型是 `error`，这是一个接口。如果你看到一个函数，它接受参数或返回值的类型是接口，它们就可以是 `nil`。

