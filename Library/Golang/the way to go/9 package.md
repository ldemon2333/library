在 Go 语言中，字符串（`string`）和字符数组（`[]rune` 或 `[]byte`）有以下几个主要区别和用法：

---

## **1. Go 中的字符串**

- Go 语言中的字符串是 **不可变** 的，也就是说字符串的内容不能被修改。
    
- 字符串底层是 **只读的字节数组**，默认以 UTF-8 编码存储。
    
- 字符串可以用 **双引号**（`""`）或 **反引号**（`` ` ` ``）包围：
    
    ```go
    s1 := "Hello, 世界"
    s2 := `Hello, 世界`
    ```
    
- 可以使用索引访问字符串的字节，但不能修改：
    
    ```go
    fmt.Println(s1[0]) // 输出 72 ('H' 的 ASCII 码)
    s1[0] = 'h' // ❌ 编译错误，字符串不可变
    ```
    

---

## **2. 字符数组（`[]rune` 和 `[]byte`）**

字符串转换为字符数组后可以修改字符。

### **（1）`[]byte` —— 处理 ASCII 或 UTF-8 字节序列**

- `string` 可以转换为 `[]byte`，然后可以修改：
    
    ```go
    s := "hello"
    b := []byte(s) // 将字符串转换为字节切片
    b[0] = 'H'
    fmt.Println(string(b)) // 输出 "Hello"
    ```
    
- **适用于 ASCII 或 UTF-8 编码的字符串**，但不能正确处理非 ASCII 字符：
    
    ```go
    s := "世界"
    b := []byte(s)
    fmt.Println(b) // 输出 [228 184 150 231 149 140]（UTF-8 编码）
    ```
    

---

### **（2）`[]rune` —— 处理 Unicode 字符**

- `rune` 是 Go 中的 **Unicode 码点** 类型（相当于 `int32`）。
    
- `string` 转换为 `[]rune` 可以正确处理中文等多字节字符：
    
    ```go
    s := "世界"
    r := []rune(s) // 转换为字符数组
    fmt.Println(r) // 输出 [19990 30028]
    r[0] = '你'     // 修改第一个字符
    fmt.Println(string(r)) // 输出 "你界"
    ```
    
- **适用于需要逐字符处理 Unicode 字符串的情况**，如文本解析、字符替换等。
    

---

## **3. 选择使用 `string`、`[]byte` 还是 `[]rune`**

|类型|主要用途|是否可变|适用场景|
|---|---|---|---|
|`string`|UTF-8 字符串|❌ 不可变|只读文本|
|`[]byte`|字节数组|✅ 可变|处理 ASCII 或 UTF-8 编码|
|`[]rune`|Unicode 码点数组|✅ 可变|处理 Unicode 字符|

---

## **4. 示例：修改字符串**

```go
package main

import "fmt"

func main() {
    s := "hello 世界"
    
    // 转换为 []byte 修改后再转换回 string
    b := []byte(s)
    b[0] = 'H'
    fmt.Println(string(b)) // "Hello 世界"
    
    // 转换为 []rune 修改后再转换回 string
    r := []rune(s)
    r[6] = '你'
    fmt.Println(string(r)) // "hello 你界"
}
```

---

## **总结**

1. **字符串 (`string`)** 是不可变的，可以索引访问但不能修改。
2. **`[]byte`** 适合处理 ASCII 或 UTF-8 编码的字符串，可以修改单个字节，但不能正确处理多字节字符。
3. **`[]rune`** 适合处理 Unicode 字符，可以修改单个字符。
4. 需要修改字符串时，应先转换为 `[]byte` 或 `[]rune`，修改后再转换回 `string`。

# 9.3 锁和 sync 包
特别是我们之前章节学习的 `map` 类型是不存在锁的机制来实现这种效果（出于对性能的考虑），所以 map 类型是非线程安全的。当并行访问一个共享的 `map` 类型的数据，`map` 数据将会出错。

`sync.Mutex` 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。

