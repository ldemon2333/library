单调栈是一种特殊的栈。栈本来就是一种受限的数据结构了，单调栈在此基础上又受限了一次（受限++）。

单调栈要求栈中的元素是单调递增的或者单调递减的。

# 适用场景

单调栈适合的题目是求解**下一个大于 xxx**或者**下一个小于 xxx**这种题目。所有当你有这种需求的时候，就应该想到单调栈。

那么为什么单调栈适合求解**下一个大于 xxx**或者**下一个小于 xxx**这种题目？原因很简单，我这里通过一个例子给大家讲解一下。

> 这里举的例子是单调递减栈

比如我们需要依次将数组 [1,3,4,5,2,9,6] 压入单调栈。

1. 首先压入 1，此时的栈为：[1]
    
2. 继续压入 3，此时的栈为：[1,3]
    
3. 继续压入 4，此时的栈为：[1,3,4]
    
4. 继续压入 5，此时的栈为：[1,3,4,5]
    
5. **如果**继续压入 2，此时的栈为：[1,3,4,5,2] 不满足单调递减栈的特性， 因此需要调整。如何调整？由于栈只有 pop 操作，因此我们只好不断 pop，直到满足单调递减为止。
    
6. 上面其实我们并没有压入 2，而是先 pop，pop 到压入 2 依然可以保持单调递减再 压入 2，此时的栈为：[1,2]
    
7. 继续压入 9，此时的栈为：[1,2,9]
    
8. **如果**继续压入 6，则不满足单调递减栈的特性， 我们故技重施，不断 pop，直到满足单调递减为止。此时的栈为：[1,2,6]

注意这里的栈仍然是非空的，如果有的题目需要用到所有数组的信息，那么很有可能因没有考虑边界而不能通过所有的测试用例。 这里介绍一个技巧 - **哨兵法**，这个技巧经常用在单调栈的算法中。

对于上面的例子，我可以在原数组 [1,3,4,5,2,9,6] 的右侧添加一个小于数组中最小值的项即可，比如 -1。此时的数组是 [1,3,4,5,2,9,6,-1]。这种技巧可以简化代码逻辑，大家尽量掌握。

上面的例子如果你明白了，就不难理解为啥单调栈适合求解**下一个大于 xxx**或者**下一个小于 xxx**这种题目了。比如上面的例子，我们就可以很容易地求出**在其之后第一个小于其本身的位置**。比如 3 的索引是 1，小于 3 的第一个索引是 4，2 的索引 4，小于 2 的第一个索引是 0，但是其在 2 的索引 4 之后，因此不符合条件，也就是不存在**在 2 之后第一个小于 2 本身的位置**。

上面的例子，我们在第 6 步开始 pop，第一个被 pop 出来的是 5，因此 5 之后的第一个小于 5 的索引就是 4。同理被 pop 出来的 3，4，5 也都是 4。

如果用 ans 来表示**在其之后第一个小于其本身的位置**，ans[i] 表示 arr[i] 之后第一个小于 arr[i] 的位置， ans[i] 为 -1 表示这样的位置不存在，比如前文提到的 2。那么此时的 ans 是 [-1,4,4,4,-1,-1,-1]。

第 8 步，我们又开始 pop 了。此时 pop 出来的是 9，因此 9 之后第一个小于 9 的索引就是 6。

这个算法的过程用一句话总结就是，**如果压栈之后仍然可以保持单调性，那么直接压。否则先弹出栈的元素，直到压入之后可以保持单调性。** 这个算法的原理用一句话总结就是，**被弹出的元素都是大于当前元素的，并且由于栈是单调增的，因此在其之后小于其本身的最近的就是当前元素了**

# 伪代码

上面的算法可以用如下的伪代码表示，同时这是一个通用的算法模板，大家遇到单调栈的题目可以直接套。

建议大家用自己熟悉的编程语言实现一遍，以后改改符号基本就能用。
```py
class Solution:
    def monostoneStack(self, arr: List[int]) -> List[int]:
        stack = []
        ans = 定义一个长度和 arr 一样长的数组，并初始化为 -1
        循环 i in  arr:
            while stack and arr[i] > arr[栈顶元素]:
                peek = 弹出栈顶元素
                ans[peek] = i - peek
            stack.append(i)
        return ans
```

