# 基本概念
## 解空间
解空间指的是**题目所有可能的解构成的集合**。比如一个题目所有解的可能是 1,2,3,4,5，但具体在某一种情况只能是其中某一个数（即可能是 1，2，3，4，5 中的**一个数**）。那么这里的解空间就是 1,2,3,4,5 构成的集合，在某一个具体的情况下可能是其中任意一个值，**我们的目标就是在某个具体的情况判断其具体是哪个**。如果线性枚举所有的可能，就枚举这部分来说时间复杂度就是 $O(n)$。

对于**搜索类题目**，解空间一定是有限的，不然问题不可解。对于搜索类问题，第一步就是需要明确解空间，这样你才能够在解空间内进行搜索。这个技巧不仅适用于二分法，只要是搜索问题都可以使用，比如 DFS，BFS 以及回溯等。只不过对于二分法来说，**明确解空间显得更为重要**。如果现在还不理解这句话也没关系，看完本文或许你就理解了。

有的同学可能会说我看不出来怎么办呀。我觉得如果你实在拿不准也完全没有关系，比如求 x 的平方根，就可以设置为 [1,x]，就让它多做几次运算嘛。我建议你**给上下界设置一个宽泛的范围**。等你对二分逐步了解之后可以**卡地更死一点**。

## 序列有序
我这里说的是序列，并不是数组，链表等。也就是说二分法通常要求的序列有序，不一定是数组，链表，也有可能是其他数据结构。另外有的**序列有序**题目直接讲出来了，会比较容易。而有些则隐藏在题目信息之中。乍一看，题目并没有**有序**关键字，而有序其实就隐藏在字里行间。比如题目给了数组 nums，并且没有限定 nums 有序，但限定了 nums 为非负。这样如果给 nums 做前缀和或者前缀或（位运算或），就可以得到一个有序的序列啦。

虽然二分法不意味着需要序列有序，但大多数二分题目都有**有序**这个显著特征。只不过：

- 有的是题目直接限定了有序。这种题目通常难度不高，也容易让人想到用二分。
    
- 有的是需要你**自己构造有序序列**。这种类型的题目通常难度不低，需要大家有一定的观察能力。

# 两种类型
## 寻找最左边插入位置
上面我们讲了`寻找满足条件的值`。如果找不到，就返回 -1。那如果不是返回 -1，而是返 回应该插入的位置，使得插入之后列表仍然有序呢？

比如一个数组 nums: [1,3,4]，target 是 2。我们应该将其插入（注意不是真的插入）的 位置是索引 1 的位置，即 [1,**2**,3,4]。因此`寻找最左插入位置`应该返回 1， 而`寻找满足条件的位置` 应该返回-1。

另外如果有多个满足条件的值，我们返回最左侧的。 比如一个数组 nums: [1,2,2,2,3,4]，target 是 2，我们应该插入的位置是 1。

### 思维框架
等价于寻找最左满足 >= target 的位置。

具体算法：

- 首先定义解空间为 [left, right]，注意是左右都闭合，之后会用到这个点。
    

> 你可以定义别的解空间形式，不过后面的代码也相应要调整，感兴趣的可以试试别的解空 间。

- 由于我们定义的解空间为 [left, right]，因此当 left <= right 的时候，解空间都不 为空。 也就是说我们的终止搜索条件为 left > right。
    
- 当 A[mid] >= x，说明找到一个备胎，我们令 r = mid - 1 将 mid 从解空间排除，继续 看看有没有更好的备胎。
    
- 当 A[mid] < x，说明 mid 根本就不是答案，直接更新 l = mid + 1，从而将 mid 从解 空间排除。
    
- 最后解空间的 l 就是最好的备胎，备胎转正。

### 代码

```py
def bisect_left(A, x):
    # 内置 api
    bisect.bisect_left(A, x)
    # 手写
    l, r = 0, len(A) - 1
    while l <= r:
        mid = (l + r) // 2
        if A[mid] >= x: r = mid - 1
        else: l = mid + 1
    return l
```

另一种写法：

```py
def find_leftmost_ge(arr, target):
	left,right = 0,len(arr)-1
	result = -1 # 初始为-1, 表示未找到满足条件的数
	
	while left<=right:
		mid = left+(right-left)//2
		if arr[mid]>=target:
			result = mid # 记录当前找到的位置
			right = mid-1 # 继续向左搜索，寻找更靠左的位置
		else:
			left = mid+1 # 继续向右搜索
	
	return result

# 示例使用
arr = [1,2,2,2,3,4,5]
target = 2
print(find_leftmost_ge(arr, target)) # 输出1,即数组中第一个大于等于2的位置
```

**计算 `mid`**：

- `mid = left + (right - left) // 2`，计算中间位置，避免直接使用 `(left + right) // 2` 以防止可能的整数溢出。

## 寻找最右插入位置
### 思维框架
寻找最右满足<=target的位置的右邻居。

### 代码
```py
def bisect_right(A, x):
    # 内置 api
    bisect.bisect_right(A, x)
    # 手写
    l, r = 0, len(A) - 1
    while l <= r:
        mid = (l + r) // 2
        if A[mid] <= x: l = mid + 1
        else: r = mid - 1
    return l # 或者 r + 1
```

```py
def find_rightmost(arr, target):
	left,right = 0,len(arr)-1
	result = -1
	while left<=right:
		mid = left+(right-left)//2
		if arr[mid]<=target:
			result = mid
			left = mid+1
		else:
			right = mid-1
	
	return result

# 示例
arr = [1,2,2,2,3,4,5]
target = 2
print(find_rightmost(arr,target)+1) # 输出4
```

以上就是两种二分的基本形式了。而在实际的写代码过程中，我不会使用**寻找满足条件的 值**模板，而是直接使用**最左** 或者 **最右** 插入模板。为什么呢？因为后者包含了 前者，并还有前者实现不了的功能。比如我要实现**寻找满足条件的值**，就可直接使 用**最左插入**模板找到插入索引 i，只不过最后判断一下 nums[i] 是否等于 target 即 可，如果不等于则返回 -1，否则返回 i。这也是为什么我**将二分分为两种类型，而不是 三种甚至四种的原因**。

另外最左插入和最右插入可以结合使用从而求出**有序序列**中和 target 相等的数的个数 ，这在有些时候会是一个考点。代码表示：
```py
nums = [1,2,2,2,3,4]
i = bisect.bisect_left(nums, 2) # get 1
j = bisect.bisect_right(nums, 2) # get 4
# j - i 就是 nums 中 2 的个数
```

为了描述方便，以后所有的最左插入二分我都会简称**最左二分**，代码上直接用 bisect.bisect_left 表示，而最右插入二分我都会简称**最右二分**，代码上用 bisect.bisect_right 或者 bisect.bisect 表示。

# 四大应用
基础知识铺垫了差不多了。接下来，我们开始干货技巧。

接下来要讲的：

- 能力检测和计数二分本质差不多，都是**普通二分** 的泛化。
    
- 前缀和二分和插入排序二分，本质都是在**构建有序序列**。

## 能力检测二分
能力检测二分一般是：定义函数 possible， 参数是 mid，返回值是布尔值。外层根据返回 值调整"解空间"。

示例代码（以最左二分为例）：

```py
def ability_test_bs(nums):
	def possible(mid):
		pass
	l,r = 0, len(nums)-1
	result = -1
	while l<=r:
		mid = l+(r-l)//2
		if possible(mid):
			result = mid
			l = mid+1
		else:
			r = mid-1
	return result 
```

## 计数二分

## 前缀和二分
如果数组全是正的，那么前缀和就是一个严格递增的数组，基于这个特性，我们可以在其之上做二分。

## 插入排序二分

