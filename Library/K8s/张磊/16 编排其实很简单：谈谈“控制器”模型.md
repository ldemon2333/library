**Pod这个看似复杂的API对象，实际上就是对容器的进一步抽象和封装而已。**

所以，Pod对象，其实就是容器的升级版。它对容器进行了组合，添加了更多的属性和字段。这就好比给集装箱四面安装了吊环，使得Kubernetes这架“吊车”，可以更轻松地操作它。

而Kubernetes操作这些“集装箱”的逻辑，都由控制器（Controller）完成。

曾经提到过一个叫作kube-controller-manager的组件。

实际上，这个组件，就是一系列控制器的集合。我们可以查看一下Kubernetes项目的pkg/controller目录：

这个目录下面的每一个控制器，都以独有的方式负责某种编排功能。而我们的Deployment，正是这些控制器中的一种。

实际上，这些控制器之所以被统一放在pkg/controller目录下，就是因为它们都遵循Kubernetes项目中的一个通用编排模式，即：控制循环（control loop）。

比如，现在有一种待编排的对象X，它有一个对应的控制器。那么，我就可以用一段Go语言风格的伪代码，为你描述这个**控制循环**：
![[Pasted image 20250507102924.png]]

**在具体实现中，实际状态往往来自于Kubernetes集群本身**。

比如，kubelet通过心跳汇报的容器状态和节点状态，或者监控系统中保存的应用监控数据，或者控制器主动收集的它自己感兴趣的信息，这些都是常见的实际状态的来源。

**而期望状态，一般来自于用户提交的YAML文件**。

比如，Deployment对象中Replicas字段的值。很明显，这些信息往往都保存在Etcd中。

接下来，以Deployment为例，我和你简单描述一下它对控制器模型的实现：
1. Deployment控制器从Etcd中获取到所有携带了“app: nginx”标签的Pod，然后统计它们的数量，这就是实际状态；
    
2. Deployment对象的Replicas字段的值就是期望状态；
    
3. Deployment控制器将两个状态做比较，然后根据比较结果，确定是创建Pod，还是删除已有的Pod（具体如何操作Pod对象，我会在下一篇文章详细介绍）。
    

可以看到，一个Kubernetes对象的主要编排逻辑，实际上是在第三步的“对比”阶段完成的。

这个操作，通常被叫作调谐（Reconcile）。这个调谐的过程，则被称作“Reconcile Loop”（调谐循环）或者“Sync Loop”（同步循环）。

而调谐的最终结果，往往都是对被控制对象的某种写操作。

比如，增加Pod，删除已有的Pod，或者更新Pod的某个字段。**这也是Kubernetes项目“面向API对象编程”的一个直观体现。**

其实，像Deployment这种控制器的设计原理，就是我们前面提到过的，“用一种对象管理另一种对象”的“艺术”。

其中，这个控制器对象本身，负责定义被管理对象的期望状态。比如，Deployment里的replicas=2这个字段。

而被控制对象的定义，则来自于一个“模板”。比如，Deployment里的template字段。

可以看到，Deployment这个template字段里的内容，跟一个标准的Pod对象的API定义，丝毫不差。而所有被这个Deployment管理的Pod实例，其实都是根据这个template字段的内容创建出来的。

像Deployment定义的template字段，在Kubernetes项目中有一个专有的名字，叫作PodTemplate（Pod模板）。

这个概念非常重要，因为后面我要讲解到的大多数控制器，都会使用PodTemplate来统一定义它所要管理的Pod。更有意思的是，我们还会看到其他类型的对象模板，比如Volume的模板。

至此，我们就可以对Deployment以及其他类似的控制器，做一个简单总结了：
![[Pasted image 20250507103221.png]]
如上图所示，**类似Deployment这样的一个控制器，实际上都是由上半部分的控制器定义（包括期望状态），加上下半部分的被控制对象的模板组成的。**

# 总结
在今天这篇文章中，我以Deployment为例，和你详细分享了Kubernetes项目如何通过一个称作“控制器模式”（controller pattern）的设计方法，来统一地实现对各种不同的对象或者资源进行的编排操作。

在后面的讲解中，我还会讲到很多不同类型的容器编排功能，比如StatefulSet、DaemonSet等等，它们无一例外地都有这样一个甚至多个控制器的存在，并遵循控制循环（control loop）的流程，完成各自的编排逻辑。

实际上，跟Deployment相似，这些控制循环最后的执行结果，要么就是创建、更新一些Pod（或者其他的API对象、资源），要么就是删除一些已经存在的Pod（或者其他的API对象、资源）。

但也正是在这个统一的编排框架下，不同的控制器可以在具体执行过程中，设计不同的业务逻辑，从而达到不同的编排效果。

这个实现思路，正是Kubernetes项目进行容器编排的核心原理。在此后讲解Kubernetes编排功能的文章中，我都会遵循这个逻辑展开，并且带你逐步领悟控制器模式在不同的容器化作业中的实现方式。

# 思考
你能否说出，Kubernetes使用的这个“控制器模式”，跟我们平常所说的“事件驱动”，有什么区别和联系吗？

这是一个非常好的问题，涉及到 Kubernetes 的核心设计思想。

---

## 🧠 简要回答

Kubernetes 所使用的 **控制器模式（Controller Pattern）** 与我们常说的 **事件驱动（Event-Driven）** 是 **相关但不完全相同** 的两种模型：

- **控制器模式** 是一种 **持续对比期望状态（Spec）与实际状态（Status）并做出修正** 的闭环机制；
    
- **事件驱动模型** 是系统对事件（变化）做出 **即时响应** 的机制；
    
- 它们在 Kubernetes 中**互为补充**：Kubernetes 控制器是“事件驱动的控制循环”。
    

---

## 🔄 控制器模式（Controller Pattern）

Kubernetes 中的每个控制器（如 Deployment Controller、ReplicaSet Controller、Node Controller）都遵循如下逻辑：

1. **期望状态**：用户提交的 YAML 中定义的 desired state（比如副本数是 3）。
    
2. **实际状态**：控制器从 etcd 读取当前集群状态（比如实际只运行了 2 个 Pod）。
    
3. **比较差异**：控制器周期性检查是否一致。
    
4. **采取行动**：如发现状态不符，会调度创建/删除 Pod，以实现目标。
    

这是一个 **控制环（Control Loop）**。

---

## ⚡️ 事件驱动模型（Event-Driven）

事件驱动系统会在某些状态发生变化时**立即触发响应操作**，而不是定期检查。例如：

- 文件修改触发构建
    
- HTTP 请求触发 Lambda 函数
    

它通常依赖事件队列、回调机制（如 `onChange`）、订阅模型等。

---

## 📎 它们的联系

Kubernetes 控制器**结合了控制循环和事件驱动**：

- 控制器监听 API Server 的资源事件（如 Pod 增删改），这是**事件驱动**。
    
- 然后进入控制循环（Reconcile Loop）去**修正状态**，这是**控制器模式**。
    

控制器不会完全依赖事件，而是会**定期轮询（resync）**，以避免事件丢失导致状态错误（这是与纯事件驱动的不同之处）。

---

## ✅ 总结对比表

|特性|控制器模式|事件驱动|
|---|---|---|
|设计目标|保证系统状态趋近期望值|对事件快速响应|
|主体|控制器不断对比状态|事件触发函数|
|是否主动拉取|是（拉取实际状态）|否（被动响应）|
|Kubernetes 中体现|Deployment、ReplicaSet 控制器等|控制器监听资源事件的 informer|

---

### 📌 一句话总结：

> Kubernetes 控制器模式是 **事件驱动的状态修正机制**，它既依赖事件通知，也保留了定期检查的容错能力。

---
