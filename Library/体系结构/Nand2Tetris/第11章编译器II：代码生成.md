跟Java和C#的编译器一样，整个Jack编译器也是基于双层结构的：一个处于后端（back-end）的虚拟机，和一个前端（front-end）模块，该模块是高级语言和VM语言之间的一座桥梁，它由语法分析器和代码生成器组成。

本章把该分析器扩展成完整的编译器，它能够将“已经被理解的”高级语言的程序转换成一系列等价的VM操作。该方法遵循了构建多数编译器时所采用的“结构化分析综合（modular analysis-synthesis）“范式。

# 11.1 背景知识
程序本质上就是一系列操纵数据的操作。因此，将高级程序编译成低级语言主要涉及两个主要的问题：**数据的翻译**和**命令的翻译**。

## 11.1.1 数据翻译
**符号表(Symbol Table)**
高级程序引入并操纵很多标识符（identifiers）。当编译器遇到标识符xxx时，它需要知道xxx代表什么。它是变量名、类名称，还是函数名？

大多数编译器通过使用符号表（symbol table）抽象来保存这些信息。在源代码中第一次遇到一个新标识符时（比如在符号声明中），编译器将它的描述添加到表中。在代码的其他地方遇到标识符时，编译器在符号表中查找该标识符，然后得到关于它的所有必要信息。

![[Pasted image 20240706174426.png]]

例如语句balance=balance+sum。使用符号表，编译器能将这条语句翻译成相应的代码，该代码反映了下面的事实：balance是当前对象中编号为2的成员字段，sum是当前运行的子程序中编号为0的参数。

因为大多数语言允许不同的程序单元使用相同的标识符来表示完全不同的变量，所以基本的符号表中每个标识符都内在地与作用域（scope）想关联。这些作用域可嵌套，因此编译器约定：当相同的标识符在内层和外层（可以理解为位于某函数体内部/外部或者是一个类的内部/外部等）都被定义时，处于内层标识符的作用域将屏蔽外层同名标识符的作用域。

例如，如果语句x++出现在某个C函数中，C编译器首先确定标识符x是否被定义在当前函数中，如果是，那么就生成局部变量自增的代码，否则编译器会确定x是否在文件的全局范围内定义了，如果是，那么就生成全局变量自增的代码。

因此，符号表除了保存所有标识符相关的信息之外，它还必须以某种方式记录标识符的作用域。用哈希表（hash table）组成的链表，每个哈希表反映了一种作用域，该作用域被嵌套在链表中下一个哈希表所描述的作用域中。当编译器没有在与当前作用域相关的哈希表中找到需要的标识符时，它将会在链表中的下一个哈希表中继续查找，也就是按照从内层作用域到外层作用域的顺序来寻找标识符。因此，如果x在某个代码段中（比如某个方法）中没有被定义，那么x可能被定义在当前段的宿主代码段中（比如某个类），等等。

**变量处理**
如何将源程序中声明的各种变量类型映射到目标平台的内存中去。首先，不同的变量类型需要不同大小的内存块，因此，这种映射不是一对一的。其次，不同的变量有不同的生命周期。

**数组处理**
数组（array）几乎总是被存储在连续的内存单元组成的内存段中。数组的名字通常被当作是指针，它向内存中存储该数组的内存段基地址。比如Java，数组的声明仅仅只会导致分配一个指针（或称引用），该指针指向数组内存段的基地址。只有在程序运行期间该数组被真正构造时，它才会被分配合适的内存段。这是从内存堆（heap）中经由动态内存分配（dynamic memory allocation）得到的内存段，而动态内存分配是通过调用操作系统提供的底层内存管理程序实现的。OS有典型的alloc(size)函数，它知道如何找到可用大小为size的内存块，并返回它的基地址给调用者。因此，当编译器编译诸如bar=new int[10]这样的高级语句时，它生成执行操作bar=alloc(10)的低级代码。该代码导致将数组内存块的基地址赋给bar。

![[Pasted image 20240706204136.png]]

下面来考虑编译器如何翻译语句bar[k]=19。因为符号bar指向数组的基地址，该语句也能使用C语言*(bar+k)=19来表示，也就是，“将19存储到地址为bar+k的内存单元中。”为了实现这个操作，目标语言必须具有某种间接寻址机制。

![[Pasted image 20240706204409.png]]

**对象处理**
某个类（比如，Employee）的对象实例封装了数据项（比如name和salary），以及一组操纵它们的操作（operation，或称方法）。编译器对数据和操作的处理方式不一样的。

对象数据的底层处理方式与数组的处理方式很相似，也是在连续的内存段中存储每个对象实例。在大多数面向对象语言中，当一个“类”类型变量被声明时，编译器也仅分配一个指针变量。只有通过调用类构造函数来真正构建对象时，才给它分配所需的内存段。因此，当编译某个类Xxx的构造函数时，编译器首先利用类成员的数量和类型来决定在内存中需要多少个字（比如n）来存储类Xxx的一个对象实例。接下来，编译器生成为新创建对象分配内存的代码，例如，this=alloc(n)。该操作将this指针设置为表示新创建对象所在内存段的基地址。

![[Pasted image 20240706205311.png]]

因为每个对象被一个指向其基地址的指针变量所表示，所以可以使用相对于基地址的索引来访问对象所封装的数据。例如，假设Complex类包含下面的方法：
```Java
Public void mult (int c){
	re=re*c;
	im=im*c;
}
```
![[Pasted image 20240707130653.png]]

假设现在希望通过方法调用（比如b.mult(5)）来调用mult方法操作对象b。编译器应该如何来处理这个方法的调用呢？对于数据变量成员（如，re和im），每个对象实例都保存了各自的副本。然而对于类中的方法，它在目标代码层（target code level）只存在唯一副本，即所有该类的对象实例都共用同一个方法副本。为了使得每个对象实例看上去好像是封装了全部所需的代码，编译器必须保证这个唯一的方法副本能够对任意对象实例进行方便的操作。这就需要将被调用方法的引用（reference，也称函数指针）作为隐含参数传递给对象实例，因此编译b.mult(5)时，就好像它被写成了mult(b,5)。一般来说，对方法的调用foo.bar(v1, v2, ...)被翻译成VM代码push foo, push v1, push v2, ... , call bar。这样，编译器就能使得同一个方法副本可以操作任何对象实例，并且形成“每个对象实例都封装了全部代码”的假象。

然而，编译器的工作并没有完成。因为语言允许不同类中的不同方法具有相同的名字，所以编译器必须确保对应的方法被应用在对应的对象上。而且，因为在子类中可能出现方法重载（method overriding），面向对象语言的编译器必须在程序运行期间来确定。如果不支持以上操作（例如Jack语言），那就在编译期间来确定。对于如x.m(y)的方法调用，编译器必须保证调用的方法m( )属于对象实例x所属的那个类。

## 11.1.2 命令翻译
讨论两个问题：表达式求值（expression evaluation）和程序交流控制（control flow）。

**表达式求值**
计算形如x+g(2, y, -z) * 5 的高级表达式代码？对基于堆栈的目标平台，采用后缀表示法（也称为RPN, Right Polish Notation 即逆波兰表示法）

![[Pasted image 20240707132342.png]]

在RPN语法中，诸如f(x,y)的函数操作被表示成x，y，f(在VM语言语法中表示为：push x, push y, call f)。同样的，诸如x+y的操作，在这里被表示成x, y, +（也就是push x, push y, add）。

**程序流控制表达式的编译**
高级编程语言都具有多种流程控制结构，比如 if、while、for、switch等等。相比之下，低级语言一般提供两种基本的控制结构：条件goto和无条件goto。

![[Pasted image 20240707133039.png]]

# 11.2 规范详述
**用法**
Jack编译器接受单一的命令行参数，如下所示：
```sh
prompt> JackCompiler source
```
source是形如Xxx.jack的文件名称或是包含若干个.jack文件的路径名。编译器将各Xxx.jack文件编译成名为Xxx.vm的文件，并保存在与源文件相同的路径下。如果source是路径名，那么该路径下的每个.jack文件都将被编译，并在相同路径下生成对应的.vm文件。

## 11.2.1 虚拟机平台之上的标准映射
**文件命名和函数命名**
每个.jack文件被编译成独立的.vm文件。Jack子程序（函数，方法和构造函数）被编译成下列的VM函数：
- 在Jack程序中，类Yyy中的Jack子程序Xxx()被编译成名为Yyy.xxx的VM函数
- 拥有k个参数的Jack函数或构造函数被编译成对k个参数进行操作的VM函数。
- 拥有k个参数的Jack方法被编译成对k+1个参数进行的VM函数。第一个参数（参数0）总是指针this（用来引用当前对象）。

**内存分配和访问**
- Jack子程序的局部变量被分配到local虚拟段，并通过该段对其进行访问。
- Jack子程序的参数变量被分配到argument虚拟段，并通过该段对其进行访问。
- .jack类文件的静态变量被分配到相应的.vm文件的static虚拟段，并通过该段对其进行访问。
- 在Jack方法或构造函数相应的VM函数中，要想访问this对象的字段，首先通过使用pointer0来将以this指针指向的虚拟内存段（this虚拟段）映射为存储当前对象的内存段上（实际就是使this指针指向存储当前对象内存段的基地址），然后通过this index来访问对象中的各个成员，这里index是非负数。
- 在VM函数中，要想访问数组的数据项，同访问对象的方法相似，首先通过使用pointer1使得that指针指向数组的第一个元素，然后通过that指针来访问数组中的数据项。

**子程序调用**
- 在调用VM函数之前，调用者（本身也是VM函数）必须将函数的参数压入堆栈。如果被调用的VM函数是Jack方法，那么首先压入的参数必须是该方法操作对象的引用（reference）。
- 将Jack方法编译成VM函数时，编译器必须插入适当的VM代码来设置this虚拟段的基地址。同样，在编译Jack构造函数时，编译器也必须插入VM代码，该代码为新对象分配一个内存段然后将this指向这个内存段的基地址。

**从返回类型为Void的方法及函数返回**
高级void子程序并不返回值。这个抽象按如下方式来处理：
- 返回类型为void的方法和函数所对应的VM函数必须返回常数0作为其返回值。
- 编译do sub 语句时（sub是返回类型为void的方法或函数），对应的调用者必须弹出（并忽略）该返回值（该值总是常数0）。

**常数**
- null 和 false 被映射到常数0。true 被映射到常数-1（该常数可以通过push constant 1，再对其进行neg操作来得到）。

**使用操作系统服务**
基本的Jack OS是以一组名为Math.vm、Array.vm、Output.vm、Screen.vm、Keyboard.vm、Memory.vm和Sys.vm的VM文件来实现的。所有这些文件必须与编译器生成的VM文件保存在一起。因此，任何VM函数可以调用OS的任何VM函数。编译器在生成代码的时候会用到以下OS提供的函数：
- 乘法和除法由OS函数Math.multiply()和Math.divide()来处理。
- 字符串常数由OS构造函数String.new(length)来创建。字符串赋值如x="cc...c"可以通过对OS程序String.appendchar(nextChar)的一系列调用那个来实现。
- 构造函数利用OS函数Memory.alloc(size)来为新对象分配空间。

## 11.2.2 编译过程举例
![[Pasted image 20240707192004.png]]
![[Pasted image 20240707192021.png]]

# 11.4 观点
Jack是一门相对简单的编程语言，这个事实回避了几个让人头疼的编译问题。例如，Jack看上去像是一种带类型的语言（typed language），然而事实并非如此。所有的Jack数据类型都是16-位长的，语言的语义允许Jack编译器忽略几乎所有的类型信息。因而，当编译和计算表达式时，Jack编译器不需要确定它们的类型（有一个例外：编译方法调用x.m()时，需要确定x的“类”类型）。同样的，Jack中的数组数据项也没有被指定类型。相比之下，大多数编程语言都具有丰富的类型系统，并对其编译器产生重要影响；对于不同类型的变量必须分配不同数量的内存；从一种类型到另一种类型的转换需要特定的语言操作；对诸如x+y的简单表达式的操作，很大程度上依赖于x和y的类型；等等。

另一个重大简化就是Jack语言没有支持继承（inheritance）。这意味着可以在编译期静态地处理所有方法调用。相比之下，支持继承的语言编译器必须将方法作为虚拟方法对待，并根据对象的运行期类型来确定它们的具体位置。例如，考虑方法调用x.m()。如果语言支持继承，x就有可能属于多个类，这就无法在运行期之前确定它具体属于哪个类。因此，如果在x所属的类中找不到方法m的定义，还可能在该类的父类中找到。

Jack所不支持的另一种面向对象的的重要属性是公共类成员字段（public class fields）。例如，若circ是类型为Circle的对象，该类有属性radius，我们就不能通过编写诸如r=circ.radius这样的语句来访问circ对象中的radius成员，为此，必须为访问Circle类中的成员编写并调用专门的读取方法：r=circ.getRaius()来访问radius成员。

