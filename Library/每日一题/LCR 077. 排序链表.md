https://leetcode.cn/problems/7WHec2/solutions/1401990/lian-biao-pai-xu-by-leetcode-solution-0rjx

时间复杂度是 O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是$O(n^2)$，其中最适合链表的排序算法是归并排序。

归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是$O(log \,n)$。如果要达到O(1) 的空间复杂度，则需要自底向上的实现方式。

# 方法一：自顶向下归并排序
如下：
- 1. 找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。
- 2. 对两个子链表分别排序。
- 3. 将两个排序后的子链表合并，得到完整的排序后的链表

上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 1，即当链表为空或者链表只包含 1 个节点时，不需要对链表进行拆分和排序。

复杂度分析：
- 时间复杂度：O(n log n)，其中 n 是链表的长度。
- 空间复杂度：O(log n)。

什么是链表的拆分，链表每一个节点打开，node-next = NULL

# 方法二：自底向上归并排序
用迭代，不用递归，从一开始subLength=1，然后倍增思想，不断迭代，达到O(1) 的空间复杂度。



