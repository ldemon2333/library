# 拆包、打包
星号 * 可以用来将一个列表拆包（unpacking）成单独元素，也可以将若干元素打包放入另一个列表中\

![[Pasted image 20240909225627.png]]

用星号 * 拆包、打包也适用于元组和字符串，但打包之后的结果为列表。

![[Pasted image 20240909225734.png]]

# 视图vs浅复制vs深复制
如果用 = 直接赋值，是非拷贝方法，结果是产生一个视图（view）。这两个列表是等价的，修改其中任何（原始列表、视图）一个列表都会影响到另一个列表。

![[Pasted image 20240909230008.png]]

如图8所示，用等号 = 赋值得到的list_2和list_1共享同一地址，这就是我们为什么称list_2为视图。

而通过copy()获得的list_3和list_1地址不同。

在 python 中，列表是可变对象，因此在复制列表时会涉及到深复制和浅复制的概念。

**浅复制 (shallow copy)**  只对 list 的第一层元素完成拷贝，深层元素还是和原 list 共用。

**深复制 (deep copy)**  是创建一个完全独立的列表对象，该对象中的元素与原始列表中的元素是不同的对象。

特别是对于嵌套列表，建议采用copy.deepcopy()深复制。

# 5.5 其他数据类型：元组、集合、字典
## 元组
--- 
元组（tuple）是一种不可变的序列类型，用圆括号（）来表示。元组一旦创建就不能被修改。不能添加或删除其中的元素。

列表是可变的。元组的优势在于它们比列表更轻量级。

---
在自定义函数时，可以使用 / 和 * 来声明参数传递方式。在 Python 的函数定义中，正斜杠 / 之前的参数是位置参数；在正斜杠 / 和星号 * 之间位置或关键字传递都可以；在星号 * 之后必须 按关键字传递。


# 9 OOP面向对象编程
## 9.4 装饰器
---
在python中，装饰器（decorator）是一种特殊的语法，用于在不修改函数代码的情况下，为函数添加额外的功能或修改函数的行为。

![[Pasted image 20240910102213.png]]

## 9.5 父类、子类
---
父类（parent class），也称基类、超类，在继承关系中层次更高；子类，也称派生类，可以继承父类的属性和方法，从而实现代码的重用和扩展。

![[Pasted image 20240910103005.png]]


# 10 可视化
![[Pasted image 20240910103148.png]]

# 核密度估计KDE
---
核密度估计 (Kernel Density Estimation, KDE) 是一种非参数方法，用于估计连续变量的概率密度函数 (Probability Density Function, PDF)。它通过将每个数据点视为一个核函数(通常是高斯核函数)，在整个变量范围内生成一系列核函数，然后将这些核函数进行平滑和叠加，从而得到连续的概率密度估计曲线。

![[Pasted image 20240910234309.png]]

核密度估计的目标是通过在数据点附近生成高斯分布的核函数，捕捉数据的分布特征和结构。具体地说，每个数据点的核函数会在其附近产生一个小的高斯分布，然后将所有核函数叠加在一起。通过调 整核函数的带宽参数，可以控制估计曲线的平滑程度和敏感度。

# 14 Numpy索引
---
NumPy 的切片操作返回的是原数组的视图 (view) 而不是副本 (copy)，因此对切片操作所得到的数组进行修改会直接影响到原数组。

## 14.3 视图VS副本
---
在 NumPy 中，有两种不同的方式来创建新的数组对象——视图 (view)、副本 (copy)。

视图是原始数组的一个新视图，而副本是原始数组的一个新副本。它们的区别在于它们如何处理原 始数据的内存和共享。 

视图是原始数组的一个新视图，一种重新排列、重新解释。视图是原始数组共享相同的数据，不会 创建新的内存。 

换句话说，视图是原始数组的一个不同的“窗口”，它可以访问原始数组的相同数据块。当对视图进 行更改时，原始数组也会发生相应的更改。

副本则是原始数组的一份完整的拷贝，修改副本不会影响原始数组。当对数组进行切片或使用 numpy.copy() 方法时，将生成一个副本。副本的创建可以使用 numpy.copy() 方法或者 numpy.array() 函数的参数 copy = True 来实现。


# 15.3 统计运算
![[Pasted image 20240911104144.png]]

![[Pasted image 20240911104204.png]]

![[Pasted image 20240911104231.png]]

# 16.2 一维数组 → 行向量、列向量

![[Pasted image 20240911113602.png]]

## 一维数组 → 行向量
---
本书前文提过，行向量、列向量都是特殊矩阵。因此，行向量、列向量都是二维数组。也就是说， 行向量是一行若干列的数组，形状为 1 × D。列向量是若干行一列的数组，形状为 n × 1。

![[Pasted image 20240911113354.png]]

![[Pasted image 20240911113422.png]]

## 一维数组 → 列向量
---
![[Pasted image 20240911113450.png]]

# 16.3 一维数组 → 二维数组
![[Pasted image 20240911113636.png]]

 
## numpy.reshape 与 numpy.resize 区别

### 1. `numpy.reshape`

- **作用**：用于改变数组的形状，但不会改变数组的总元素数。新的形状必须与原始形状兼容。
- **特性**：返回的是原始数组的视图（view），不会改变原数组本身。如果新形状与原数组不兼容，会抛出错误。
  
### 2. `numpy.resize`

- **作用**：用于改变数组的形状，如果新形状的大小大于原数组的大小，`resize` 会重复填充原数组中的元素。如果新形状的大小小于原数组的大小，则会截断原数组。
- **特性**：可以改变数组的大小，而不仅仅是形状。如果你传入的形状大小不匹配，`resize` 不会报错，而是自动调整数据大小。

#### 示例：
```python
import numpy as np

arr = np.array([1, 2, 3, 4])
resized_arr = np.resize(arr, (3, 3))  # 将 1D 数组调整为 3x3 的 2D 数组

print(resized_arr)
# 输出：
# [[1 2 3]
#  [4 1 2]
#  [3 4 1]]
```

- **注意**：当调整的形状大于原数组大小时，`resize` 会重复使用原数据的元素来填充新数组。

### 主要区别：

1. **元素数量**：
   - `reshape` 要求新形状和原数组的总元素数量相同。
   - `resize` 不要求相同，数组会被截断或扩展。
   
2. **返回值**：
   - `reshape` 返回的是原数组的视图，不改变原数组。
   - `resize` 可以返回新的数组，或者通过 `arr.resize()` 修改原数组。

3. **重复填充和截断**：
   - `reshape` 不会改变数组的元素个数，也不会重复填充数据。
   - `resize` 会根据新形状自动填充或截断数据。

# 16.5 视图VS副本
视图和副本是 NumPy 中的两种不同的数组对象。

视图是指一个数组的不同视角或者不同形状的表现方式，视图和原始数组共享数据存储区，因此在对视图进行操作时，会影响原始数组的数据。视图可以通过数组的切片、转置、重塑等操作创建。

大家可以看到，我们用 numpy.shares_memory() 判断两个数组是否指向同一个内存。

# 16.6 转置
![[Pasted image 20240911114825.png]]

一维数组转置不改变形状，一维数组指（125，）


# 16.7 扁平化
![[Pasted image 20240911115118.png]]

![[Pasted image 20240911115214.png]]

如果需要返回一个数组副本，可以使用flatten( )函数

# 16.8 旋转、翻转
![[Pasted image 20240911115432.png]]

# 16.9 堆叠
## 沿行堆叠
---
![[Pasted image 20240911115715.png]]

![[Pasted image 20240911115723.png]]

## 沿列堆叠
---
![[Pasted image 20240911115847.png]]

![[Pasted image 20240911115920.png]]

![[Pasted image 20240911115928.png]]

## 拼接
---
![[Pasted image 20240911120000.png]]

## 堆叠结果为三维数组
---
![[Pasted image 20240911120310.png]]

![[Pasted image 20240911120937.png]]

![[Pasted image 20240911120948.png]]

# 16.10重复

![[Pasted image 20240911121135.png]]

![[Pasted image 20240911121141.png]]

# 16.11分块矩阵
## 合成
---
![[Pasted image 20240911121429.png]]

## 切割
---
numpy.split( )函数可以将一个数组沿指定轴分割为多个子数组。numpy.split( )接受三个参数：要分割的数组、分割的索引位置、沿着哪个轴进行分割。

![[Pasted image 20240911122236.png]]

![[Pasted image 20240911122258.png]]







