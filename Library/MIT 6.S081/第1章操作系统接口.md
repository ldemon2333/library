操作系统的工作是
1. 将计算机的资源在多个程序间共享，并且给程序提供一系列比硬件本身更有用的服务。
2. 管理并抽象底层硬件，比如，一个文件处理软件（Word）不用去关心自己使用的是何种硬盘。
3. 多路复用硬件，使得多个程序可以(至少看起来是)同时运行的。
4. 给程序间提供一种受控的交互方式，使得程序之间可以共享数据、共同工作。

操作系统通过接口向用户程序提供服务。设计一个好的接口实际上是很难的。一方面我们希望接口设计得简单和精准，使其易于正确地实现；另一方面，我们可能忍不住想为应用提供一些更加复杂的功能。解决这种矛盾的办法是让接口的设计依赖于少量的 _机制_ （_mechanism_)，而通过这些机制的组合提供强大、通用的功能。

本书通过 xv6 操作系统来阐述操作系统的概念，它提供 Unix 操作系统中的基本接口，同时模仿 Unix 的内部设计。Unix 里机制结合良好的窄接口提供了令人吃惊的通用性。这样的接口设计非常成功，使得包括 BSD，Linux，Mac OS X，Solaris （甚至 Microsoft Windows 在某种程度上）都有类似 Unix 的接口。理解 xv6 是理解这些操作系统的一个良好起点。
![[Pasted image 20241014190936.png]]
如图1.1所示，xv6 使用了传统的**内核**概念 - 一个向其他运行中程序提供服务的特殊程序。每一个运行中程序（称之为**进程**）都拥有包含指令、数据、栈的内存空间。指令实现了程序的运算，数据是用于运算过程的变量，栈管理了程序的过程调用。

当进程需要调用内核服务时，它会调用 system call ，这是操作系统接口中的调用之一。 系统调用进入内核；内核执行服务并返回。因此，一个进程交替执行 user space 和 kernel space 。

内核使用了 CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间。内核拥有实现保护机制所需的硬件权限(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。

内核提供的一系列系统调用就是用户程序可见的操作系统接口，xv6 内核提供了 Unix 传统系统调用的一部分，它们是：

| 系统调用                    | 描述                 |
| ----------------------- | ------------------ |
| fork()                  | 创建进程               |
| exit()                  | 结束当前进程             |
| wait()                  | 等待子进程结束            |
| kill(pid)               | 结束pid所指进程          |
| getpid()                | 获得当前进程pid          |
| sleep(n)                | 睡眠 n 秒             |
| exec(filename,*argv)    | 加载并执行一个文件          |
| sbrk(n)                 | 为进程内存空间增加 n 字节     |
| open(filename,flags)    | 打开文件，flags 指定读/写模式 |
| read(fd,buf,n)          | 从文件中读 n 个字节到buf    |
| write(fd,buf,n)         | 从buf中写 n 个字节到文件    |
| close(fd)               | 关闭打开的fd            |
| dup(fd)                 | 复制fd               |
| pipe(p)                 | 创建管道，并把读和写的fd返回到p  |
| chdir(dirname)          | 改变当前目录             |
| mkdir(dirname)          | 创建新的目录             |
| mknod(name,major,minor) | 创建设备文件             |
| fstat(fd)               | 返回文件信息             |
| link(f1,f2)             | 给f1创建一个新名字(f2)     |
| unlink(filename)        | 删除文件               |
这一章剩下的部分将说明 xv6 系统服务的概貌 —— 进程，内存，文件描述符，管道和文件系统，为了描述他们，我们给出了代码和一些讨论。这些系统调用在 shell 上的应用阐述了他们的设计是多么独具匠心。

shell 是一个普通的程序，它读取用户的命令并执行它们。shell 是一个用户程序，而不 是内核的一部分，这一事实说明了系统调用接口的强大功能：shell 没有什么特别的。这也 意味着外壳易于更换；因此，现代 Unix 系统有多种 shell 可供选择，每种都有自己的用户 界面和脚本功能。xv6 shell 是 Unix Bourne shell 本质的简单实现。它的实现可以在以下位 置找到 (user/sh.c) 。

# 进程和内存
xv6 进程由用户空间内存（指令、数据和堆栈）和内核私有的进程状态组成。Xv6 *time-share* 进程：它在等待执行的进程集中透明地切换可用CPU。当进程未执行时，xv6会保存进程的CPU寄存器，并在下次运行进程时回复它们。内核将进程标识符（PID）与每个进程关联。

一个进程可以使用fork系统调用创建一个新进程。fork为新进程提供了父进程内存的精确副本，包括指令和数据。fork在父进程和子进程中均返回。在父进程中，fork返回子进程的PID。在子进程中，fork返回0。

![[Pasted image 20241014222031.png]]
该 exit 系统调用导致调用进程停止执行并释放内存和打开文件等资源。exit 采用整数状态参数，通常 0 表示成功，1 表示失败。这 wait 系统调用返回当前进程已退出（或被杀死）的子进程PID，并将子进程的退出状态复制到传递给 wait 的地址；如果调用者的子进程都没有退出，则 wait 等待其中一个退出。如果调用者没有子进程，wait 立即返回 -1。 如果父进程不关心子进程的退出状态，它可以将 0 地址传递给 wait