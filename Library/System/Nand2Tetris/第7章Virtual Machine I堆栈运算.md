介绍构建典型的基于对象(object-based)的高级语言编译器的最初步骤。分两个步骤。首先，高级语言将被翻译成中间代码，然后中间代码被转化为机器语言。这种思想被称为(two-tier)转换模型。

基本思想如下：
中间代码运行在虚拟机(Virtual Machine)上，而不是真实的硬件平台上。VM是并不真实存在的抽象计算机，但是却能在其他的计算机平台上得以实现。

本章介绍典型的VM结构，它是以Java虚拟机(Java Virtual Machine, JVM)的模型为蓝本。

虚拟机模型一般配有一种语言，可以利用这种语言来编写VM程序。这里介绍的VM语言包括4种类型的命令：算术命令，内存访问命令，程序流程控制命令和子程序调用命令，本章构建基本的VM翻译器，它能将VM的算术命令和内存访问命令翻译成机器语言。

两种虚拟机模型——Java体系和Net架构

# 7.1 背景知识
## 7.1.1 The Virtual Machine Paradigm
作为一个独立程序的编译器现在被分成两个独立的程序。第一个程序，仍然成为编译器(compiler)，将高级代码翻译成中间VM指令，第二个程序将这个VM代码翻译成目标计算机硬件平台的机器语言。

优点：
- 虚拟机实现部分（编译器的后端程序，backend）就能相对容易地得到不同硬件平台的编译器。因此，虚拟机在不同硬件平台之间的可移植性可以实现代码效率、硬件成本和程序开发难度之间的权衡。
- 很多语言的编译器能够共享VM后端程序，允许代码共享和语言互用性。比如，某种高级语言善于科学计算，而另一种在处理用户接口方面很突出。如果把两种语言编译到通用的VM层，那么通过使用约定的调用语法，其中一种语言的程序就能够很容易地调用另一种语言的程序。
- 模块化，VM效率的每一个改善都会立即被所有构建于其上的编译器继承。

![[Pasted image 20240630163701.png]]

## 7.1.2 堆栈机模型
在VM操作中的操作数和结果应该驻留在哪里。

在堆栈机（stack machine）模型里，算术命令将其操作数从堆栈顶弹出，并将结果从栈顶压入。经证明，这些简单的堆栈操作可以被用来计算任何数学或逻辑表达式。

堆栈存取在很多方面不同于普通的内存访问
- 堆栈只有顶部一个出入口，一次只能存/取一个元素。
- 读取堆栈是一种“丢失”操作：读取栈顶元素值的唯一方法是将其从堆栈中移除。相比之下，从普通内存单元读取值的行为就不会对内存的状态产生影响。
- 给堆栈添加新元素的操作就是直接将其压入栈顶，而不会改变堆栈的其余部分。然而，将值赋予一个普通的内存位置则是“丢失”操作，因为它覆盖了该内存单元内原来的值。

![[Pasted image 20240630164747.png]]

在我们这里构建的虚拟机体系里面，堆栈主要有两个用途：
- 它被用来处理所有VM的算术和逻辑操作
- 它使得子程序调用和相关的内存分配变得容易

# 7.2 VM规范详述
## 7.2.1 概论
VM语言使用单一的16位数据类型，它能够表示整数，布尔类型，或者指针。该语言包含四种类型的命令：
- 算术命令：在堆栈上执行算术和逻辑操作
- 存储器存取命令：在堆栈和虚拟内存单元之间转移数据
- 程序流程命令：使条件分支操作和无条件分支操作变得容易
- 函数调用命令：调用函数并返回调用处（即函数调用指令的下一条指令地址）

**程序和命令结构**  VM程序是有一个或多个扩展名为.vm的文件构成的集合，而每个程序又包含一个或多个函数。从编译的角度来看，这些结构分别与面向对象编程语言中的程序(program)、类(class)和方法(method)的概念相对应。

![[Pasted image 20240630165741.png]]

## 7.2.2 算术命令和逻辑命令
VM语言有9个面向堆栈的算术命令和逻辑命令。其中的7个命令是二元的。

![[Pasted image 20240630165959.png]]

## 7.2.3 内存访问命令
内存访问命令使用伪命令pop和push x 来表示，这里符号x代表在某个全局内存中的一个独立的存储单元。VM操纵8个独立的虚拟内存段（virtual memory segments）

![[Pasted image 20240630170248.png]]

比如，push argument 2 和pop local 1 语句将会把函数的第三个参数的值存储在函数的第二个局部变量中（每个segment的index均从0开始）。

![[Pasted image 20240630170643.png]]

除了这8个虚拟内存段可被VM的pop和push直接操作，VM还操纵两个暗含的数据结构成为堆栈（stack）和堆（heap）。这些数据结构从来不会被直接提到，但随着VM对它们进行操纵，它们的状态却会在后台变化。

**堆栈（stack）** 考虑两条连续的命令语句push argument 2 和 pop local 1，这个在前面提及过。这样的VM操作的工作内存就是堆栈。数据值并不是简单地直接从一个单元跳到另一个单元，而是必须经过堆栈中转。

**堆（heap）** 处在VM后端的另一个数据结构就是堆。堆是RAM区域的名字，用来存储对象和数组数据。

## 7.2.4 程序流程控制命令和函数调用命令
![[Pasted image 20240630171220.png]]

## 7.2.5 Jack-VM-Hack平台中的程序元素
让我们采取自顶向下的视角，审视典型的高级程序在完整编译过程中所涉及的所有程序元素。

![[Pasted image 20240630171354.png]]

在图7.8的顶部我们看见一个Jack程序（Jack是简单的类Java语言）。每个Jack类包含一个或多个函数。

## 7.2.6 VM编程实例
3个例子
1. **典型的算法任务**

![[Pasted image 20240630171858.png]]
![[Pasted image 20240630171946.png]]

乘法算法的源代码，编译器应该如何用VM语言来表达这个算法呢？

当VM函数开始运行时，它假定：
- 堆栈是空的
- 用来被操作的参数值位于程序的argument部分
- 在程序local部分的局部变量都被初始化为0

VM命令不能使用符号化的参数和变量名，只能按照<segment index>的形式来进行引用。只需要将x,y,sum和j分别映射成argument 0、argument 1、local 0和local 1。
 
2. **数组处理** 

假定高级语言程序创建了名为bar的由10个整数组成的数组，然后填入了10个数字。现在假定数组的基地址已经被映射到RAM地址4315处。假设现在程序想要执
行命令bar[2]=19。

在C语言里面，这样的操作可以被描述为*(bar+2)=19，意思是“将RAM中地址为bar+2的位置赋予值19”（VM中有两个指针pointer0和pointer1,分别对应两个虚拟内存段this和that;如果将pointer0或pointer1赋予某特定内存地址address，那么实际上就是将对应的this和that两个虚拟内存段映射到内存中以address地址开始的一块内存段。）

![[Pasted image 20240630183802.png]]

3. **对象处理**

高级语言的程序员将对象看成是封装了数据（由成员字段即fields;或者属性即properties组成）和相关代码（由方法即methods）的实体。然而从本质上将，每个对象实例（object instance）的数据是在RAM上被序列化（serialized）成一串数字，这串数字代表对象中各个字段的值。因此，对象的低级处理和数组的低级处理相似。

例如，考虑一个动画程序，该程序在屏幕上弹球。假设每个球对象被整数字段x、y、radius和color来描述，而且程序创建了该对象并命名为b。那么在计算机里这个对象的内部形式。

像所有其他对象实例一样，它会被存储在RAM里。当程序在创建一个新对象，编译器都会以字为单位计算对象的大小，然后OS会寻找一个足够大的RAM空间并分配给该对象来存储它的内容。现在，假设b对象已经被分配了从3012地址到3015地址的RAM空间。如图7.11所示

![[Pasted image 20240630184956.png]]

假设现在有一高级语言程序中有名为resize的方法，以Ball对象和整数r为参数，该方法将球的半径设为r 。

将pointer 0 的值设为argument 0，实际上就好似将this虚拟内存段的地址设成对象的基地址，这样通过VM指令就可以用this段和一个索引号来访问对象中任何数据成员。使用的索引号是我们所访问的数据成员地址相对于其对象基址的偏移量。

# 7.3 实现
## 7.3.1 Hack平台上的标准VM映射，第I部分
**从VM到Hack的翻译** 

前面介绍过VM程序是由一个或多个扩展名为.vm的文件构成的集合，每个文件包含一个或多个VM函数，每个函数又由一系列VM命令构成。VM翻译器将这些.vm文件作为输入，产生一个单一的Hack汇编语言.asm文件作为输出。每个VM命令被翻译成Hack汇编命令。.vm文件中函数的顺序对程序的执行没有影响。

**RAM用法**

Hack计算机的数据内存由32K个16-位字组成。前16K作为通用RAM。下一个16K包含I/O设备的内存映像。

![[Pasted image 20240630190711.png]]

前面介绍，根据Hack机器语言规范，任何汇编程序都能够使用R0～R15的符号来指代0～15的RAM地址单元。另外，规范还规定了汇编程序可以使用SP、LCL、ARG、THIS和THAT来分别指代RAM地址0～4。在VM程序里面的这些寄存器的用法如下所示：

![[Pasted image 20240630190950.png]]

**内存段映射**

Constant：这个段是真正虚拟的，因为它不占用目标平台上的任何物理存储空间。VM实现通过简单地提供常数i来处理任何VM对<constant i>的访问。

Static：在汇编程序中每遇到一个新的符号时，编译器就为其分配一个新的RAM单元，从地址16处开始。利用这个规定，使用汇编语言符号f.j来表示VM文件f中的每个静态变量数字j。

**汇编语言符号**

![[Pasted image 20240630192757.png]]

# 7.4 观点

开发用于高级语言的编译器，采用两层(two-tier)编译模型来进行开发。在前端（frontend）层级，高级代码被翻译为运行在虚拟机上的中间代码。在后端（backend）层级，中间代码被翻译为目标硬件平台的机器语言。

JVM是一种规范，描述了Java编译器的目标语言，即称为bytecode的中间语言。用bytecode编写的文件被作为Java程序的动态代码发布版本在互联网上进行发布，最常用的是嵌在网页里面的applets（Java小应用程序）。

21世纪，微软推出.NET体系架构，.NET的核心是称为Common Language Runtime(CLR，公共语言运行时)的虚拟机模型。在虚拟机模型发挥互操作性的巨大潜力之前，必须要将一个关键成分加入虚拟机模型，这个成分就是通用软件程序库(common software library)。Java虚拟机带有Java程序库，微软的虚拟机带有CLR。可以将这些软件程序库看作小型操作系统，为运行在虚拟机上的语言提供了统一的服务，比如内存管理、GUI组件、字符串处理函数、数学函数等等。

# 7.5 项目实现

```
set RAM[0] 256,   // stack pointer
set RAM[1] 300,   // base address of the local segment
set RAM[2] 400,   // base address of the argument segment
set RAM[3] 3000,  // base address of the this segment
set RAM[4] 3010,  // base address of the that segment
```
---

```
push constant 10
```

转汇编

![[Pasted image 20240630221836.png]]

```
@10
D=A //D=10

//接下来是标准push操作

@SP //SP的存放在R0，将A寄存器的值设为0
A=M //A=M[0]=256，此时A修改为SP值，栈顶元素存放的实际位置在     
    //RAM[256]
M=D //M[A=256]=10，进栈操作
@SP //SP的地址是0,将A寄存器修改为0
M=M+1 //M[A=0]+1，实际上把M[0]修改为257，完成++操作
```
---
```
pop local 0
```

转汇编

```
@0 //0放入A寄存器
D=A //D=0
@LCL //LCL=1，1放入A寄存器
D=M+D //M[A=1]+0->D，其中M[1]=300，D=300
@R15 //R15=15，A=15
M=D //M[15]=300

//接下来是标准pop
@SP //SP=0
AM=M-1 //M[0]-1=256, M[0]=256, A=256
D=M  //D=M[A=256]=10
@R15
A=M //A=M[15]=300
M=D //M[300]=10
```
---

``` 
//eq
@SP //SP=0, M[SP]=258, A=0
AM=M-1 //M[0]=257, A=257
D=M //D=M[257]=17
A=A-1 //A=256
D=M-D //M[256]-17=0
M=0 //M[256] =0 
@eq_0 //
D;JNE //Jump to (eq_0) when not D not equal 0
@SP //SP=0, A=0
A=M-1 //A=M[0]-1=257-1=256
M=-1 //M[256]=-1, true
(eq_0)
```









 

