Darwin OS 容器虚拟化的实现：

Darwin 上进程 struct 是如何表示的

linux 上 namespaces 机制实现（更多的是软件上的定义结构）Linux 2.6.24 版本

# Namespaces （软件上的修改）
主要通过 clone 和 unshare 两个函数创建新的命名空间
命名空间的实现需要两个部分：每个子系统的命名空间结构，将此前所有的全局组件包装到命名空间中；将给定进程关联到所属各个命名空间的机制。
![[Pasted image 20250303152648.png]]
![[Pasted image 20250303153524.png]]


每个进程的 task_struct 都关联到一个 nsproxy 指针
![[Pasted image 20250303153850.png]]

The initial global namespaces is defined by `init_nsproxy`, which keeps pointers to the initial objects of the per-subsystem namespaces:
![[Pasted image 20250303154536.png]]
![[Pasted image 20250303154553.png]]

## 示例：UTS 命名空间具体实现（最简单的命名空间机制）
![[Pasted image 20250303154739.png]]
kref 是一个嵌入的引用计数器，可用于跟踪内核中有多少地方使用了 struct uts_namespace 的实例。uts_namespace 所提供的属性信息本身包含在 struct new_utsname 中：
![[Pasted image 20250303154856.png]]
各个字符串分别存储了系统的名称（Linux）、内核发布版本、机器名。

内核如何创建一个新的 UTS 命名空间，通过 copy_utsname 函数。某个进程调用 fork 并通过 CLONE_NEWUTS 标志创建新的 UTS 命名空间时，调用该函数，首先生成先前的 uts_namespace 实例的一份副本，当前进程的 nsproxy 实例内部的指针会指向新的副本。然后修改子进程的 uts_namespace 的实例。

## Darwin OS 上实现示例
首先进程的 task_struct 是怎么定义的，但目前看的文档里没看到 task_struct 的定义。更多的是从软件上实现的一种容器抽象机制

# cgroup v2 实现
这里要想清楚两个问题

首先应解决一个问题，linux OS 是如何采集和展示硬件资源的使用情况的。如何知道 CPU、内存、硬盘等资源的使用情况？这些信息是如何从硬件传递到软件的。

#### 1. 硬件资源监控机制

Linux系统通过多种机制从硬件层面收集资源使用情况。这些机制主要包括：

- **性能监控单元（PMU）**：现代CPU内置了PMU，能够实时监控CPU的使用情况，如每个核心的负载、缓存命中率等。Linux内核通过访问这些PMU寄存器，获取CPU的详细使用数据。

- **内存控制器**：部分主板配备了内存控制器，能够监控内存的使用情况，如已使用的内存总量、空闲内存等。Linux内核通过与这些控制器的交互，收集内存使用数据。

- **磁盘设备命令**：磁盘设备（如ATA和SCSI设备）支持特定命令，用于查询设备的I/O操作状态。Linux内核通过发送这些命令，获取磁盘的读写操作次数和大小。

#### 2. 操作系统内核的数据收集

Linux内核通过以下方式收集和整合硬件资源的使用数据：

- **定时器中断**：内核利用定时器中断定期统计CPU的使用情况。每次中断触发时，内核记录各个核心的活动状态，从而计算出CPU的使用率。
    
- **内存管理单元**：内核维护着详细的页表，跟踪内存页的使用情况。通过遍历这些页表，内核可以统计已使用的内存总量和空闲内存。
    
- **块设备层**：内核在块设备层记录磁盘I/O操作的完成情况，包括读写操作的次数和大小。这些数据被整合到内核的统计信息中。
    

#### 3. 用户空间工具的实现

用户空间工具通过读取内核提供的接口，获取资源使用数据并将其呈现出来。常用工具及其工作原理如下：

- **top/htop**：这些工具通过读取/proc/stat文件，获取CPU的使用情况；通过读取/proc/meminfo文件，获取内存的使用情况。它们定期刷新数据，动态展示系统资源的使用状态。
    
- **vmstat**：该工具通过读取内核的虚拟内存统计信息，展示内存使用、磁盘I/O、进程状态等信息。它能够提供系统的整体资源使用情况快照。
    
- **iostat**：此工具专门用于监控磁盘I/O性能。它通过读取内核的磁盘统计信息，展示各个设备的读写操作次数、传输速度等。
    

#### 4. 具体实现细节

- **/proc虚拟文件系统**：Linux内核通过/proc文件系统向用户空间提供丰富的系统信息。例如，/proc/cpuinfo包含CPU信息，/proc/meminfo包含内存信息，/proc/stat包含系统统计信息。用户空间工具通过读取这些文件，获取所需的数据。
    
- **sysctl接口**：通过sysctl命令，用户可以访问和修改内核参数。部分资源使用情况的信息也可以通过sysctl接口获取。
    
- **系统调用**：用户空间程序可以通过系统调用（如getprocs）获取进程信息，从而间接了解资源的使用情况。


#### 6. 实际应用示例

以top命令为例，其工作流程如下：

1. **初始化**：top命令启动后，初始化界面并设置刷新频率。
    
2. **数据获取**：
    
    - 通过读取/proc/stat文件，获取CPU的使用情况。
    - 通过读取/proc/meminfo文件，获取内存的使用情况。
    - 通过读取/proc/loadavg文件，获取系统的负载平均值。
3. **数据处理**：对获取的数据进行处理，计算出各项指标，如CPU使用率、内存使用率等。
    
4. **显示更新**：将处理后的数据显示在终端上，并按设定的频率刷新。
    
5. **响应用户输入**：接收用户的按键输入，执行相应的操作，如排序、过滤等。



第二个问题：在 linux 上我修改了某个进程 cgroup 的限制，比如说硬件、cpu、内存资源的限制，我只是改了几个文件，那么反映到硬件上是如何限制这个进程硬件资源的使用情况的呢？cgroup 上的修改到不说是一种软件上的限制，并没有真实反映到具体硬件上资源的限制。

### 步骤详解：cgroup v2如何通过软件与硬件交互限制进程资源使用
1. **理解cgroup v2的基础架构**
    
    - **cgroup v2的文件系统结构**
        - cgroup v2采用统一的文件系统结构，所有的资源控制器（如CPU、内存、磁盘I/O等）都集中在一个层级结构中。
        - 主要的控制文件包括：
            - `cgroup.procs` ：列出属于该控制组的进程ID。
            - `cpu.weight` ：设置CPU资源的权重。
            - `cpu.max` ：设置CPU资源的最大使用时间。
            - `memory.current` ：显示当前内存使用情况。
            - `memory.high` ：设置内存的高水位限制。
            - `memory.max` ：设置内存的上限。
2. **配置cgroup v2的资源限制**
    
    - **设置CPU资源限制**
        - 使用`cpu.weight` 参数来设定控制组的CPU资源权重。例如：  bash echo 500 > /sys/fs/cgroup/cpu.weight
            
        - 使用`cpu.max` 参数来设定控制组在一定时间内的最大CPU使用时间。例如：  bash echo 100ms 100ms > /sys/fs/cgroup/cpu.max
            
3. **Linux内核调度器的角色**
    - **调度器的基本工作原理**
        - Linux内核的调度器负责决定哪些进程在什么时候运行。调度器根据进程的优先级、资源需求等因素来分配CPU时间。
    - **cgroup与调度器的交互**
        - 当cgroup的资源限制参数发生变化时，内核会通知调度器，调度器会根据新的参数重新计算和分配CPU时间片。
        - 调度器在选择下一个运行的进程时，会参考进程所属控制组的资源限制，从而确保整体的资源使用符合预设的限制。


这里 cgroup 只是一个参考说明书，是给 Linux 内核调度器看的，调度器去实现资源的限制。

放在 Darwin 上也应该是如此。这里不就连起来了，cgroup 上的需要有哪些资源取决于调度器实现，调度器选择一个任务后，要查看该任务的 cgroup 资源限制说明，分配给它具体限制的资源，然后在运行。

如果要在往下挖，就是Darwin 上调度器如何限定硬件资源来执行任务，任务和硬件资源具体是如何绑定起来的问题。

