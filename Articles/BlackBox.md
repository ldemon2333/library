# Abstract
Containers rely on the operating system to enforce their security guatantees. This poses a significant security risk as large operating system codebases contain many vulnerabilities. We have created BlackBox, a new container architecture that provides fine-grain protection of application data confidentiality and integrity without trusting the operating system. ==BlackBox introduces a container security monitor, a small trusted computing base that creates protected physical address spaces (PPASes) for each container such that there is no direct information flow from container to OS or other container PPASes.== Indirect information flow can only happen through the monitor, which only copies data between container PPASes and the operating system as system call arguments, encrypting data as needed to protect interprocess communication through the operating system. Containerized applications do not need to be modified, can still make use of operating system services via system calls, yet their CPU and memory state are isolated and protected from other containers and the operating system. We have implemented BlackBox by leveraging Arm hardware virtualization support, using nested paging to enforce PPASes.

# Intro
Popular container mechanisms such as Linux containers rely on a commodity operating system (OS) to enforce their security guarantees. 

Modern systems incorporate hardware security mechanisms to protect application from an untrusted OS, such aas Inter Software Guard Extensions (SGX), but they require rewriting applications and may impose high overhead to use OS services. Some approaches have built on these mechanisms to protect unmodified applications or containers. Unfortunately, they suffer from high overhead, incomplete and limited functionality, and massively increase the trusted computing base (TCB) through a library OS or runtime system, potentially trading one large vulnerable TCB for another.

作为替代方案，虚拟机管理程序已增强了其他机制，以保护应用程序免受不受信任的操作系统的攻击 [11,12,27,35,67]。这会导致基于虚拟机管理程序的虚拟化的性能开销，而容器的设计初衷就是为了避免这种情况。这些系统的 TCB 非常大，在某些情况下包括额外的商品主机操作系统，从而提供了额外的漏洞，可利用这些漏洞来危害应用程序。从理论上讲，这些方法可以应用于具有较小 TCB 的微型虚拟机管理程序 [10,61]。不幸的是，微型虚拟机管理程序仍然继承了基于虚拟机管理程序的虚拟化的复杂性，包括虚拟化和管理硬件资源。TCB 的减少是通过大大减少的功能集和有限的硬件支持来实现的，这使得它们在实践中部署起来很困难。

To address this problem, we have created BlackBox, a new container architecture that provides fine-grain protection of application data confidentiality and intergrity without the need to trust the OS. BlackBox introduces a _container security moniter (CSM)_, a new mechanism that leverages existing hardware feature to enforce container security guarantees in a small trusted computing base (TCB) in lieu of the OS. The monitor creates protected physical address spaces (PPASes) for each container to enforce physical address spaces (PPASes) for each container to enforce physical memory access controls, but provides no virtualization of hardware resources. 监视器为每个容器创建受保护的物理地址空间 (PPAS)，以强制执行物理内存访问控制，但不提供硬件资源的虚拟化。映射到容器 PPAS 的物理内存在 PPAS 之外无法访问，从而在容器和操作系统之间提供物理内存隔离。由于物理内存中的容器私有数据仅驻留在其自己的 PPAS 中的页面上，因此其机密性和完整性受到保护，不受操作系统和其他容器的影响。

CSM 重新利用现有的硬件虚拟化支持，以更高的权限级别运行并创建 PPAS，但其本身并不是虚拟机管理程序，也不会虚拟化硬件。相反，操作系统继续直接访问设备并负责分配资源。这使得 CSM 既简约又简单，同时保持高性能。通过直接支持容器而无需虚拟化，无需在安全执行环境中运行额外的客户操作系统或复杂的运行时，从而最大限度地减少了容器本身内的 TCB。

在 BlackBox 容器中运行的应用程序无需修改，可以通过系统调用使用操作系统服务，同时还可以保护其数据不受操作系统的影响。监视器介入容器和操作系统之间的所有转换，清除 CPU 寄存器中的容器私有数据并根据需要切换 PPAS。内存中的任何容器数据唯一可供操作系统使用的时间是作为系统调用参数，只有监视器本身可以通过在容器 PPAS 和操作系统之间复制参数来提供。监视器了解系统调用语义，并在将系统调用参数传递给操作系统之前根据需要对其进行加密，例如用于进程之间的进程间通信，保护系统调用参数中的容器私有数据不受操作系统的影响。鉴于端到端加密在 I/O 安全方面的使用越来越多[55]，部分原因是斯诺登泄密事件[36]，监视器依靠应用程序加密自己的 I/O 数据来简化其设计。一旦系统调用完成并且允许进程返回其容器之前，监视器会检查 CPU 状态以验证进程，然后再将 CPU 切换回使用容器的 PPAS。

除了确保容器的 CPU 和内存状态在容器外部不可访问外，BlackBox 还可以防止在容器内运行的恶意代码。只有经过签名和加密的受信任二进制文件才能在 BlackBox 容器中运行。监视器需要解密二进制文件，因此它们只能在监视器监督的 BlackBox 容器内运行。监视器在二进制文件运行之前对其进行身份验证，因此不受信任的二进制文件无法在 BlackBox 容器中运行。它还可以防止与内存相关的 Iago 攻击，这种攻击会恶意操纵虚拟和物理内存映射，通过阻止可能覆盖进程堆栈的虚拟或物理内存分配，可能导致容器中进程的任意代码执行。

鉴于 Arm 在个人计算机和云计算基础设施中的应用日益广泛，以及在移动和嵌入式系统上的主导地位，我们在 Arm 硬件上实现了 BlackBox。我们利用 Arm 硬件虚拟化支持，重新利用 Arm 的 EL2 特权级别和嵌套分页（最初设计用于运行虚拟机管理程序），以强制分离 PPAS。与运行虚拟机管理程序的 x86 根操作不同，Arm EL2 具有自己的硬件系统状态。这最大限度地降低了在调用和返回系统调用时捕获到在 EL2 中运行的监视器的成本，因为系统状态不必在每个陷阱上保存和恢复。我们表明，BlackBox 只需对 Linux 内核进行适度修改即可支持广泛使用的 Linux 容器，并从操作系统继承了对各种 Arm 硬件的支持。该实现的 TCB 不到 5K 行代码，外加一个经过验证的加密库，比商用操作系统和虚拟机管理程序少几个数量级。由于尺寸如此小，开发人员可以更轻松地维护 CSM 并确保其正确性，甚至比仅维护虚拟机管理程序的核心虚拟化功能更容易。我们表明，与传统的虚拟机管理程序和容器架构相比，BlackBox 可以提供更细粒度和更强大的安全保障，而实际应用程序工作负载的性能开销仅为中等。

# Threat Model and Assumptions
我们的威胁模型主要关注操作系统漏洞，这些漏洞可能被利用来破坏容器私有数据的机密性或完整性。范围内的攻击包括破坏操作系统或任何其他软件以读取或修改私有容器内存或寄存器状态，包括通过控制支持 DMA 的设备，或通过内存重新映射和别名攻击。我们假设容器不会故意或无意地主动泄露自己的私有数据，但来自其他受损容器的攻击（包括机密性和完整性攻击）都在范围内。受损操作系统的可用性攻击超出了范围。物理或旁道攻击 [5、32、43、52、68、69] 超出了本文的范围。BlackBox 中发生旁道攻击的机会比在较低级别隔离的系统（例如虚拟机）中更大。 BlackBox 的信任边界是操作系统的系统调用 API，这使得对手能够看到操作系统交互的一些细节，例如大小和偏移量。

我们假设安全密钥存储可用，例如由可信平台模块 (TPM) 提供的 [31]。我们假设硬件没有错误，系统最初是良性的，允许在系统受到损害之前安全地存储签名和密钥。我们假设容器使用端到端加密通道来保护其 I/O 数据 [21、37、55]。我们假设 CSM 没有任何漏洞，因此可以信任；正式验证其代码库是未来的工作。我们假设对任何加密容器数据执行暴力攻击在计算上都是不可行的，并且假设任何加密通信协议都旨在防御重放攻击。

# Design
BlackBox 将传统 Linux 容器置于飞地中，以保护容器数据的机密性和完整性。如果 BlackBox 保护容器免受操作系统的影响，我们称该容器为飞地容器。从应用程序的角度来看，使用飞地容器与使用传统容器没有太大区别。应用程序无需修改即可使用飞地容器，并且可以通过系统调用使用操作系统服务。容器管理解决方案 [48,49]（如 Docker [20]）可用于管理飞地容器。BlackBox 旨在支持商用操作系统，尽管使用其飞地机制需要对操作系统进行微小修改，这与通常需要对操作系统进行修改才能利用新硬件功能的方式非常相似。但是，BlackBox 不信任操作系统，运行飞地容器的受损操作系统无法破坏其数据的机密性和完整性。

![[Pasted image 20250318153732.png]]

BlackBox 引入了容器安全监视器 (CSM)，如图 1 所示，它充当其 TCB。CSM 的唯一目的是保护正在使用的容器数据的机密性和完整性。它通过执行两个主要功能（访问控制和验证操作系统操作）来实现这一点。其狭窄的目的和功能使 CSM 能够保持小巧和简单，避免许多其他受信任的系统软件组件的复杂性。例如，与虚拟机管理程序不同，CSM 不会虚拟化或管理硬件资源。它不维护虚拟硬件（例如虚拟 CPU 或设备），从而避免了模拟 CPU 指令、中断或设备的需要。相反，中断直接传递给操作系统，设备由操作系统的现有驱动程序直接管理。它也不执行 CPU 调度或内存分配，因此不提供可用性保证。 CSM 可以保持较小规模，因为它假定操作系统能够感知 CSM，并且依赖操作系统实现复杂的功能，例如引导、CPU 调度、内存管理、文件系统以及中断和设备管理。

为了封装容器，CSM 引入了受保护的物理地址空间 (PPAS) 的概念，即一组独立的物理内存页面，只有 PPAS 的指定所有者和 CSM 才能访问。每个物理内存页面最多映射到一个 PPAS。CSM 使用此机制通过为每个封装容器分配一个单独的 PPAS 来提供内存访问控制，从而将每个容器的物理内存与操作系统和任何其他容器隔离开来。操作系统确定为每个 PPAS 分配了哪些内存，但无法访问 PPAS 的内存内容。同样，容器无法访问它不拥有的 PPAS。未分配给 PPAS 或 CSM 的内存已分配给操作系统并可供操作系统访问。CSM 本身可以访问任何内存，包括分配给 PPAS 的内存。在 PPAS 内，访问内存的地址与机器上的物理地址相同；物理内存不能重新映射到 PPAS 中的其他地址。例如，如果将物理内存的页码 5 分配给 PPAS，它将在 PPAS 内作为页码 5 进行访问。内存中的容器私有数据仅驻留在映射到其自己的 PPAS 的页面上，因此其机密性和完整性受到操作系统和其他容器的保护。第 4 节描述了 BlackBox 如何使用嵌套页表来强制执行 PPAS。

CSM 介入容器和操作系统之间的所有转换，即系统调用、中断和异常，以确保进程和线程（我们统称为任务）在容器上下文中执行时只能访问其所属容器的 PPAS。CSM 确保当任务陷入操作系统并切换到运行操作系统内核代码时，该任务不再有权访问容器的 PPAS。否则，操作系统可能会导致任务访问容器的私有数据，从而损害其机密性或完整性。CSM 维护一个封闭任务数组，该数组包含封闭容器中运行的所有任务的信息。进入操作系统时，CSM 检查调用任务是否在封闭容器中，在这种情况下，它会将 CPU 寄存器和陷阱原因保存到封闭任务数组中，切换出容器的 PPAS，并清除操作系统不需要的任何 CPU 寄存器。退出操作系统时，CSM 检查隔离任务数组，以确定正在运行的任务是否属于隔离容器，在这种情况下，它会验证当前 CPU 上下文（即堆栈指针和页表基址寄存器）是否与隔离任务数组中保存的相应任务相匹配。如果匹配，CSM 会切换到相应容器的 PPAS，以便任务可以访问其隔离 CPU 和内存状态。因此，CPU 寄存器或内存中的容器私有数据无法被操作系统访问。

为了支持传统上需要访问任务的 CPU 状态和内存的 OS 功能，CSM 为 OS 提供了一个应用程序二进制接口 (ABI)，以便 OS 从 CSM 请求服务。CSM ABI 如表 1 所示。例如，create_enclave 和 destroy_enclave 分别由 OS 调用，以响应容器运行时（例如 runC [29]）对 enclave 和 unenclave 容器的请求。对于需要动态分配内存的 CSM 调用，OS 必须分配并传入足够大的连续内存区域的物理地址以执行相应的操作。否则，调用将失败并返回所需的内存量，以便 OS 可以使用所需的分配再次进行调用。例如，create_enclave 要求 OS 分配内存以用于 enclave 容器的元数据。成功后，分配的内存将分配给 CSM，并且操作系统将无法再访问它，直到调用 destroy_enclave，此时内存将再次分配回操作系统。

## 3.1 System Boot and Initiallization
BlackBox 依靠统一可扩展固件接口 (UEFI) 固件及其具有硬件信任根的签名基础设施来启动 CSM。CSM 和 OS 内核链接为单个二进制文件，该二进制文件经过加密签名，通常由运行 BlackBox 容器的云提供商签名；这类似于 Red Hat 或 Microsoft 等供应商对 OS 二进制文件的签名方式。首先使用已存储在安全存储中的密钥验证二进制文件，确保只能加载签名的二进制文件。为了使 CSM 尽可能简单，BlackBox 不会在 CSM 本身内实现引导，这可能需要数千行代码来支持许多系统。相反，它依靠操作系统的引导代码在启动时安全地安装 CSM，因为操作系统最初是良性的。通过依赖已经在各种系统上启动的商用操作系统（例如 Linux），CSM 可以更轻松地支持许多系统，而无需为许多系统手动维护和移植自己的引导代码。

在启动时，操作系统最初完全控制系统以初始化硬件，并安装 CSM。CSM 的安装发生在本地存储、网络和串行输入服务可用之前，因此远程攻击者无法破坏其安装。安装后，CSM 以比操作系统更高的权限级别运行，随后根据需要启用 PPAS。一小部分物理内存被静态分配给 CSM，其余分配给操作系统。除 CSM 本身外，任何访问 CSM 内存的尝试都将陷入 CSM 并被拒绝。尽管操作系统的内存与 CSM 的内存是分开的，但 CSM 可以访问操作系统的内存，并且可以在需要时限制其修改自己的内存。

CSM 希望硬件包含一个 IOMMU，以防止 OS 管理的设备发起 DMA 攻击 [62]。CSM 保留对 IOMMU 的控制权，并要求 OS 进行 CSM 调用以更新 IOMMU 页表映射，这些映射通常由 OS 在启动期间配置。这可确保 I/O 设备只能访问映射到 CSM 管理的 IOMMU 页表中的内存。OS 在启动期间调用 alloc_iopgtable 为设备分配 IOMMU 转换单元及其相关页表，并调用 set_iopt 为设备分配物理内存以用于 DMA。CSM 确保 OS 只能将其自己的物理内存分配给 IOMMU 页表，从而确保 DMA 攻击不能用于危害 CSM 或容器内存。


## 3.2 Enclaved Container Initialization
为了安全地初始化 enclaved 容器，必须首先将要用于此类容器的映像处理为 BlackBox 容器映像，其过程类似于使用 Docker 映像创建 Amazon enclave 的过程 [1]。BlackBox 提供了一个命令行工具 build_bb_image，可供云客户使用，该工具获取 Docker 映像，查找映像中包含的所有可执行二进制文件，并使用与存储在主机安全存储中且只有 CSM 可访问的受信任私钥配对的公钥加密包含代码和代码使用的数据的部分。然后对这些加密部分进行哈希处理，并将其哈希值与它们所属的二进制文件一起记录下来。然后使用容器映像创建者的私钥对这些值进行签名，其配对的公钥可在主机的安全存储中访问以确保真实性，并与容器映像捆绑在一起，以供以后在进程创建过程中引用，如第 3.3 节所述。这确保了二进制文件无法在未被检测到的情况下被修改，或除非 CSM 解密，否则无法运行。除了额外的哈希值和使用加密二进制文件外，BlackBox 容器映像与传统 Docker 映像没有任何不同。

要使用 BlackBox 容器镜像启动容器，需要修改容器运行时以执行简单的 shim 进程来代替容器指定的 init 进程。容器运行时将容器使用的 init 进程的路径以及任何参数及其环境传递给 shim。shim 还会获得与容器镜像捆绑在一起的签名二进制哈希信息。shim 进程运行一个微小的静态链接程序，该程序在执行原始 init 进程之前向操作系统发起调用 create_enclave CSM 调用的请求，并将签名的哈希信息作为调用的一部分传递给 CSM。除了在执行 init 进程时退出的 shim 进程之外，除了 vanilla Linux 容器之外，BlackBox 容器中没有其他运行的代码。没有额外的库，也不需要库操作系统，从而避免了容器本身的 TCB 膨胀的风险。

create_enclave 使用 Black-Box 容器映像创建一个新的 enclave，并返回在 enclave 容器中运行的调用进程，调用的返回值是新 enclave 的标识符。create_enclave 执行以下步骤。首先，它为容器创建一个新的 PPAS。其次，它冻结调用进程的用户空间内存，以便它及其关联的页表不能被操作系统直接更改，然后将其所有物理内存页面移动到容器的 PPAS 中，以便操作系统不再可访问它们。最后，它根据已知哈希检查内存中已加载的 shim 二进制文件的内容，以验证调用进程是否是预期的 shim 进程。

从 create_enclave 返回后，shim 从容器内部执行容器的 init 进程。由于容器的 init 进程从 BlackBox 容器映像（其代码和数据已加密）获取其可执行文件，因此操作系统可以加载它，但如果没有 CSM 使用其私钥对其进行解密，则无法实际执行它。第 3.6 节介绍了有关使用加密二进制文件的 exec 的更多详细信息。这样，如果没有 CSM，操作系统就无法运行 BlackBox 容器映像。因此，如果它正在运行，CSM 必须参与并保护它。由于 CSM 本身是安全启动的，并且 enclave 代码是加密的，并且只能由 CSM 运行，因此建立了一个不间断的信任链，从而实现了类似于其他安全系统（如 Samsung Knox [56]）的远程证明。

容器运行时调用 destroy_enclave 来移除容器的 enclave，这会终止容器内所有正在运行的进程和线程，以确保在移除 enclave 之前清除所有容器 CPU 状态和内存，并且操作系统或任何其他容器都无法访问这些内存。容器实际上会返回到调用 create_enclave 之前的状态。

## 3.3 Enclaved Task Execution
BlackBox 支持在封闭容器中执行的任务的完整生命周期，包括通过标准系统调用（如 fork、clone、exec 和 exit）动态创建和终止任务。这包括跟踪哪些任务被允许在哪些容器中执行。这是通过要求操作系统调用一组 CSM 调用来实现的，在通过 fork 和 clone 创建任务时调用 task_clone，在通过 exec 加载新地址空间时调用 task_exec，在任务通过 exit 退出时调用 task_exit。这些调用请求 CSM 执行与任务执行相关的各种功能，而操作系统无法执行这些功能，因为它无法访问任务 CPU 状态和内存。如果操作系统没有进行相应的 CSM 调用，则创建的任务和执行的二进制文件将不会在其封闭空间中运行，因此将无法访问其数据。这些调用更新封闭任务数组，该数组的索引用作封闭任务标识符。数组中的每个条目都包括执行任务的容器的安全区标识符，以及前面讨论过的任务使用的页表的地址。

当在封闭容器中运行的任务通过系统调用创建子任务时，操作系统将使用调用任务的封闭任务标识符和一个标志来调用 task_clone，该标志指示新任务是否与调用者共享相同的地址空间（如创建线程时）或拥有调用者地址空间的副本（如创建进程时）。在后一种情况下，将为子任务分配新的页表，CSM 将确保它们与调用者的页表匹配，并且不能被操作系统直接修​​改。CSM 还将确认调用任务发出了任务创建系统调用。如果所有检查都通过，CSM 将在封闭任务数组中创建一个新条目，其封闭标识符与调用进程相同，并返回新条目的数组索引作为任务的标识符。该条目还将包含任务页表的地址，如果它与调用者共享相同的地址空间，则该地址将与调用者的条目相同。

当操作系统运行子进程并且任务从操作系统返回时，操作系统会向 CSM 提供封闭任务的标识符。然后，CSM 使用此标识符在其封闭任务数组中查找任务，并确认存储在条目中的页表地址与存储在 CPU 页表基址寄存器中的地址相匹配。如果检查通过，它将恢复 CPU 状态并将 CPU 切换到容器的 PPAS，从而允许任务在容器中恢复执行。如果操作系统不调用 task_clone，则在退出操作系统时，任务的 PPAS 将不会安装，并且无法运行。

在 exec 上，调用任务将用新地址空间替换其现有地址空间。操作系统调用 task_exec，它与 fork 的 task_clone 一样，创建一个具有新地址空间的新封闭任务条目。不同之处在于，通过确保新进程的堆栈按预期设置并且可执行二进制文件已签名并位于 BlackBox 容器映像中来验证新地址空间，如第 3.6 节所述。创建新的封闭任务条目后，原始地址空间与容器分离，清除任何要返回操作系统的内存页面并将其从容器的 PPAS 中删除。

## 3.4 Memory
BlackBox 阻止操作系统直接访问容器的内存，但依赖操作系统进行内存管理，包括为容器中的任务分配内存。这避免了在 BlackBox 中引入复杂的内存管理代码，使其保持小巧和简单，但这意味着 BlackBox 还需要通过操纵系统调用返回值来防止不受信任的操作系统发起基于内存的 Iago 攻击 [9]。例如，如果进程调用 mmap，它希望收到一个不与其任何现有映射重叠的地址映射。如果操作系统返回一个与进程堆栈重叠的值，它可以通过随后使用攻击者控制的地址进行读取来操纵进程覆盖其堆栈上的返回地址，从而为返回导向编程 [53] 和 return-into-libc [58] 攻击打开大门。此外，操作系统可能会从 mmap 返回一个看似无害的非重叠虚拟地址，但仍然会恶意将返回的地址映射到堆栈所在的物理页面。

为了在防止基于内存的 Iago 攻击的同时依靠操作系统进行内存管理，BlackBox 通过阻止操作系统直接更新每个进程的页表来保护应用程序级别的容器内存。相反，它要求操作系统向 CSM 发出请求以更新进程页表，从而允许 CSM 在操作系统行为不正确时拒绝更新。图 2 描述了在页面错误期间如何更新容器的页表。当容器中的进程在页面上发生错误时，异常会导致控制权通过 CSM 转移到操作系统（步骤 1-3）。然后，操作系统为进程分配一个页面，但不是直接更新进程页表，而是执行 set_pt CSM 调用（步骤 4）。在收到 set_pt 调用后，CSM 会验证分配是否可接受（步骤 5）。为此，CSM 为每个进程维护一个有效映射列表。此列表通过插入调整内存映射的系统调用来维护。在 Linux 中，这些调用包括 mmapand brk。在写入页表条目之前，CSM 首先验证指定的虚拟地址是否属于有效映射。如果不是，则拒绝更新。其次，CSM 检查分配的物理页面是否已经在容器的 PPAS 中，因此已经在使用中。这通常会无害地发生，例如，当容器中的两个进程在其地址空间中映射了相同的文件时。但是，为了防止恶意操作系统通过恶意内存分配强迫 enclave 覆盖现有内存的风险，CSM 将容器的 PPAS 中任何多次映射的物理页面标记为只读，除非它是从父级继承的，作为进程创建的一部分，在这种情况下它是可信的。虽然这可以有效地防止这些攻击，但缺点是对此类内存的写入将陷入困境，需要由 BlackBox 处理；为简单起见，BlackBox 不允许可写内存映射文件 I/O，因为它不常用。最后，如果虚拟地址有效且未映射到容器 PPAS 中的现有物理页面，则 CSM 取消映射 OS 中分配的物理页面并将其映射到容器的 PPAS。然后，CSM 代表 OS 更新页表条目（步骤 6）。然后将控制权返回给 OS（步骤 7）。当将控制权返回到发生故障的进程时，将切换到该进程的容器 PPAS（步骤 8-10）。第 4 节描述了有关此过程的更多详细信息。CSM 还会在执行页表更新时根据需要使 TLB 条目无效，从而确保恶意 OS 无法通过陈旧的 TLB 条目破坏容器的 PPAS。
![[Pasted image 20250401115927.png]]

BlackBox 提供对写时复制 (CoW) 内存的支持，这是操作系统中常用的一项关键优化。操作系统传统上希望能够在多个进程之间共享内存中的页面，并且在尝试写入时，通过将页面的内容复制到分配给进程的新页面来中断 CoW。但是，使用 BlackBox，操作系统无法复制容器内存，因此操作系统改为进行 copy_page CSM 调用，让 CSM 代表其执行 CoW 中断。CSM 将检查源页面是否属于容器的 PPAS，并且目标页面是否在操作系统的内存中。如果是，它将把目标页面移动到容器的 PPAS 中并执行复制。

BlackBox 支持在任务调整其堆、取消映射内存区域和退出时动态将内存释放回操作系统，同时保护容器内存的隐私和完整性。与内存分配一样，可以允许返回应用程序内存的系统调用（如 munmap 和 \_exit）会被跟踪，以保持对容器内存映射的准确视图。在这些调用期间，操作系统可能会尝试释放分配给进程的页面。在这样做时，与内存分配一样，它必须使用 set_pt CSM 调用，因为它无法直接更新页表。然后，CSM 将检查应用程序是否已调用释放指定的内存，如果没有，则拒绝更新。如果更新有效，CSM 将执行页表更新，如果不再需要，则清除页面并将其从容器的 PPAS 中删除。

虽然 BlackBox 确保容器内存无法被操作系统访问，但许多通过系统调用进行的操作系统交互都期望使用作为应用程序内存一部分的内存缓冲区来向操作系统发送数据或从操作系统接收数据。BlackBox 将系统调用中此类内存缓冲区的使用视为隐式指令，以解密缓冲区，以便与操作系统共享。为了支持这种解密，同时确保容器的 PPAS 无法被操作系统访问，BlackBox 为在封闭容器中运行的每个任务提供了一个系统调用缓冲区，该容器位于容器的 PPAS 之外，可供操作系统访问。在介入系统调用异常时，CSM 将作为系统调用参数传入的内存缓冲区的引用替换为任务的系统调用缓冲区的引用。对于用于向操作系统发送数据的缓冲区，这些缓冲区中的数据也会被复制到系统调用缓冲区。返回容器时，对系统调用缓冲区的引用将替换为对原始内存缓冲区的引用。对于用于从操作系统接收数据的缓冲区，系统调用缓冲区中的数据也会复制到原始内存缓冲区。

大多数系统调用都由 CSM 中的一个通用包装函数插入，该函数使用系统调用元数据表来确定必须更改哪些参数。具有更复杂参数的系统调用（例如涉及 iovec 结构的系统调用）则由更具体的包装函数插入。在 Linux 上，这种插入和更改参数的方式适用于大多数系统调用，但有一些值得注意的例外，如第 3.5 节所述。

作为将数据从操作系统复制到封闭容器的一部分，BlackBox 还对系统调用返回值进行简单检查，以确保它们在预定义的正确范围内。这已被证明可以防止许多 Iago 攻击 [14]。但是，为了保持其 TCB 简单而小巧，BlackBox 仅保证内存管理和进程间通信 (IPC) 的系统调用语义的正确性，后者在第 3.5 节中讨论。因此，BlackBox 可以防止与内存管理和 IPC 相关的 Iago 攻击，但容易受到其他一些 Iago 攻击。在封闭容器中使用用户级运行时库增强 BlackBox 可以保证系统调用语义的正确性，这可以提高 Iago 攻击保护，但代价是更大的 TCB 和系统调用功能的潜在额外限制。

## 3.5 Inter-process Communucation
BlackBox 将作为系统调用参数传入操作系统的数据解密，同时通过加密传入 IPC 相关系统调用的数据来保护在同一封闭容器中运行的任务之间的进程间通信 (IPC)。这保护了使用 IPC 的应用程序，这些应用程序通过操作系统传输并可供操作系统访问。可以创建 IPC 相关文件描述符的系统调用（例如管道和 Unix 域套接字）被插入，并且它们返回的文件描述符 (FD) 被记录在每个进程的数组中，标记为与 IPC 相关。当 CSM 插入通过 FD 传递数据的系统调用（如 write 和 sendmsg）时，它会检查给定的 FD 是否与该进程的 IPC 相关。如果是，CSM 首先使用经过身份验证的加密，使用在容器初始化期间创建的随机生成的对称密钥来加密数据，然后再将其移动到任务的系统调用缓冲区中。记录计数器在每次交易时递增，作为额外的认证数据，以防止主机重放以前的交易。同样，在将数据复制到调用进程的 PPAS 之前，在插入 read 和 recvmsg 等系统调用时，数据会被解密和认证。通过这种机制，IPC 通信可以透明地加密，并免受操作系统的攻击。

如第 3.4 节所述，为了避免信任操作系统的内存分配，容器中多个进程使用的内存页面在容器的 PPAS 中标记为只读，除非已知这些页面属于共享内存映射并在进程创建期间继承。父进程通过 mmap 使用 MAP_SHARED 创建并在分叉之前发生故障的共享内存区域可以由父进程和子进程写入，因为子进程的地址空间在分叉后得到验证，如第 3.3 节所述。但是，为简单起见，BlackBox 不允许通过 XSI IPC 方法（例如 shmget 和 shm_open）写入可写 IPC 共享内存，这些方法不再广泛使用。现代应用程序倾向于基于线程的方法以提高性能，或通过与 BlackBox 兼容的 mmap 在子工作进程之间进行共享映射。

Futex 用于线程和进程之间，以同步对共享内存区域的访问。作为 futex 设计的一部分，操作系统需要读取 futex 值，该值位于进程的地址空间中，并包含在相应容器的内存中。这种对容器内存的直接访问与 BlackBox 的内存隔离不兼容。为了支持 futex，操作系统会进行 futex_read CSM 调用以获取容器进程的 futex 值，而不是尝试直接访问内存。CSM 确保只有传递给 futex 的 futex 地址才能被读取，并且只有在进行了 futex 调用后才能读取。

信号用于将各种事件通知进程，它给 BlackBox 带来了两个问题。首先，在向进程传递信号时，会在进程的内存中为信号处理程序设置一个临时堆栈。对于封闭式容器，操作系统无法访问此内存。为了解决这个问题，操作系统进行了修改，将此堆栈设置在容器 PPAS 之外的内存区域中，然后在执行信号处理程序时将其移动到 PPAS，并在信号处理程序通过 rt_sigreturn 返回时返回操作系统。其次，操作系统必须调整进程的控制流以执行信号处理程序，而不是返回到之前执行的位置。BlackBox 不能允许操作系统在未验证其是否正确执行的情况下调整封闭式进程的控制流。为了实现这一点，作为 CSM 介入系统调用的一部分，它通过系统调用（如 rt_sigaction）跟踪信号处理程序的安装。处理信号后，CSM 确保进程将正确返回到已注册的处理程序。

## 3.6 Container File System
容器内的文件只能通过操作系统的 I/O 设施进行访问，因此，如果没有额外的保护，对容器文件的访问本质上是不可信的。用户空间加密文件系统可能用于提供文件 I/O 的透明保护，但这可能会显著增加容器的 TCB。BlackBox 依靠应用程序使用加密来完全保护容器内的敏感数据文件，并提供一种简单的机制，允许操作系统加载加密的可执行二进制文件以供执行。

如第 3.2 节所述，BlackBox 的容器镜像经过预处理。例如，在 Linux 上广泛使用的 ELF 二进制文件具有 .text、.data 和 .rodata 部分，其中包含可执行代码和代码使用的数据。这些部分在加载到内存中时会组合成各种段。在 BlackBox 容器镜像中，ELF 标头未加密，但 .text、.data 和 .rodata 部分已加密然后进行哈希处理，并且它们的哈希值与二进制文件一起记录。这使 BlackBox 能够验证可执行二进制文件的完整性和真实性。

ELF 二进制文件由操作系统执行，这是进程调用 exec 的结果，操作系统通过将其 ELF 标头映射到内存中来加载二进制文件，读取 ELF 标头以确定如何处理二进制文件的其余部分，然后将二进制文件的段映射到内存。如第 3.3 节所述，操作系统需要调用 task_exec，它将包含 .text、.data 和 .rodata 部分的二进制文件加载段的虚拟地址传递给 CSM。在此调用期间，CSM 将与加载的二进制文件相对应的进程页面移动到容器的 PPAS 中，验证加密的 .text、.data 和 .rodata 部分的哈希值是否与来自 BlackBox 容器映像的给定二进制文件的哈希值匹配，以确认加载段的真实性和完整性，然后解密内存中的部分。这些二进制段的虚拟到物理地址映射被记录下来以供以后使用。从 task_exec 返回后，操作系统将开始运行该任务，该任务的二进制文件现在已在受保护的容器内存中解密。
如果检查哈希值或解密失败，CSM 将拒绝在封闭容器内运行二进制文件，
确保只有受信任的二进制文件才能在其中运行。

对于动态链接的二进制文件，除了操作系统在执行期间映射的二进制段之外，操作系统还会将加载程序的段映射到进程的地址空间中。这些段的验证方式与二进制段的验证方式相同。动态链接的二进制文件加载并执行外部库，BlackBox 必须验证这些库是否符合预期且值得信赖。在容器映像创建过程中，与可执行二进制文件一样，库二进制文件也会被加密，以防止在没有 CSM 的情况下使用它们。这些库在运行时由作为受信任容器映像一部分的加载程序在用户空间中加载和链接。为此，加载程序作为进程地址空间的一部分运行，将库段映射到内存中。CSM 通过介入与 FD 相关的系统调用（例如 open）来拦截这些 mmap。如果为容器中的某个库创建了 FD，如在容器映像创建期间记录的那样，CSM 会将该 FD 标记为与给定的库相关联。如果此 FD 随后与 mmap 一起使用，则 CSM 会拦截它。根据 mmap 请求的大小和使用的保护标志，CSM 可以推断加载器正在映射哪个段。如果它是包含加密部分之一的段，则 CSM 执行与可执行二进制文件相同的散列、解密和内存映射记录。

# 4 Implementation
我们通过重新利用现代架构上现有的硬件虚拟化支持（包括通常为虚拟机管理程序保留的更高特权级别）和嵌套页表 (NPT) 实现了 BlackBox 原型。NPT 也称为 Arm 的第 2 阶段页表和英特尔的扩展页表 (EPT)，是一种硬件辅助虚拟化技术，引入了额外的虚拟地址转换级别 [8]。当虚拟机管理程序使用 NPT 时，VM 中的客户操作系统会管理自己的页表，以将虚拟地址转换为 VM 认为的物理地址（称为客户物理地址），但随后虚拟机管理程序会管理 NPT 以将客户物理地址转换为主机上的实际物理地址。因此，虚拟机管理程序可以使用 NPT 来控制每个 VM 可用的物理内存。

BlackBox 使用硬件虚拟化支持来运行 CSM，而不是虚拟机管理程序来支持 PPAS。CSM 在更高的虚拟机管理程序特权级别上运行，因此它比操作系统具有更高的特权，并且能够控制 NPT。CSM 为每个容器和操作系统引入一个 NPT，这样容器的 PPAS 仅映射到其自己的 NPT，从而将每个容器的物理内存与操作系统和彼此隔离。CSM 通过简单地更新其 NPT 基址寄存器以指向相应容器的 NPT，将 CPU 从一个 PPAS 切换到另一个 PPAS。同样，CSM 使用 NPT 来保护自己的内存免受操作系统和容器的影响，只需不将其自己的内存映射到 NPT 中即可。NPT 的内存是 CSM 受保护内存的一部分，本身不会映射到任何 NPT 中，因此只有 CSM 可以更新 NPT。当 CSM 运行时，
NPT 被禁用，因此它可以完全访问物理内存。

具体来说，BlackBox 使用 Arm 硬件虚拟化扩展 (VE) [16–19]。CSM 在 Arm 的虚拟机管理程序 (EL2) 模式下运行，该模式严格来说比用户 (EL0) 和内核 (EL1) 模式具有更高的特权。EL2 具有由寄存器和控制状态定义的自己的执行上下文，并且 EL0 和 EL1 的执行上下文切换是在软件中完成的。CSM 配置 EL2 中的第 2 阶段页表和系统内存管理单元 (SMMU)，即 Arm 的 IOMMU。Linux 内核在 EL1 中运行，无法访问 EL2 寄存器，因此它无法危及 CSM。CSM 调用是使用 EL1 中的 Arm 的 hvc 指令进行的。

在每次转换到操作系统之前和之后，BlackBox 都会陷入 CSM，而 CSM 又会在容器和操作系统 NPT 之间切换。有人可能会认为，对 CSM 施加两次上下文切换以在每次调用操作系统时交换 NPT 会非常昂贵，但我们在第 5 节中展示了这可以在 Arm 上完成而无需太多开销。Arm EL2 提供的灵活性允许软件确定如何在虚拟机管理程序和其他模式之间切换执行上下文，这对于实现 CSM 特别有利，因为它不会将其实现锁定在使用重量级硬件虚拟化机制来保存和恢复 CSM 不需要的虚拟机管理程序执行上下文。

在每次转换到操作系统之前和之后捕获到 CSM 需要 CSM 介入所有系统调用、中断和异常。虚拟机管理程序传统上通过将中断和异常捕获到自身，然后将虚拟中断和异常注入虚拟机来实现类似的功能。BlackBox 通过采用不同的方法避免了虚拟化中断和异常的额外复杂性。CSM 配置硬件，以便系统调用、中断和异常捕获到操作系统，并修改操作系统的异常向量表以处理这些事件，以便始终在实际操作系统事件处理程序之前和之后进行 enter_os 和 exit_os CSM 调用。为了保证这些处理程序已安装并且不会在以后被操作系统修改，BlackBox 要求操作系统在系统初始化期间使用向量表文本部分的地址进行 protect_vectors CSM 调用，然后才可以封装任何容器。然后，CSM 通过在操作系统的 NPT 中将其后备物理内存标记为只读，防止操作系统篡改修改后的向量表。同样，内存的 vDSO 区域被标记为只读，以防止恶意篡改该区域。

图 3 描述了在重新利用虚拟化硬件时介入容器和操作系统之间的转换所涉及的步骤。在容器中运行时，发生异常，将控制权转移到受保护的操作系统异常向量表（步骤 1）。异常向量表中的所有入口点都会调用 enter_osCSM 调用（步骤 2）。在此期间，CSM 切换到操作系统的 NPT（步骤 3）。因此，操作系统将无法访问映射到容器 NPT 的私有物理内存。对于系统调用异常，系统调用参数被复制到操作系统可访问的系统调用缓冲区（步骤 4）。控制权被转移回操作系统（步骤 5）以执行所需的异常处理。当操作系统完成异常处理后，exit_os CSM 调用将作为异常向量返回用户空间时返回路径的一部分进行（步骤 6）。对于系统调用异常，操作系统更新的参数被复制回原始缓冲区（步骤 7）。在 exit_os 上，CSM 验证异常返回地址以确保调用来自受信任的异常向量，操作系统无法更改这些向量，并拒绝任何不可信的异常向量。然后，CSM 检查正在运行的任务是否属于封闭容器，在这种情况下，CSM 切换到相应容器的 NPT，以便任务可以访问其 PPAS 内存状态（步骤 8）。通过从 exit_os 返回（步骤 9）并返回到用户空间（步骤 10），将控制权恢复到容器。如果没有调用 exit_os，CSM 将不会切换 CPU 以使用容器的 PPAS，因此其状态将在该 CPU 上保持不可访问。

BlackBox 通过为操作系统和每个容器使用单独的 NPT 来保护容器的内存，但仍然依赖操作系统执行所有复杂的内存管理功能（例如分配和回收），以最大限度地降低 CSM 的复杂性和大小。这很简单，因为与使用 NPT 虚拟化物理内存的虚拟机管理程序不同，CSM 仅使用 NPT 进行访问控制，以便身份映射用于所有 NPT，包括操作系统的 NPT。对于映射到操作系统 NPT 中的任何物理内存，操作系统对内存的看法实际上与实际物理内存相同。除了 CSM 的物理内存外，所有物理内存最初都分配给操作系统并映射到其 NPT。当操作系统将物理内存分配给容器中的进程时，CSM 只需将物理内存从操作系统的 NPT 取消映射，并将其映射到同一地址的相应容器的 NPT。CSM 不需要自己的复杂分配功能。 CSM 检查操作系统的 NPT，以确保操作系统有权分配给定的内存页面。例如，如果操作系统尝试分配属于 CSM 的物理页面，CSM 将拒绝分配并且不会更新操作系统或容器的 NPT。CSM 还会检查操作系统为容器提出的任何页面分配是否未映射到 IOMMU 页表中，因此不会受到 DMA 攻击，如第 3.1 节所述。

![[Pasted image 20250401125742.png]]
请注意，操作系统没有意识到，其针对进程页表（Arm 的第 1 阶段页表）的分配决策也用于第 2 阶段页表。此外，由于 Arm 硬件首先检查第 1 阶段页表，然后再检查第 2 阶段页表，因此由于需要为进程分配物理内存而导致的页面错误都显示为第 1 阶段页面错误，这些错误由操作系统的页面错误处理程序以正常方式处理。由于 CSM 同时将物理内存映射到相应的第 1 阶段和第 2 阶段页表条目，因此内存分配不会出现第 2 阶段页面错误。

如第 3.4 节所述，BlackBox 要求 OS 不能直接修改进程页表。同时，Linux 等商用 OS 执行许多涉及遍历和访问进程页表的操作。为了最大限度地减少使用封闭容器所需的 OS 修改，BlackBox 通过将 OS 的 NPT 中的相应条目标记为只读，使进程页表可读但不能由 OS 写入。遍历和读取进程页表的所有现有 OS 代码都可以继续运行而无需修改，并且 OS 只需进行有限的更改即可使用 CSM 调用对进程页表进行任何更新。进程的页表也映射到其各自容器的 NPT，因此在执行进程时，MMU 硬件可以访问它们以进行虚拟地址转换。BlackBox 还将任务的系统调用缓冲区（用于将系统调用参数传递到操作系统和从操作系统传递出来）映射到它们的第 1 阶段页表。这样，用于将数据复制到调用进程地址空间中的缓冲区或从缓冲区复制数据的 OS 函数无需修改即可正常运行。任务的系统调用缓冲区本身仅映射到 OS 的 NPT，而不是容器的 NPT，因为它们仅由 CSM 和 OS 直接共享。

为了优化 TLB 使用率，可以将物理上连续的内存映射到大于默认 4 KB 页面大小的块中的 NPT。BlackBox 实现支持透明的 2 MB 第 2 阶段块映射，方法是首先用 4 KB 映射完全填充最后一级第 2 阶段页表，然后将所有 512 个条目折叠成一个条目。BlackBox 检查所有 512 个条目在物理内存中是否连续，以及第一个条目是否与 2 MB 边界对齐。如果原始 512 个条目中的一个未映射，BlackBox 将展开块映射，这样所有 512 个条目在物理内存中就不再连续。同样，如果需要更改原始 512 个条目之一的属性，例如将其标记为只读而其他条目保持可写，BlackBox 将展开块映射。这种方法比仅支持操作系统分配的大页面更有优势，因为即使操作系统不使用大页面，它也能提高 TLB 的使用率。

尽管 BlackBox 的设计目标是使用现有的硬件虚拟化支持，但即将推出的 Armv9 架构及其包含的 Arm 机密计算架构 (CCA) [41] 提供了可用于实现 BlackBox 的替代机制。CCA 引入了称为 Realms 的安全执行环境。这些 Realms 的内存和执行状态对于现有的特权软件（如操作系统和虚拟机管理程序）来说是无法访问的，从而保证了它们的机密性和完整性。Realms 由单独的 Realm World 支持，并由 Realm World 中 EL2 中运行的 Realm Management Monitor (RMM) 管理，使其可以完全访问 Realm 内存和 CPU 状态以及控制它们的执行。尽管 Realms 目前仅设计为支持虚拟机，但可以通过将 CSM 的功能与 RMM 集成并扩展其 ABI 以包含 CSM 的 ABI，使用它们来支持封闭容器。

todo

### BlackBox容器安全监控系统关键总结

#### 一、核心创新与架构设计

1. **容器安全监控器（CSM）**
    - 作为可信计算基（TCB），仅约5K行代码，显著小于传统OS/虚拟机监控器。
    - 不虚拟化硬件资源，仅通过**受保护物理地址空间（PPAS）**实现内存隔离。
    - 利用ARM EL2特权级和嵌套分页（Nested Paging）强制隔离容器内存。
2. **物理地址空间保护（PPAS）**
    - 每个容器独占一个PPAS，物理内存页仅允许所属容器和CSM访问。
    - 通过硬件机制阻止操作系统和其他容器直接访问受保护内存。
    - 内存地址在PPAS内与物理地址一致，避免重映射攻击。
3. **系统调用与上下文切换**
    - 拦截所有容器与OS的交互（系统调用、中断、异常），清除寄存器残留数据。
    - 仅在系统调用参数传递时复制数据，并通过加密保护跨容器通信。
    - 维护"enclaved task array"记录任务状态，验证上下文完整性。

#### 二、安全机制与威胁防护

1. **数据保护层级**
    - **内存隔离**：物理内存按PPAS划分，阻止越界访问。
    - **CPU状态保护**：切换上下文时清除敏感寄存器数据。
    - **加密传输**：系统调用参数加密，依赖应用层端到端加密保障I/O安全。
2. **攻击防御能力**
    - 防范操作系统漏洞利用（如内存读取/篡改、DMA攻击）。
    - 阻止恶意容器间的横向渗透（信息流仅通过CSM可控复制）。
    - 通过签名验证和内存分配限制抵御Iago攻击（堆栈覆盖攻击）。
3. **可信启动与密钥管理**
    - 依赖UEFI安全启动验证CSM和OS镜像签名。
    - 密钥存储基于TPM等硬件安全模块，防止离线破解。

#### 三、实现与性能

1. **ARM硬件支持**
    - 利用EL2特权级的独立系统状态，减少上下文切换开销。
    - 嵌套分页实现PPAS隔离，无需修改容器化应用。
2. **兼容性与扩展性**
    - 支持主流Linux容器（如Docker），仅需少量内核修改。
    - 继承OS对硬件驱动的支持，避免重复开发设备管理模块。
3. **性能表现**
    - 系统调用延迟优化：EL2硬件状态保留减少寄存器保存/恢复操作。
    - 实测应用负载下性能损失有限（具体数据未提供但强调"modest overhead"）。
![[Pasted image 20250318153012.png]]
#### 五、局限性及未来方向
1. **未覆盖的攻击面**
    - 侧信道攻击（如缓存计时攻击）未被防御。
    - 假设硬件无漏洞，实际部署需结合其他防护措施。
2. **功能限制**
    - 不提供可用性保障（OS仍可拒绝服务）。
    - 依赖应用层实现I/O加密，未内置全链路加密。
3. **验证与扩展**
    - CSM代码尚未形式化验证（论文提及为未来工作）。
    - 当前仅支持ARM架构，x86移植需评估可行性。

> **总结**：BlackBox通过极简的TCB设计和硬件辅助隔离机制，在保持容器轻量级特性的同时，实现了接近虚拟机的安全强度。其创新点在于重新定义容器与OS的信任边界，为云原生场景下对抗不可信操作系统提供了新思路。

